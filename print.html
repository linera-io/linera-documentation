<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="The Linera Manual">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-d0866e17.css">
        <link rel="stylesheet" href="css/general-e9745eeb.css">
        <link rel="stylesheet" href="css/chrome-d7ced664.css">
        <link rel="stylesheet" href="css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome-799aeb25.css">
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/theme-864c5258.css">
        <link rel="stylesheet" href="./mdbook-admonish.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-2a6c6635.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const html = document.documentElement;
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/linera-io/linera-documentation" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/linera_banner_db73e9b.svg" alt="The Linera banner" /></p>
<h1 id="the-linera-manual"><a class="header" href="#the-linera-manual">The Linera Manual</a></h1>
<p>Welcome to the reference manual of Linera, the decentralized protocol for
<strong>real-time Web3 applications</strong>.</p>
<p>This documentation is split into three main parts:</p>
<ol>
<li>
<p>The first section gives a <a href="protocol/overview.html">high-level overview</a> of the
protocol.</p>
</li>
<li>
<p>The second section is intended for
<a href="developers/getting_started.html">developers</a> building applications using the
Linera Rust SDK.</p>
</li>
<li>
<p>The third section is intended for <a href="operators/devnets.html">operators</a> who wish
to run Linera validators.</p>
</li>
</ol>
<blockquote>
<p><strong>NEW: Publish and test your Web3 application on the Linera Testnet!</strong></p>
<p>Install
<a href="developers/getting_started/installation.html#installing-from-cratesio">the Linera CLI tool</a>
then follow the instructions on
<a href="developers/getting_started/hello_linera.html#using-the-testnet">this page</a> to
claim a microchain and publish your first application on the current Testnet.</p>
</blockquote>
<p>To join our community and get involved in the development of the Linera
ecosystem, check out our
<a href="https://github.com/linera-io/linera-protocol">GitHub repository</a>, our
<a href="https://linera.io">Website</a>, and find us on social media channels such as
<a href="https://www.youtube.com/@linera_io">YouTube</a>, <a href="https://x.com/linera_io">X</a>,
<a href="https://t.me/linera_official">Telegram</a>, and
<a href="https://discord.gg/linera">Discord</a>.</p>
<p>You can also find high-level introductory and extended concepts discussed and
explained in video format in our
<a href="https://www.youtube.com/watch?v=0pym5NkVLWs&amp;list=PLdGxlJxLrfgIk7KsD88FnhILcnnzjyoYK">Developer Workshops series on YouTube</a>.</p>
<p><em>Let's get started!</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Linera is a decentralized protocol optimized for real-time, agentic Web3
applications that require guaranteed performance for an unlimited number of
active users.</p>
<p>The core idea of the <a href="https://linera.io/whitepaper">Linera protocol</a> is to run
many chains of blocks, called <strong>microchains</strong>, in parallel in one set of
validators.</p>
<h2 id="how-do-microchains-work"><a class="header" href="#how-do-microchains-work">How do microchains work?</a></h2>
<p>Linera users propose blocks directly to the chains that they <strong>own</strong>. Chains may
also be shared with other users. Linera validators ensure that all blocks are
validated and finalized in the same way across all the chains.</p>
<pre class="mermaid">    flowchart LR
        user([&quot;User wallet&quot;])
        provider([&quot;Provider&quot;])
        validators([&quot;Validators&quot;])
        subgraph &quot;Validators&quot;
          chain1[&quot;Personal chain&quot;]
          chain2[&quot;Temporary chain&quot;]
          chain3[&quot;Public chain&quot;]
          chain4[&quot;App chain&quot;]
        end
        user -- owns --&gt; chain1
        user -- shares --&gt; chain2
        validators -- own --&gt; chain3
        provider -- owns/shares --&gt; chain4

    %% Styling
    style Validators fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style provider fill:#A0736B,stroke:#D2E8C8,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#5A8269,stroke:#D2E8C8,stroke-width:2px
    style chain3 fill:#4A5A60,stroke:#F3EEE2,stroke-width:2px
    style chain4 fill:#4A7B75,stroke:#70D4D3,stroke-width:2px

</pre>
<p>While validation rules and security assumptions are the same for all chains,
block production in each chain can be configured in a number of ways. In
practice, most chains fall into the following categories:</p>
<ul>
<li><strong>Personal chains</strong> (aka. <strong>user chains</strong>”) are those with a single <strong>owner</strong>,
i.e. a single user proposing blocks.</li>
<li><strong>Temporary chains</strong> are shared between a few users.</li>
<li><strong>Public chains</strong>, usually dedicated to a particular task in the Linera
infrastructure, are fully managed by Linera validators.</li>
<li>Chains dedicated to a particular application, called <strong>app chains</strong>, may use
either their own infrastructure for block production, a permissionless
solution using proof-of-work, or a rotating set of trusted providers.</li>
</ul>
<blockquote>
<p>In order to validate all the chains reliably and at minimal cost, Linera
validators are designed to be <strong>elastic</strong>, meaning that they can independently
add or remove computational power (e.g. cloud workers) on demand whenever
needed. In turn, this allows Linera applications to scale horizontally by
distributing work to the microchains of their users.</p>
</blockquote>
<h2 id="what-makes-linera-real-time-and-agent-friendly"><a class="header" href="#what-makes-linera-real-time-and-agent-friendly">What makes Linera real-time and agent-friendly?</a></h2>
<h3 id="connected-clients"><a class="header" href="#connected-clients">Connected clients</a></h3>
<p>To propose blocks and provide APIs to frontends, Linera users rely on a <strong>Linera
client</strong>. Clients synchronize on-chain data in real-time, without trusting third
parties, thanks to local VMs and Linera’s native support for notifications.
Clients are <strong>sparse</strong> in the sense that they track only the chains relevant to
a particular user.</p>
<pre class="mermaid">flowchart LR
    subgraph user_device[&quot;User device&quot;]
        ui[&quot;Web UI or AI agent&quot;]
        ui &lt;-- GraphQL --&gt; user_local

        subgraph linera_client[&quot;Linera client&quot;]
            user_local[&quot;user chain&quot;]
            admin_local[&quot;admin chain&quot;]
        end
    end

    user_local &lt;-- sync blocks --&gt; user_remote
    user_remote -- notify incoming messages --&gt; user_local
    admin_local &lt;-- sync blocks --&gt; admin_remote

    subgraph validators_clients[&quot;Validators&quot;]
        user_remote[&quot;user chain&quot;]
        admin_remote[&quot;admin chain&quot;]
    end

    %% Styling
    style user_device fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style linera_client fill:#0e2630,stroke:#A0E3E2,stroke-width:1px,stroke-dasharray:2 2,rx:8,ry:8
    style validators_clients fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10

    style ui fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style user_local fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style admin_local fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style user_remote fill:#4A5A60,stroke:#F3EEE2,stroke-width:2px
    style admin_remote fill:#4A5A60,stroke:#F3EEE2,stroke-width:2px

</pre>
<p>User interfaces interact with Linera applications by querying and sending
high-level commands to local GraphQL services running securely inside the Linera
client.</p>
<p>Similarly,
<a href="protocol/../developers/core_concepts/node_service.html#connecting-ai-agents-to-linera-applications-in-mcp">discussions</a>
between AI agents and Linera applications stay local, hence private and free of
charge. This also protects agents against compromised external RPC services.</p>
<blockquote>
<p>Linera is the first Layer-1 to allow <strong>trustless real-time synchronization</strong>
of user data on their devices, democratizing low-latency data access and
bringing professional-grade security to frontends, customized oracle networks,
and AI-trading agents.</p>
</blockquote>
<h3 id="geographic-sharding"><a class="header" href="#geographic-sharding">Geographic sharding</a></h3>
<p>In the future, Linera validators will be incentivized to operate machines and
maintain a presence in a number of key regions. Most microchains will be pinned
explicitly to a specific region, giving users of this region the lowest latency
possible in their on-chain interactions. Linera validators will be incentivized
to connect their regional data-centers using a low-latency network.</p>
<pre class="mermaid">flowchart LR
    subgraph region_1[&quot;Region 1&quot;]
        user1([&quot;User 1&quot;])
        chain1[&quot;chain 1&quot;]
        chain2[&quot;chain 2&quot;]
    end
    subgraph region_2[&quot;Region 2&quot;]
        chain3[&quot;chain 3&quot;]
        chain4[&quot;chain 4&quot;]
    end
    user1 --&gt; chain1
	  chain1 &lt;--&gt; chain2
	  chain2 &lt;---&gt; chain3
	  chain2 &lt;---&gt; chain3
	  chain3 &lt;--&gt; chain4

    %% Styling
    style region_1 fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style region_2 fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user1 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain3 fill:#4A5A60,stroke:#F3EEE2,stroke-width:2px
    style chain4 fill:#4A5A60,stroke:#F3EEE2,stroke-width:2px

</pre>
<p>Importantly, geographic affinity in Linera is not conditioned to the time of the
day allowing applications to deliver similar performance at night and during
working hours. Yet, Linera validators have the flexibility to downsize and
upsize their pool of machines at will to save costs.</p>
<h2 id="how-do-linera-microchains-compare-to-traditional-multi-chain-protocols"><a class="header" href="#how-do-linera-microchains-compare-to-traditional-multi-chain-protocols">How do Linera microchains compare to traditional multi-chain protocols?</a></h2>
<p>Linera is the first blockchain designed to run a virtually unlimited number of
chains in parallel, including one dedicated <strong>user chain</strong> per user wallet.</p>
<p>In traditional multi-chain protocols, each chain usually runs a full blockchain
protocol in a separate set of validators. Creating a new chain or exchanging
messages between chains is expensive. As a result, the total number of chains is
generally limited.</p>
<p>In contrast, <strong>Linera is designed to run as many microchains as needed</strong>:</p>
<ul>
<li>
<p>Users only create blocks in their chain when needed;</p>
</li>
<li>
<p>Creating a microchain does not require onboarding validators;</p>
</li>
<li>
<p>All chains have the same level of security;</p>
</li>
<li>
<p>Microchains communicate efficiently using the internal networks of validators;</p>
</li>
<li>
<p>Validators are internally sharded (like a regular web service) and may adjust
their capacity elastically by adding or removing internal workers.</p>
</li>
<li>
<p>Users may run heavy transactions in their microchain without affecting other
users.</p>
</li>
</ul>
<h2 id="main-protocol-features"><a class="header" href="#main-protocol-features">Main protocol features</a></h2>
<p><strong>Infrastructure</strong></p>
<ul>
<li>
<p>Finality time under 0.5 seconds for most blocks, including a certificate of
execution.</p>
</li>
<li>
<p>New microchains created in one transaction from an existing chain.</p>
</li>
<li>
<p>No theoretical limit in the number of microchains, hence the number of
transactions per second (TPS).</p>
</li>
<li>
<p>Bridge-friendly block headers compatible with EVM signatures</p>
</li>
</ul>
<p><strong>On-chain applications</strong></p>
<ul>
<li>
<p>Rich programming model allowing applications to distribute computation across
chains using asynchronous messages, shared immutable data, and event streams.</p>
</li>
<li>
<p>Full synchronous composability inside each microchain.</p>
</li>
<li>
<p>Support for heavy (multi-second) transactions and direct oracle queries to
external web services and data storage layers.</p>
</li>
</ul>
<p><strong>Web client and wallet infrastructure</strong></p>
<ul>
<li>
<p>Real-time push-notifications from validators to web clients.</p>
</li>
<li>
<p>Block synchronization and VM execution for selected microchains, allowing
instant pre-confirmation of user transactions.</p>
</li>
<li>
<p>Trustless reactive programming using familiar Web2 frameworks.</p>
</li>
<li>
<p>On-chain applications programmed in Rust to run on Wasm, or Solidity on
EVM(*).</p>
</li>
</ul>
<p><em>Features marked with (*) are under active development on the main branch.</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="roadmap"><a class="header" href="#roadmap">Roadmap</a></h1>
<p>This section outlines our current technical roadmap. Please note that this
roadmap is provided for informational purposes only and is subject to change at
any time.</p>
<pre class="mermaid">%%{init: { 'logLevel': 'debug', 'theme': 'dark' } }%%
timeline
    section 2024
      Testnet 1 (Archimedes): Multi-user chains
                            : Data blobs
                            : Fees
    section 2025+
      Testnet 2 (Babbage): Web client
               : POW public chains
               : Block headers
      Testnet 3 (Conway): Browser extension &amp; wallet connect
               : EVM support
               : Block explorer
      Testnet 4: Governance
               : Tokenomics
               : Security audits
      Mainnet
</pre>
<h2 id="testnet-1-released-nov-2024"><a class="header" href="#testnet-1-released-nov-2024">Testnet #1 (released Nov 2024)</a></h2>
<p>Codename: Archimedes</p>
<p><strong>SDK</strong></p>
<ul>
<li>
<p>Released Rust SDK v0.13+</p>
</li>
<li>
<p>First Web demos running a Linera client in the browser</p>
</li>
<li>
<p>Blob storage for user data</p>
</li>
</ul>
<p><strong>Core protocol</strong></p>
<ul>
<li>
<p>Blob storage for application bytecode and user data</p>
</li>
<li>
<p>Multi-user chains (e.g. used in on-chain game demo)</p>
</li>
<li>
<p>Initial support for fees</p>
</li>
</ul>
<p><strong>Infrastructure</strong></p>
<ul>
<li>
<p>Fixed number of workers per validator</p>
</li>
<li>
<p>Onboarding of 20+ external validators</p>
</li>
</ul>
<h2 id="testnet-2-released-apr-2025"><a class="header" href="#testnet-2-released-apr-2025">Testnet #2 (released Apr 2025)</a></h2>
<p>Codename: Babbage</p>
<p><strong>SDK</strong></p>
<ul>
<li>
<p>Official Web client framework</p>
</li>
<li>
<p>Support for native oracles: http queries and non-deterministic computations</p>
</li>
<li>
<p>Support for POW public chains</p>
</li>
<li>
<p>Simplified user and application addresses</p>
</li>
</ul>
<p><strong>Core protocol</strong></p>
<ul>
<li>
<p>More scalable reconfigurations</p>
</li>
<li>
<p>No more "request-application" operations</p>
</li>
<li>
<p>Bridge-friendly block headers compatible with EVM signatures</p>
</li>
</ul>
<p><strong>Infrastructure</strong></p>
<ul>
<li>
<p>Better hotfix release process</p>
</li>
<li>
<p>Support for resizing workers offline</p>
</li>
</ul>
<h2 id="testnet-3-released-sep-2025"><a class="header" href="#testnet-3-released-sep-2025">Testnet #3 (released Sep 2025)</a></h2>
<p>Codename: Conway</p>
<p><strong>SDK</strong></p>
<ul>
<li>
<p>Wallet connect (signing demo with external wallet)</p>
</li>
<li>
<p>Event streams (deprecating pub/sub channels)</p>
</li>
<li>
<p>Experimental support for EVM</p>
</li>
<li>
<p>Compatibility with EVM addresses</p>
</li>
</ul>
<p><strong>Core protocol</strong></p>
<ul>
<li>
<p>More scalable client with partial chain execution and optimized block
synchronization</p>
</li>
<li>
<p>Execution cache for faster server-side and client-side block execution</p>
</li>
<li>
<p>Simplify chain creation and support externally created microchains</p>
</li>
</ul>
<p><strong>Infrastructure</strong></p>
<ul>
<li>
<p>High-TPS configuration</p>
</li>
<li>
<p>Software service to support block indexing</p>
</li>
</ul>
<h2 id="testnet-4"><a class="header" href="#testnet-4">Testnet #4</a></h2>
<p><strong>SDK</strong></p>
<ul>
<li>
<p>Stable support for EVM</p>
</li>
<li>
<p>Transaction scripts</p>
</li>
<li>
<p>Application upgradability</p>
</li>
</ul>
<p><strong>Core protocol</strong></p>
<ul>
<li>
<p>Protocol upgradability, including block format, virtual machines, and system
APIs</p>
</li>
<li>
<p>Governance chain</p>
</li>
<li>
<p>Final tokenomics and fees</p>
</li>
<li>
<p>Storage durability</p>
</li>
</ul>
<p><strong>Infrastructure</strong></p>
<ul>
<li>
<p>Network performance measurements and validator incentives</p>
</li>
<li>
<p>Security audits</p>
</li>
</ul>
<h2 id="mainnet-and-beyond"><a class="header" href="#mainnet-and-beyond">Mainnet and beyond</a></h2>
<p><strong>SDK</strong></p>
<ul>
<li>
<p>Account abstraction and fee masters</p>
</li>
<li>
<p>Linera light clients for other contract languages (e.g. Solidity, Sui Move)</p>
</li>
</ul>
<p><strong>Core Protocol</strong></p>
<ul>
<li>
<p>Permissionless auditing protocol</p>
</li>
<li>
<p>Performance improvements</p>
</li>
</ul>
<p><strong>Infrastructure</strong></p>
<ul>
<li>
<p>Block indexing and block explorer</p>
</li>
<li>
<p>Walrus archives</p>
</li>
<li>
<p>Support for dynamic shard assignment and elasticity</p>
</li>
<li>
<p>Geographic sharding</p>
</li>
<li>
<p>Support for more cloud vendors</p>
</li>
<li>
<p>Native bridges</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>In this section, we will cover the necessary steps to install the Linera
toolchain and give a short example to get started with the Linera SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Let's start with the installation of the Linera development tools.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The Linera toolchain consists of several crates:</p>
<ul>
<li>
<p><code>linera-sdk</code> is the main library used to program Linera applications in Rust.</p>
</li>
<li>
<p><code>linera-service</code> defines a number of binaries, notably <code>linera</code> the main
client tool used to operate developer wallets and start local testing
networks.</p>
</li>
<li>
<p><code>linera-storage-service</code> provides a simple database used to run local
validator nodes for testing and development purposes.</p>
</li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>The operating systems currently supported by the Linera toolchain can be
summarized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Linux x86 64-bit</th><th>Mac OS (M1 / M2)</th><th>Mac OS (x86)</th><th>Windows</th></tr></thead><tbody>
<tr><td>✓ Main platform</td><td>✓ Working</td><td>✓ Working</td><td>Untested</td></tr>
</tbody></table>
</div>
<p>The main prerequisites to install the Linera toolchain are Rust, Wasm, and
Protoc. They can be installed as follows on Linux:</p>
<ul>
<li>
<p>Rust and Wasm</p>
<ul>
<li><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li><code>rustup target add wasm32-unknown-unknown</code></li>
</ul>
</li>
<li>
<p>Protoc</p>
<ul>
<li><code>curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protoc-21.11-linux-x86_64.zip</code></li>
<li><code>unzip protoc-21.11-linux-x86_64.zip -d $HOME/.local</code></li>
<li>If <code>~/.local</code> is not in your path, add it:
<code>export PATH="$HOME/.local/bin:$PATH"</code></li>
</ul>
</li>
<li>
<p>On certain Linux distributions, you may have to install development packages
such as <code>g++</code>, <code>libclang-dev</code> and <code>libssl-dev</code>.</p>
</li>
</ul>
<p>For MacOS support and for additional requirements needed to test the Linera
protocol itself, see the installation section on
<a href="https://github.com/linera-io/linera-protocol/blob/main/INSTALL.md">GitHub</a>.</p>
<p>This manual was tested with the following Rust toolchain:</p>
<pre><code class="language-text">[toolchain]
channel = "1.86.0"
components = [ "clippy", "rustfmt", "rust-src" ]
targets = [ "wasm32-unknown-unknown" ]
profile = "minimal"
</code></pre>
<h2 id="installing-from-cratesio"><a class="header" href="#installing-from-cratesio">Installing from crates.io</a></h2>
<p>You may install the Linera binaries with</p>
<pre><code class="language-bash">cargo install --locked linera-storage-service@0.15.3
cargo install --locked linera-service@0.15.3
</code></pre>
<p>and use <code>linera-sdk</code> as a library for Linera Wasm applications:</p>
<pre><code class="language-bash">cargo add linera-sdk@0.15.3
</code></pre>
<p>The version number <code>0.15.3</code> corresponds to the
current Testnet of Linera. The minor version may change frequently but should
not induce breaking changes.</p>
<h2 id="installing-from-github"><a class="header" href="#installing-from-github">Installing from GitHub</a></h2>
<p>Download the source from <a href="https://github.com/linera-io/linera-protocol">GitHub</a>:</p>
<pre><code class="language-bash">git clone https://github.com/linera-io/linera-protocol.git
cd linera-protocol
git checkout -t origin/testnet_conway  # Current release branch
</code></pre>
<p>To install the Linera toolchain locally from source, you may run:</p>
<pre><code class="language-bash">cargo install --locked --path linera-storage-service
cargo install --locked --path linera-service
</code></pre>
<p>Alternatively, for developing and debugging, you may instead use the binaries
compiled in debug mode, e.g. using <code>export PATH="$PWD/target/debug:$PATH"</code>.</p>
<p>This manual was tested against the following commit of the
<a href="https://github.com/linera-io/linera-protocol">repository</a>:</p>
<pre><code class="language-text">fd6b3cc05da4729f1c44cdd87e225a339890517e
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h2>
<p>If installation fails, reach out to the team (e.g. on
<a href="https://discord.gg/linera">Discord</a>) to help troubleshoot your issue or
<a href="https://github.com/linera-io/linera-protocol/issues/new">create an issue</a> on
GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-linera"><a class="header" href="#hello-linera">Hello, Linera</a></h1>
<p>In this section, you will learn how to initialize a developer wallet, interact
with the current Testnet, run a local development network, then compile and
deploy your first application from scratch.</p>
<p>By the end of this section, you will have a
<a href="developers/getting_started/../core_concepts/microchains.html">microchain</a> on the Testnet and/or on your
local network, and a working application that can be queried using GraphQL.</p>
<h2 id="creating-a-wallet-on-the-latest-testnet"><a class="header" href="#creating-a-wallet-on-the-latest-testnet">Creating a wallet on the latest Testnet</a></h2>
<p>To interact with the latest Testnet, you will need a developer wallet, a new
microchain, and some tokens. These can be all obtained at once by querying the
Testnet's <strong>faucet</strong> service as follows:</p>
<pre><code class="language-bash">linera wallet init --faucet https://faucet.testnet-conway.linera.net
linera wallet request-chain --faucet https://faucet.testnet-conway.linera.net
</code></pre>
<p>If you obtain an error message instead, make sure to use a Linera toolchain
<a href="developers/getting_started/installation.html#installing-from-cratesio">compatible with the current Testnet</a>.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="developers/getting_started/hello_linera.html#admonition-info"></a>
</div>
<div>
<p>A Linera Testnet is a deployment of the Linera protocol used for testing. A deployment
consists of a number of <a href="developers/getting_started/../advanced_topics/validators.html">validators</a>, each of which runs
a frontend service (aka. <code>linera-proxy</code>), a number of workers (aka. <code>linera-server</code>), and
a shared database (by default <code>linera-storage-service</code>).</p>
</div>
</div>
<h2 id="using-a-local-test-network"><a class="header" href="#using-a-local-test-network">Using a local test network</a></h2>
<p>Another option is to start your own local development network. To do so, run the
following command:</p>
<pre><code class="language-bash">linera net up --with-faucet --faucet-port 8080
</code></pre>
<p>This will start a validator with the default number of shards and start a
faucet.</p>
<p>Now, we're ready to create a developer wallet by running the following command
in a separate shell:</p>
<pre><code class="language-bash">linera wallet init --faucet http://localhost:8080
linera wallet request-chain --faucet http://localhost:8080
</code></pre>
<div id="admonition-note" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-title">
<div class="admonition-title">
<div id="admonition-note-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="developers/getting_started/hello_linera.html#admonition-note"></a>
</div>
<div>
<p>A wallet is valid for the lifetime of its network. Every time a local
network is restarted, the wallet needs to be removed and created again.</p>
</div>
</div>
<h2 id="working-with-several-developer-wallets-and-several-networks"><a class="header" href="#working-with-several-developer-wallets-and-several-networks">Working with several developer wallets and several networks</a></h2>
<p>By default, the <code>linera</code> command looks for wallet files located in a
configuration path determined by your operating system. If you prefer to choose
the location of your wallet files, you may optionally set the variables
<code>LINERA_WALLET</code>, <code>LINERA_KEYSTORE</code> and <code>LINERA_STORAGE</code> as follows:</p>
<pre><code class="language-bash">DIR=$HOME/my_directory
mkdir -p $DIR
export LINERA_WALLET="$DIR/wallet.json"
export LINERA_KEYSTORE="$DIR/keystore.json"
export LINERA_STORAGE="rocksdb:$DIR/wallet.db"
</code></pre>
<p>Choosing such a directory can be useful to work with several networks because a
wallet is always specific to the network where it was created.</p>
<div id="admonition-note-1" class="admonition admonish-note" role="note" aria-labelledby="admonition-note-1-title">
<div class="admonition-title">
<div id="admonition-note-1-title">
<p>Note</p>
</div>
<a class="admonition-anchor-link" href="developers/getting_started/hello_linera.html#admonition-note-1"></a>
</div>
<div>
<p>We refer to the wallets created by the <code>linera</code> CLI as "developer wallets" because
they are operated from a developer tool and merely meant for testing and development.</p>
<p>Production-grade user wallets are generally operated by a browser
extension, a mobile application, or a hardware device.</p>
</div>
</div>
<h2 id="interacting-with-the-linera-network"><a class="header" href="#interacting-with-the-linera-network">Interacting with the Linera network</a></h2>
<p>To check that the network is working, you can synchronize your chain with the
rest of the network and display the chain balance as follows:</p>
<pre><code class="language-bash">linera sync
linera query-balance
</code></pre>
<p>You should see an output number, e.g. <code>10</code>.</p>
<h2 id="building-an-example-application"><a class="header" href="#building-an-example-application">Building an example application</a></h2>
<p>Applications running on Linera are <a href="https://webassembly.org/">Wasm</a> bytecode.
Each validator and client has a built-in Wasm virtual machine (VM) which can
execute bytecode.</p>
<p>Let's build the <code>counter</code> application from the <code>examples/</code> subdirectory of the
<a href="https://github.com/linera-io/linera-protocol/tree/testnet_conway">Linera testnet
branch</a>:</p>
<pre><code class="language-bash">cd examples/counter &amp;&amp; cargo build --release --target wasm32-unknown-unknown
</code></pre>
<h2 id="publishing-your-application"><a class="header" href="#publishing-your-application">Publishing your application</a></h2>
<p>You can publish the bytecode and create an application using it on your local
network using the <code>linera</code> client's <code>publish-and-create</code> command and provide:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  ../target/wasm32-unknown-unknown/release/counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<p>Congratulations! You've published your first application on Linera!</p>
<h2 id="querying-your-application"><a class="header" href="#querying-your-application">Querying your application</a></h2>
<p>Now let's query your application to get the current counter value. To do that,
we need to use the client running in
<a href="developers/getting_started/../core_concepts/node_service.html"><em>service</em> mode</a>. This will expose a bunch of
APIs locally which we can use to interact with applications on the network.</p>
<pre><code class="language-bash">linera service --port 8080
</code></pre>
<!-- TODO: add graphiql image here -->
<p>Navigate to <code>http://localhost:8080</code> in your browser to access GraphiQL, the
<a href="https://graphql.org">GraphQL</a> IDE. We'll look at this in more detail in a
<a href="developers/getting_started/../core_concepts/node_service.html#graphiql-ide">later section</a>; for now, list
the applications deployed on your default chain by running:</p>
<pre><code class="language-gql">query {
  applications(chainId: "...") {
    id
    description
    link
  }
}
</code></pre>
<p>where <code>...</code> are replaced by the chain ID shown by <code>linera wallet show</code>.</p>
<p>Since we've only deployed one application, the results returned have a single
entry.</p>
<p>At the bottom of the returned JSON there is a field <code>link</code>. To interact with
your application copy and paste the link into a new browser tab.</p>
<p>Finally, to query the counter value, run:</p>
<pre><code class="language-gql">query {
  value
}
</code></pre>
<p>This will return a value of <code>42</code>, which is the initialization argument we
specified when deploying our application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-concepts"><a class="header" href="#core-concepts">Core concepts</a></h1>
<p>We now describe some of the core concepts of the Linera protocol in greater
details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microchains"><a class="header" href="#microchains">Microchains</a></h1>
<p>This section provides an introduction to microchains, the main building block of
the Linera Protocol. For a more formal treatment refer to the
<a href="https://linera.io/whitepaper">whitepaper</a>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>A <strong>microchain</strong> is a chain of blocks describing successive changes to a shared
state. We will use the terms <em>chain</em> and <em>microchain</em> interchangeably. Linera
microchains are similar to the familiar notion of blockchain, with the following
important specificities:</p>
<ul>
<li>
<p>An arbitrary number of microchains can coexist in a Linera network, all
sharing the same set of validators and the same level of security. Creating a
new microchain only takes one transaction on an existing chain.</p>
</li>
<li>
<p>The task of proposing new blocks in a microchain can be assumed either by
validators or by end users (or rather their wallets) depending on the
configuration of a chain. Specifically, microchains can be <em>single-owner</em>,
<em>multi-owner</em>, or <em>public</em>, depending on who is authorized to propose blocks.</p>
</li>
</ul>
<h2 id="cross-chain-messaging"><a class="header" href="#cross-chain-messaging">Cross-chain messaging</a></h2>
<p>In traditional networks with a single blockchain, every transaction can access
the application's entire execution state. This is not the case in Linera where
the state of an application is spread across multiple microchains, and the state
on any individual microchain is only affected by the blocks of that microchain.</p>
<p>Cross-chain messaging is a way for different microchains to communicate with
each other asynchronously. This method allows applications and data to be
distributed across multiple chains for better scalability. When an application
on one chain sends a message to itself on another chain, a cross-chain request
is created. These requests are implemented using remote procedure calls (RPCs)
within the validators' internal network, ensuring that each request is executed
only once.</p>
<p>Instead of immediately modifying the target chain, messages are placed first in
the target chain's <strong>inbox</strong>. When an owner of the target chain creates its next
block in the future, they may reference a selection of messages taken from the
current inbox in the new block. This executes the selected messages and applies
their messages to the chain state.</p>
<p>Below is an example set of chains sending asynchronous messages to each other
over consecutive blocks.</p>
<pre><code class="language-ignore">                               ┌───┐     ┌───┐     ┌───┐
                       Chain A │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
                                                     ▲
                                           ┌─────────┘
                                           │
                               ┌───┐     ┌─┴─┐     ┌───┐
                       Chain B │   ├────►│   ├────►│   │
                               └───┘     └─┬─┘     └───┘
                                           │         ▲
                                           │         │
                                           ▼         │
                               ┌───┐     ┌───┐     ┌─┴─┐
                       Chain C │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
</code></pre>
<p>The Linera protocol allows receivers to discard messages but not to change the
ordering of selected messages inside the communication queue between two chains.
If a selected message fails to execute, the wallet will automatically reject it
when proposing the receiver's block. The current implementation of the Linera
client always selects as many messages as possible from inboxes, and never
discards messages unless they fail to execute.</p>
<h2 id="chain-ownership-semantics"><a class="header" href="#chain-ownership-semantics">Chain ownership semantics</a></h2>
<p>Active chains can have one or multiple owners. Chains with zero owners are
permanently deactivated.</p>
<p>In Linera, the validators guarantee <em>safety</em>: On each chain, at each height,
there is at most one unique block.</p>
<p>But <em>liveness</em>—actually adding blocks to a chain at all—relies on the owners.
There are different types of rounds and owners, optimized for different use
cases:</p>
<ul>
<li>First an optional <em>fast</em> round, where a <em>super owner</em> can propose blocks that
get confirmed with very particularly low latency, optimal for single-owner
chains with no contention.</li>
<li>Then a number of <em>multi-leader rounds</em>, where all <em>regular owners</em> can propose
blocks. This works well even if there is occasional, temporary contention: an
owner using multiple devices, or multiple people using the same chain
infrequently.</li>
<li>And finally <em>single-leader rounds</em>: These give each regular chain owner a time
slot in which only they can propose a new block, without being hindered by any
other owners' proposals. This is ideal for chains with many users that are
trying to commit blocks at the same time.</li>
</ul>
<p>The number of multi-leader rounds is configurable: On chains with fluctuating
levels of activity, this allows the system to dynamically switch to
single-leader mode whenever all multi-leader rounds fail during periods of high
contention. Chains that very often have high activity from multiple owners can
set the number of multi-leader rounds to 0.</p>
<p>For more detail and examples on how to open and close chains, see the wallet
section on <a href="developers/core_concepts/wallets.html#opening-a-chain">chain management</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallets"><a class="header" href="#wallets">Wallets</a></h1>
<p>As in traditional blockchains, Linera wallets are in charge of holding user
private keys. However, instead of signing transactions, Linera wallets are meant
to sign blocks and propose them to extend the chains owned by their users.</p>
<p>In practice, wallets include a node which tracks a subset of Linera chains. We
will see in the <a href="developers/core_concepts/node_service.html">next section</a> how a Linera wallet can run a
GraphQL service to expose the state of its chains to web frontends.</p>
<blockquote>
<p>The command-line tool <code>linera</code> is the main way for developers to interact with
a Linera network and manage the developer wallets present locally on the
system.</p>
</blockquote>
<p>Note that this command-line tool is intended mainly for development purposes.
Our goal is that end users eventually manage their wallets in a browser
extension.</p>
<h2 id="creating-a-developer-wallet"><a class="header" href="#creating-a-developer-wallet">Creating a developer wallet</a></h2>
<p>The simplest way to obtain a wallet with the <code>linera</code> CLI tool is to run the
following command:</p>
<pre><code class="language-bash">linera wallet init --faucet $FAUCET_URL
linera wallet request-chain --faucet $FAUCET_URL
</code></pre>
<p>where <code>$FAUCET_URL</code> represents the URL of the network's faucet (see
<a href="developers/core_concepts/../getting_started/hello_linera.html">previous section</a>)</p>
<h2 id="selecting-a-wallet"><a class="header" href="#selecting-a-wallet">Selecting a wallet</a></h2>
<p>The private state of a wallet is conventionally stored in a file <code>wallet.json</code>,
keys are stored in <code>keystore.db</code>, while the state of its node is stored in a
file <code>wallet.db</code>.</p>
<p>To switch between wallets, you may use the <code>--wallet</code>, <code>--keystore</code>, and
<code>--storage</code> options of the <code>linera</code> tool, e.g. as in
<code>linera --wallet wallet2.json --keystore keystore2.json --storage rocksdb:wallet2.db:runtime:default</code>.</p>
<p>You may also define the environment variables <code>LINERA_STORAGE</code>,
<code>LINERA_KEYSTORE</code>, and <code>LINERA_WALLET</code> to the same effect. E.g.
<code>LINERA_STORAGE=rocksdb:$PWD/wallet2.db:runtime:default</code> and
<code>LINERA_WALLET=$PWD/wallet2.json</code>.</p>
<p>Finally, if <code>LINERA_STORAGE_$I</code>, <code>LINERA_KEYSTORE_$I</code>, and <code>LINERA_WALLET_$I</code>
are defined for some number <code>I</code>, you may call <code>linera --with-wallet $I</code> (or
<code>linera -w $I</code> for short).</p>
<h2 id="chain-management"><a class="header" href="#chain-management">Chain management</a></h2>
<h3 id="listing-chains"><a class="header" href="#listing-chains">Listing chains</a></h3>
<p>To list the chains present in your wallet, you may use the command <code>show</code>:</p>
<pre><code class="language-bash">linera wallet show
╭──────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────╮
│ Chain ID                                                         ┆ Latest Block                                                                         │
╞══════════════════════════════════════════════════════════════════╪══════════════════════════════════════════════════════════════════════════════════════╡
│ 668774d6f49d0426f610ad0bfa22d2a06f5f5b7b5c045b84a26286ba6bce93b4 ┆ Public Key:         3812c2bf764e905a3b130a754e7709fe2fc725c0ee346cb15d6d261e4f30b8f1 │
│                                                                  ┆ Owner:              c9a538585667076981abfe99902bac9f4be93714854281b652d07bb6d444cb76 │
│                                                                  ┆ Block Hash:         -                                                                │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:20.820840                                       │
│                                                                  ┆ Next Block Height:  0                                                                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 91c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f646 ┆ Public Key:         29c19718a26cb0d5c1d28102a2836442f53e3184f33b619ff653447280ccba1a │
│                                                                  ┆ Owner:              efe0f66451f2f15c33a409dfecdf76941cf1e215c5482d632c84a2573a1474e8 │
│                                                                  ┆ Block Hash:         51605cad3f6a210183ac99f7f6ef507d0870d0c3a3858058034cfc0e3e541c13 │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:21.885221                                       │
│                                                                  ┆ Next Block Height:  1                                                                │
╰──────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────╯

</code></pre>
<p>Each row represents a chain present in the wallet. On the left is the unique
identifier on the chain, and on the right is metadata for that chain associated
with the latest block.</p>
<h3 id="default-chain"><a class="header" href="#default-chain">Default chain</a></h3>
<p>Each wallet has a default chain that all commands apply to unless you specify
another <code>--chain</code> on the command line.</p>
<p>The default chain is set initially, when the first chain is added to the wallet.
You can check the default chain for your wallet by running:</p>
<pre><code class="language-bash">linera wallet show
</code></pre>
<p>The chain ID which is in green text instead of white text is your default chain.</p>
<p>To change the default chain for your wallet, use the <code>set-default</code> command:</p>
<pre><code class="language-bash">linera wallet set-default &lt;chain-id&gt;
</code></pre>
<h3 id="creating-chains"><a class="header" href="#creating-chains">Creating chains</a></h3>
<p>In the Linera protocol, chains are generally created using a transaction from an
existing chain.</p>
<h4 id="create-a-chain-from-an-existing-one-for-your-own-wallet"><a class="header" href="#create-a-chain-from-an-existing-one-for-your-own-wallet">Create a chain from an existing one for your own wallet</a></h4>
<p>To create a new chain from the default chain of your wallet, you can use the
<code>open-chain</code> command:</p>
<pre><code class="language-bash">linera open-chain
</code></pre>
<p>This will create a new chain and add it to the wallet. Use the <code>wallet show</code>
command to see your existing chains.</p>
<h4 id="create-a-new-chain-from-an-existing-one-for-another-wallet"><a class="header" href="#create-a-new-chain-from-an-existing-one-for-another-wallet">Create a new chain from an existing one for another wallet</a></h4>
<p>Creating a chain for another <code>wallet</code> requires an extra two steps. Let's
initialize a second wallet:</p>
<pre><code class="language-bash">linera --wallet wallet2.json --storage rocksdb:linera2.db wallet init --faucet $FAUCET_URL
</code></pre>
<p>First <code>wallet2</code> must create an unassigned keypair. The public part of that
keypair is then sent to the <code>wallet</code> who is the chain creator.</p>
<pre><code class="language-bash">linera --wallet wallet2.json keygen
6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 # this is the public key for the unassigned keypair
</code></pre>
<p>Next, using the public key, <code>wallet</code> can open a chain for <code>wallet2</code>.</p>
<pre><code class="language-bash">linera open-chain --to-public-key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888
e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000
fc9384defb0bcd8f6e206ffda32599e24ba715f45ec88d4ac81ec47eb84fa111
</code></pre>
<p>The first line is the message ID specifying the cross-chain message that creates
the new chain. The second line is the new chain's ID.</p>
<p>Finally, to add the chain to <code>wallet2</code> for the given unassigned key we use the
<code>assign</code> command:</p>
<pre><code class="language-bash"> linera --wallet wallet2.json assign --key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 --message-id e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000
</code></pre>
<p>Note that in the case of a test network with a faucet, the new wallet and the
new chain could also have been created from the faucet directly using:</p>
<pre><code class="language-bash">linera --wallet wallet2.json --storage rocksdb:linera2.db wallet init --faucet $FAUCET_URL
linera --wallet wallet2.json --storage rocksdb:linera2.db wallet request-chain --faucet $FAUCET_URL
</code></pre>
<h4 id="opening-a-chain-with-multiple-users"><a class="header" href="#opening-a-chain-with-multiple-users">Opening a chain with multiple users</a></h4>
<p>The <code>open-chain</code> command is a simplified version of <code>open-multi-owner-chain</code>,
which gives you fine-grained control over the set and kinds of owners and rounds
for the new chain, and the timeout settings for the rounds. E.g. this creates a
chain with two owners and two multi-leader rounds.</p>
<pre><code class="language-bash">linera open-multi-owner-chain \
    --chain-id e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000 \
    --owner-public-keys 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 \
                        ca909dcf60df014c166be17eb4a9f6e2f9383314a57510206a54cd841ade455e \
    --multi-leader-rounds 2
</code></pre>
<p>The <code>change-ownership</code> command offers the same options to add or remove owners
and change round settings for an existing chain.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-service"><a class="header" href="#node-service">Node Service</a></h1>
<p>So far we've seen how to use the Linera client treating it as a binary in your
terminal. However, the client also acts as a node which:</p>
<ol>
<li>Executes blocks</li>
<li>Exposes a GraphQL API and IDE for dynamically interacting with applications
and the system</li>
<li>Listens for notifications from validators and automatically updates local
chains.</li>
</ol>
<p>To interact with the node service, run <code>linera</code> in <code>service</code> mode:</p>
<pre><code class="language-bash">linera service
</code></pre>
<p>This will run the node service on port 8080 by default (this can be overridden
using the <code>--port</code> flag).</p>
<h2 id="a-note-on-graphql"><a class="header" href="#a-note-on-graphql">A note on GraphQL</a></h2>
<p>Linera uses GraphQL as the query language for interfacing with different parts
of the system. GraphQL enables clients to craft queries such that they receive
exactly what they want and nothing more.</p>
<p>GraphQL is used extensively during application development, especially to query
the state of an application from a front-end for example.</p>
<p>To learn more about GraphQL check out the
<a href="https://graphql.org/learn/">official docs</a>.</p>
<h2 id="graphiql-ide"><a class="header" href="#graphiql-ide">GraphiQL IDE</a></h2>
<p>Conveniently, the node service exposes a GraphQL IDE called GraphiQL. To use
GraphiQL start the node service and navigate to <code>localhost:8080/</code>.</p>
<p>Using the schema explorer on the left of the GraphiQL IDE you can dynamically
explore the state of the system and your applications.</p>
<p><img src="developers/core_concepts/graphiql.png" alt="graphiql.png" /></p>
<h2 id="graphql-system-api"><a class="header" href="#graphql-system-api">GraphQL system API</a></h2>
<p>The node service also exposes a GraphQL API which corresponds to the set of
system operations. You can explore the full set of operations by clicking on
<code>MutationRoot</code>.</p>
<h2 id="graphql-application-api"><a class="header" href="#graphql-application-api">GraphQL application API</a></h2>
<p>To interact with an application, we run the Linera client in service mode. It
exposes a GraphQL API for every application running on any owned chain at
<code>localhost:8080/chains/&lt;chain-id&gt;/applications/&lt;application-id&gt;</code>.</p>
<p>Navigating there with your browser will open a GraphiQL interface which enables
you to graphically explore the state of your application.</p>
<h2 id="connecting-ai-agents-to-linera-applications-in-mcp"><a class="header" href="#connecting-ai-agents-to-linera-applications-in-mcp">Connecting AI agents to Linera applications in MCP</a></h2>
<p>Most AI agents understand the
<a href="https://modelcontextprotocol.io">Model Context Protocol</a> (MCP for short).</p>
<p>GraphQL service can be turned an MCP server using
<a href="https://www.apollographql.com/docs/apollo-mcp-server">Apollo MCP Server</a>.</p>
<p>More information can be found in the
<a href="https://github.com/linera-io/mcp-demo"><code>mcp-demo</code></a> repository.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>The programming model of Linera is designed so that developers can take
advantage of microchains to scale their applications.</p>
<p>Linera uses the <a href="https://webassembly.org">WebAssembly (Wasm)</a> Virtual Machine to
execute user applications. Currently, the <a href="developers/core_concepts/../backend.html">Linera SDK</a> is focused
on the <a href="https://www.rust-lang.org/">Rust</a> programming language for the backend
and <a href="https://www.typescriptlang.org/">TypeScript</a> for the frontend.</p>
<p>Linera applications are structured using the familiar notion of <strong>Rust crate</strong>:
the external interfaces of an application (including instantiation parameters,
operations and messages) generally go into the library part of its crate, while
the core of each application is compiled into binary files for the Wasm
architecture.</p>
<h2 id="the-application-deployment-lifecycle"><a class="header" href="#the-application-deployment-lifecycle">The Application deployment lifecycle</a></h2>
<p>Linera Applications are designed to be powerful yet re-usable. For this reason
there is a distinction between the bytecode and an application instance on the
network.</p>
<p>Applications undergo a lifecycle transition aimed at making development easy and
flexible:</p>
<ol>
<li>The bytecode is built from a Rust project with the <code>linera-sdk</code> dependency.</li>
<li>The bytecode is published to the network on a microchain, and assigned an
identifier.</li>
<li>A user can create a new application instance, by providing the bytecode
identifier and instantiation arguments. This process returns an application
identifier which can be used to reference and interact with the application.</li>
<li>The same bytecode identifier can be used as many times needed by as many
users needed to create distinct applications.</li>
</ol>
<p>Importantly, the application deployment lifecycle is abstracted from the user,
and an application can be published with a single command:</p>
<pre><code class="language-bash">linera publish-and-create &lt;contract-path&gt; &lt;service-path&gt; &lt;init-args&gt;
</code></pre>
<p>This will publish the bytecode as well as instantiate the application for you.</p>
<h2 id="anatomy-of-an-application"><a class="header" href="#anatomy-of-an-application">Anatomy of an application</a></h2>
<p>An <strong>application</strong> is broken into two major components, the <em>contract</em> and the
<em>service</em>.</p>
<p>The <strong>contract</strong> is gas-metered, and is the part of the application which
executes operations and messages, make cross-application calls and modifies the
application's state. The details are covered in more depth in the
<a href="developers/core_concepts/../backend.html">application backend guide</a>.</p>
<p>The <strong>service</strong> is non-metered and read-only. It is used primarily to query the
state of an application and populate the presentation layer (think front-end)
with the data required for a user interface.</p>
<h2 id="operations-and-messages"><a class="header" href="#operations-and-messages">Operations and messages</a></h2>
<blockquote>
<p>For this section we'll be using a simplified version of the example
application called "fungible" where users can send tokens to each other.</p>
</blockquote>
<p>At the system-level, interacting with an application can be done via operations
and messages.</p>
<p><strong>Operations</strong> are defined by an application developer and each application can
have a completely different set of operations. Chain owners then actively create
operations and put them in their block proposals to interact with an
application. Other applications may also call the application by providing an
operation for it to execute, this is called a cross-application call and always
happens within the same chain. Operations for cross-application calls may return
a response value back to the caller.</p>
<p>Taking the "fungible token" application as an example, an operation for a user
to transfer funds to another user would look like this:</p>
<pre><code class="language-rust"><span class="boring">extern crate serde;
</span><span class="boring">extern crate linera_sdk;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use linera_sdk::linera_base_types::*;
</span>#[derive(Debug, Deserialize, Serialize)]
pub enum Operation {
    /// A transfer from a (locally owned) account to a (possibly remote) account.
    Transfer {
        owner: AccountOwner,
        amount: Amount,
        target_account: Account,
    },
    // Meant to be extended here
}</code></pre>
<p><strong>Messages</strong> result from the execution of operations or other messages. Messages
can be sent from one chain to another, always within the same application. Block
proposers also actively include messages in their block proposal, but unlike
with operations, they are only allowed to include them in the right order
(possibly skipping some), and only if they were actually created by another
chain (or by a previous block of the same chain). Messages that originate from
the same transaction are included as a single transaction in the receiving
block.</p>
<p>In our "fungible token" application, a message to credit an account would look
like this:</p>
<pre><code class="language-rust"><span class="boring">extern crate serde;
</span><span class="boring">extern crate linera_sdk;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use linera_sdk::linera_base_types::*;
</span>#[derive(Debug, Deserialize, Serialize)]
pub enum Message {
    Credit { owner: AccountOwner, amount: Amount },
    // Meant to be extended here
}</code></pre>
<p>Messages can be marked as <strong>tracked</strong> by their sender. When a tracked message is
rejected, the message is marked as <strong>bouncing</strong> and sent back to the sender
chain. This is useful to avoid dropping assets in case the receiver is not able
or wanting to accept them.</p>
<h3 id="composing-applications"><a class="header" href="#composing-applications">Composing applications</a></h3>
<p>Within a chain, Linera applications call each other synchronously. The
transactions of a block initiates the first call to an application. The
atomicity of <strong>message bundles</strong> ensures that the messages created by a
transaction are either all received or all rejected by the receiver chain.</p>
<p>The following example shows a common design pattern where a high-level
application (here, a crowd-funding app) calls into another application (here an
ERC-20-like application managing a fungible token), resulting in a bundle of two
messages.</p>
<pre class="mermaid"> flowchart LR
    subgraph user_chain[&quot;User chain&quot;]
      block(&quot;operation in block&quot;) -- calls (with signer) (1) --&gt; app11
      subgraph exec_user[&quot;Execution state&quot;]
        app11[&quot;crowdfunding app&quot;] -- calls (with signer) (2) --&gt; app21[&quot;fungible token app&quot;]
      end
    end

    subgraph app_chain[&quot;Crowdfunding app chain&quot;]
      subgraph exec_app[&quot;Execution state&quot;]
        app12[&quot;crowdfunding app&quot;] -- calls (7) --&gt; app22[&quot;fungible token app&quot;]
      end
      bundle(&quot;Incoming message bundle&lt;br&gt;[assets, pledge]&quot;)
    end

    app11 -- send pledge (4) --&gt; bundle
    app21 -- send assets (3) --&gt; bundle
    bundle -- receive pledge (6) --&gt; app12
    bundle -- receive assets (5) --&gt; app22

    %% Styling
    style user_chain fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style app_chain fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style exec_user fill:#0e2630,stroke:#A0E3E2,stroke-width:1px,stroke-dasharray:2 2,rx:8,ry:8
    style exec_app fill:#0e2630,stroke:#A0E3E2,stroke-width:1px,stroke-dasharray:2 2,rx:8,ry:8

    style app11 fill:#4A7B75,stroke:#70D4D3,stroke-width:2px
    style app12 fill:#4A7B75,stroke:#70D4D3,stroke-width:2px
    style app21 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style app22 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style bundle fill:#5A8269,stroke:#D2E8C8,stroke-width:2px

</pre>
<p>When a user proposes a block in their user chain, operations inherit the
authentication of the user (aka <strong>signer</strong> or <strong>origin</strong>) that signed the block.
Calls may optionally forward this authentication, for instance to allow the
transfer of assets.</p>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>Operations in a block are always authenticated and messages may be
authenticated. The signer of a block becomes the authenticator of all the
operations in that block. As operations are being executed by applications,
messages can be created to be sent to other chains. When they are created, they
can be configured to be authenticated. In that case, the message receives the
same authentication as the operation that created it. If handling an incoming
message creates new messages, those may also be configured to have the same
authentication as the received message.</p>
<p>In other words, the block signer can have its authority propagated across chains
through series of messages. This allows applications to safely store user state
on chains that the user may not have the authority to produce blocks. The
application may also allow only the authorized user to change that state, and
not even the chain owner is able to override that.</p>
<p>The figure below shows four chains (A, B, C, D) and some blocks produced in
them. In this example, each chain is owned by a single owner (aka. address).
Owners are in charge of producing blocks and sign new blocks using their signing
keys. Some blocks show the operations and incoming messages they accept, where
the authentication is shown inside parenthesis. All operations produced are
authenticated by the block proposer, and if these are all single user chains,
the proposer is always the chain owner. Messages that have authentication use
the one from the operation or message that created it.</p>
<p>One example in the figure is that chain A produced a block with Operation 1,
which is authenticated by the owner of chain A (written <code>(a)</code>). That operation
sent a message to chain B, and assuming the message was sent with the
authentication forwarding enabled, it is received and executed in chain B with
the authentication of <code>(a)</code>. Another example is that chain D produced a block
with Operation 2, which is authenticated by the owner of chain D (written
<code>(d)</code>). That operation sent a message to chain C, which is executed with
authentication of <code>(d)</code> like the example before. Handling that message in chain
C produced a new message, which was sent to chain B. That message, when received
by chain B is executed with the authentication of <code>(d)</code>.</p>
<pre><code class="language-ignore">                            ┌───┐     ┌─────────────────┐     ┌───┐
       Chain A owned by (a) │   ├────►│ Operation 1 (a) ├────►│   │
                            └───┘     └────────┬────────┘     └───┘
                                               │
                                               └────────────┐
                                                            ▼
                                                ┌──────────────────────────┐
                            ┌───┐     ┌───┐     │ Message from chain A (a) │
       Chain B owned by (b) │   ├────►│   ├────►│ Message from chain C (d) |
                            └───┘     └───┘     │ Operation 3 (b)          │
                                                └──────────────────────────┘
                                                            ▲
                                                   ┌────────┘
                                                   │
                            ┌───┐     ┌──────────────────────────┐     ┌───┐
       Chain C owned by (c) │   ├────►│ Message from chain D (d) ├────►│   │
                            └───┘     └──────────────────────────┘     └───┘
                                                 ▲
                                     ┌───────────┘
                                     │
                            ┌─────────────────┐     ┌───┐     ┌───┐
       Chain D owned by (d) │ Operation 2 (d) ├────►│   ├────►│   │
                            └─────────────────┘     └───┘     └───┘
</code></pre>
<p>An example where this is used is in the Fungible application, where a <code>Claim</code>
operation allows retrieving money from a chain the user does not control (but
the user still trusts will produce a block receiving their message). Without the
<code>Claim</code> operation, users would only be able to store their tokens on their own
chains, and multi-owner and public chains would have their tokens shared between
anyone able to produce a block.</p>
<p>With the <code>Claim</code> operation, users can store their tokens on another chain where
they're able to produce blocks or where they trust the owner will produce blocks
receiving their messages. Only they are able to move their tokens, even on
chains where ownership is shared or where they are not able to produce blocks.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-design-patterns"><a class="header" href="#common-design-patterns">Common Design Patterns</a></h1>
<p>We now explore some common design patterns to take advantage of microchains.</p>
<h2 id="applications-with-only-user-chains"><a class="header" href="#applications-with-only-user-chains">Applications with only user chains</a></h2>
<p>Some applications such as payments only require user chains, hence are fully
horizontally scalable:</p>
<pre class="mermaid">flowchart LR
    user1([&quot;user 1&quot;]) -- initiates transfer --&gt; chain1

    subgraph validators_only_users[&quot;Validators&quot;]
      chain1[&quot;user chain 1&quot;] -- &quot;sends assets&quot; --&gt; chain2[&quot;user chain 2&quot;]
    end

    chain2 -- notifies --&gt; user2([&quot;user 2&quot;])

    %% Styling
    style validators_only_users fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user1 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style user2 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px

</pre>
<p><strong>Example:</strong> the
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/fungible">fungible demo application</a>
of the Linera codebase.</p>
<h2 id="clientserver-applications"><a class="header" href="#clientserver-applications">Client/server applications</a></h2>
<p>Pre-existing applications (e.g. written in Solidity) generally run on a single
chain of blocks for all users. Those can be embedded in an app chain to act as a
service.</p>
<pre class="mermaid">flowchart LR
    user1([&quot;user 1&quot;]) -- initiates request --&gt; chain1
    user1 ~~~ chain1
    provider([&quot;block producer&quot;]) -- initiate response(s) --&gt; chain3
    chain1 -- notifies --&gt; user1
    chain3 -- notifies --&gt; provider

    subgraph validators_cs[&quot;Validators&quot;]
      chain1[&quot;user chain 1&quot;] -- &quot;sends request&quot; --&gt; chain3
      chain1 ~~~ chain3
      chain2[&quot;user chain 2&quot;] --&gt; chain3
      chain3[&quot;app chain&quot;] -- &quot;sends response&quot; --&gt; chain1
    end

    %% Styling
    style validators_cs fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user1 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style provider fill:#A0736B,stroke:#D2E8C8,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain3 fill:#4A7B75,stroke:#70D4D3,stroke-width:2px

</pre>
<blockquote>
<p>Depending on the nature of the application, the blocks produced in the app
chain may be restricted to only contain messages (no operations). This is to
ensure that block producers have no influence on a chain, other than selecting
incoming messages.</p>
</blockquote>
<p><strong>Example:</strong> the
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/crowd-funding">crowd-funding demo application</a>
of the Linera codebase.</p>
<h2 id="using-personal-chains-to-scale-applications"><a class="header" href="#using-personal-chains-to-scale-applications">Using personal chains to scale applications</a></h2>
<p>User chains are useful to store the assets of their users and initiate requests
to app chains. Yet, oftentimes, they can also help applications scale
horizontally by taking work out of the app chains.</p>
<pre class="mermaid">flowchart LR
    user1([&quot;user 1&quot;]) -- submits ZK proof --&gt; chain1

    subgraph microchains_scale[&quot;Microchains&quot;]
      chain1[&quot;user chain 1&quot;]
      chain0[&quot;airdrop chain&quot;]
      chain1 -- &quot;sends trusted message《ZK proof is valid》&quot; --&gt; chain0
      chain1 ~~~ chain0
      chain0 -- &quot;sends tokens&quot; --&gt; chain1
      chain2[&quot;user chain 2&quot;] --&gt; chain0
    end

    %% Styling
    style microchains_scale fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user1 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain0 fill:#4A7B75,stroke:#70D4D3,stroke-width:2px

</pre>
<p>One of the benefits of personal chains is to enable transactions that would be
too slow or not deterministic enough for traditional blockchains, including:</p>
<ul>
<li>Validating ZK proofs,</li>
<li>Sending web queries to external oracle services (e.g. AI inference) and other
API providers,</li>
<li>Downloading data blobs from external data availability (”DA”) layers and
computing app-specific invariants.</li>
</ul>
<p><strong>Example (unfinished):</strong> the
<a href="https://github.com/linera-io/airdrop-demo">airdrop demo application</a> of the
Linera project.</p>
<h2 id="using-temporary-chains-to-scale-applications"><a class="header" href="#using-temporary-chains-to-scale-applications">Using temporary chains to scale applications</a></h2>
<p>Temporary chains can be created on demand and configured to accept blocks from
specific users.</p>
<p>The following diagram allows a virtually unlimited number of games (e.g. chess
game) to be spawned for a given tournament.</p>
<pre class="mermaid">flowchart LR
    subgraph microchains_scale[&quot;Microchains&quot;]
      chain1[&quot;user chain 1&quot;] &lt;--&gt; chain3
      chain2[&quot;user chain 2&quot;] &lt;--&gt; chain3
      chain3[&quot;tournament app chain&quot;] -- creates --&gt; chain0[&quot;temporary game chain&quot;]
      chain0 -- reports result --&gt; chain3
    end

    user1([&quot;user 1&quot;]) -- request game --&gt; chain1
    user2([&quot;user 2&quot;]) -- request game --&gt; chain2
    user1 -- plays --&gt; chain0
    user2 -- plays --&gt; chain0

    %% Styling
    style microchains_scale fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user1 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style user2 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain3 fill:#4A7B75,stroke:#70D4D3,stroke-width:2px

</pre>
<p><strong>Example:</strong> the
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/hex-game">hex-game demo application</a>
of the Linera codebase.</p>
<h2 id="just-in-time-oracles"><a class="header" href="#just-in-time-oracles">Just-in-time oracles</a></h2>
<p>We have seen that Linera clients are connected and don’t rely on external RPC
providers to read on-chain data from the chain. This ability to receive secure,
censorship-resistant notifications and read data from the network is a game
changer allowing on-chain applications to query certain clients in real time.</p>
<p>For instance, clients may be running an AI oracle off-chain in a trusted
execution environment (TEE), allowing on-chain application to extract important
information form the Internet.</p>
<pre class="mermaid">flowchart LR
    subgraph validators_only_users[&quot;Validators&quot;]
      chain2 -- oracle response --&gt; chain1
      chain1[&quot;app chain&quot;] -- &quot;oracle query&quot; --&gt; chain2[&quot;oracle chain&quot;]
    end
    subgraph tee[&quot;Oracle TEE&quot;]
      user2([&quot;oracle client&quot;]) &lt;--&gt; ai[&quot;AI oracle&quot;]
    end
    chain2 -- notifies --&gt; user2
    user2 -- submit response --&gt; chain2
    ai &lt;--&gt; web((Web))

    %% Styling
    style validators_only_users fill:#1A4456,stroke:#70D4D3,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style tee fill:#1A4456,stroke:#A0E3E2,stroke-width:2px,stroke-dasharray:3 3,rx:10,ry:10
    style user2 fill:#8B7355,stroke:#EDE4D2,stroke-width:2px
    style ai fill:#A0736B,stroke:#D2E8C8,stroke-width:2px
    style chain1 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px
    style chain2 fill:#3A6B7A,stroke:#A0E3E2,stroke-width:2px

</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-linera-applications"><a class="header" href="#writing-linera-applications">Writing Linera Applications</a></h1>
<p>In this section, we'll be exploring how to create Web3 applications using the
Linera SDK.</p>
<p>We'll use a simple "counter" application as a running example.</p>
<p>We'll focus on the backend of the application, which consists of two main parts:
a <em>smart contract</em> and its GraphQL service.</p>
<p>Both the contract and the service of an application are written in Rust using
the crate <a href="https://crates.io/crates/linera-sdk"><code>linera-sdk</code></a>, and compiled to
Wasm bytecode.</p>
<p>This section should be seen as a guide versus a reference manual for the SDK.
For the reference manual, refer to the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/">documentation of the crate</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-linera-project"><a class="header" href="#creating-a-linera-project">Creating a Linera Project</a></h1>
<p>To create your Linera project, use the <code>linera project new</code> command. The command
should be executed outside the <code>linera-protocol</code> folder. It sets up the
scaffolding and requisite files:</p>
<pre><code class="language-bash">linera project new my-counter
</code></pre>
<p><code>linera project new</code> bootstraps your project by creating the following key
files:</p>
<ul>
<li><code>Cargo.toml</code>: your project's manifest filled with the necessary dependencies
to create an app;</li>
<li><code>src/lib.rs</code>: the application's ABI definition;</li>
<li><code>src/state.rs</code>: the application's state;</li>
<li><code>src/contract.rs</code>: the application's contract, and the binary target for the
contract bytecode;</li>
<li><code>src/service.rs</code>: the application's service, and the binary target for the
service bytecode.</li>
</ul>
<blockquote>
<p>When writing Linera applications it is a convention to use your app's name as
a prefix for names of <code>trait</code>, <code>struct</code>, etc. Hence, in the following manual,
we will use <code>CounterContract</code>, <code>CounterService</code>, etc.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-application-state"><a class="header" href="#creating-the-application-state">Creating the Application State</a></h1>
<p>The state of a Linera application consists of onchain data that are persisted
between transactions.</p>
<p>The <code>struct</code> which defines your application's state can be found in
<code>src/state.rs</code>. To represent our counter, we're going to use a <code>u64</code> integer.</p>
<p>While we could use a plain data-structure for the entire application state:</p>
<pre><code class="language-rust">struct Counter {
  value: u64
}</code></pre>
<p>in general, we prefer to manage persistent data using the concept of "views":</p>
<blockquote>
<p><a href="https://docs.rs/linera-views/latest/linera_views/">Views</a> allow an
application to load persistent data in memory and stage modifications in a
flexible way.</p>
<p>Views resemble the persistent objects of an
<a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a>
framework, except that they are stored as a set of key-value pairs (instead of
a SQL row).</p>
</blockquote>
<p>In this case, the struct in <code>src/state.rs</code> should be replaced by</p>
<pre><code class="language-rust"><span class="boring">extern crate linera_sdk;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use linera_sdk::linera_base_types::*;
</span><span class="boring">use linera_sdk::*;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use linera_sdk::views::{linera_views, RegisterView, RootView, ViewStorageContext};
</span><span class="boring">use crate::linera_sdk::views::View as _;
</span>/// The application state.
#[derive(RootView, async_graphql::SimpleObject)]
#[view(context = ViewStorageContext)]
pub struct Counter {
    pub value: RegisterView&lt;u64&gt;,
    // Additional fields here will get their own key in storage.
}</code></pre>
<p>and the occurrences of <code>Application</code> in the rest of the project should be
replaced by <code>Counter</code>.</p>
<p>The derive macro <code>async_graphql::SimpleObject</code> is related to GraphQL queries
discussed in the <a href="developers/backend/service.html">next section</a>.</p>
<p>A <code>RegisterView&lt;T&gt;</code> supports modifying a single value of type <code>T</code>. Other data
structures available in the library
<a href="https://docs.rs/linera-views/latest/linera_views/"><code>linera_views</code></a> include:</p>
<ul>
<li><code>LogView</code> for a growing vector of values;</li>
<li><code>QueueView</code> for queues;</li>
<li><code>MapView</code> and <code>CollectionView</code> for associative maps; specifically, <code>MapView</code>
in the case of static values, and <code>CollectionView</code> when values are other
views.</li>
</ul>
<p>For an exhaustive list of the different constructions, refer to the crate
<a href="https://docs.rs/linera-views/latest/linera_views/">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-the-abi"><a class="header" href="#defining-the-abi">Defining the ABI</a></h1>
<p>The Application Binary Interface (ABI) of a Linera application defines how to
interact with this application from other parts of the system. It includes the
data structures, data types, and functions exposed by on-chain contracts and
services.</p>
<p>ABIs are usually defined in <code>src/lib.rs</code> and compiled across all architectures
(Wasm and native).</p>
<p>For a reference guide, check out the
<a href="https://docs.rs/linera-base/latest/linera_base/abi/">documentation of the crate</a>.</p>
<h2 id="defining-a-marker-struct"><a class="header" href="#defining-a-marker-struct">Defining a marker struct</a></h2>
<p>The library part of your application (generally in <code>src/lib.rs</code>) must define a
public empty struct that implements the <code>Abi</code> trait.</p>
<pre><code class="language-rust">struct CounterAbi;</code></pre>
<p>The <code>Abi</code> trait combines the <code>ContractAbi</code> and <code>ServiceAbi</code> traits to include
the types that your application exports.</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application (both contract
/// and service).
pub trait Abi: ContractAbi + ServiceAbi {}</code></pre>
<p>Next, we're going to implement each of the two traits.</p>
<h2 id="contract-abi"><a class="header" href="#contract-abi">Contract ABI</a></h2>
<p>The <code>ContractAbi</code> trait defines the data types that your application uses in a
contract. Each type represents a specific part of the contract's behavior:</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application contract.
pub trait ContractAbi {
    /// The type of operation executed by the application.
    ///
    /// Operations are transactions directly added to a block by the creator (and signer)
    /// of the block. Users typically use operations to start interacting with an
    /// application on their own chain.
    type Operation: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The response type of an application call.
    type Response: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// How the `Operation` is deserialized
    fn deserialize_operation(operation: Vec&lt;u8&gt;) -&gt; Result&lt;Self::Operation, String&gt; {
        bcs::from_bytes(&amp;operation)
            .map_err(|e| format!("BCS deserialization error {e:?} for operation {operation:?}"))
    }

    /// How the `Operation` is serialized
    fn serialize_operation(operation: &amp;Self::Operation) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
        bcs::to_bytes(operation)
            .map_err(|e| format!("BCS serialization error {e:?} for operation {operation:?}"))
    }

    /// How the `Response` is deserialized
    fn deserialize_response(response: Vec&lt;u8&gt;) -&gt; Result&lt;Self::Response, String&gt; {
        bcs::from_bytes(&amp;response)
            .map_err(|e| format!("BCS deserialization error {e:?} for response {response:?}"))
    }

    /// How the `Response` is serialized
    fn serialize_response(response: Self::Response) -&gt; Result&lt;Vec&lt;u8&gt;, String&gt; {
        bcs::to_bytes(&amp;response)
            .map_err(|e| format!("BCS serialization error {e:?} for response {response:?}"))
    }
}</code></pre>
<p>All these types must implement the <code>Serialize</code>, <code>DeserializeOwned</code>, <code>Send</code>,
<code>Sync</code>, <code>Debug</code> traits, and have a <code>'static</code> lifetime.</p>
<p>In our example, we would like to change our <code>Operation</code> to <code>u64</code>, like so:</p>
<pre><code class="language-rust ignore">pub struct CounterAbi;

impl ContractAbi for CounterAbi {
    type Operation = u64;
    type Response = u64;
}</code></pre>
<h2 id="service-abi"><a class="header" href="#service-abi">Service ABI</a></h2>
<p>The <code>ServiceAbi</code> is in principle very similar to the <code>ContractAbi</code>, just for the
service component of your application.</p>
<p>The <code>ServiceAbi</code> trait defines the types used by the service part of your
application:</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application service.
pub trait ServiceAbi {
    /// The type of a query receivable by the application's service.
    type Query: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The response type of the application's service.
    type QueryResponse: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;
}</code></pre>
<p>For our <code>Counter</code> example, we'll be using GraphQL to query our application so
our <code>ServiceAbi</code> should reflect that:</p>
<pre><code class="language-rust ignore">use async_graphql::{Request, Response};

impl ServiceAbi for CounterAbi {
    type Query = Request;
    type QueryResponse = Response;
}</code></pre>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>
<p>The full trait definition of <code>Abi</code> can be found
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/linera-base/src/abi.rs">here</a>.</p>
</li>
<li>
<p>The full <code>Counter</code> example application can be found
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/counter">here</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-contract-binary"><a class="header" href="#writing-the-contract-binary">Writing the Contract Binary</a></h1>
<p>The contract binary is the first component of a Linera application. It can
actually change the state of the application.</p>
<p>To create a contract, we need to create a new type and implement the <code>Contract</code>
trait for it, which is as follows:</p>
<pre><code class="language-rust ignore">pub trait Contract: WithContractAbi + ContractAbi + Sized {
    /// The type of message executed by the application.
    type Message: Serialize + DeserializeOwned + Debug;

    /// Immutable parameters specific to this application (e.g. the name of a token).
    type Parameters: Serialize + DeserializeOwned + Clone + Debug;

    /// Instantiation argument passed to a new application on the chain that created it
    /// (e.g. an initial amount of tokens minted).
    type InstantiationArgument: Serialize + DeserializeOwned + Debug;

    /// Event values for streams created by this application.
    type EventValue: Serialize + DeserializeOwned + Debug;

    /// Creates an in-memory instance of the contract handler.
    async fn load(runtime: ContractRuntime&lt;Self&gt;) -&gt; Self;

    /// Instantiates the application on the chain that created it.
    async fn instantiate(&amp;mut self, argument: Self::InstantiationArgument);

    /// Applies an operation from the current block.
    async fn execute_operation(&amp;mut self, operation: Self::Operation) -&gt; Self::Response;

    /// Applies a message originating from a cross-chain message.
    async fn execute_message(&amp;mut self, message: Self::Message);

    /// Reacts to new events on streams.
    ///
    /// This is called whenever there is a new event on any stream that this application
    /// subscribes to.
    async fn process_streams(&amp;mut self, _updates: Vec&lt;StreamUpdate&gt;) {}

    /// Finishes the execution of the current transaction.
    async fn store(self);
}</code></pre>
<p>There's quite a bit going on here, so let's break it down and take one method at
a time.</p>
<p>For this application, we'll be using the <code>load</code>, <code>execute_operation</code> and <code>store</code>
methods.</p>
<h2 id="the-contract-lifecycle"><a class="header" href="#the-contract-lifecycle">The contract lifecycle</a></h2>
<p>To implement the application contract, we first create a type for the contract:</p>
<pre><code class="language-rust ignore">linera_sdk::contract!(CounterContract);

pub struct CounterContract {
    state: CounterState,
    runtime: ContractRuntime&lt;Self&gt;,
}</code></pre>
<p>This type usually contains at least two fields: the persistent <code>state</code> defined
earlier and a handle to the runtime. The runtime provides access to information
about the current execution and also allows sending messages, among other
things. Other fields can be added, and they can be used to store volatile data
that only exists while the current transaction is being executed, and discarded
afterwards.</p>
<p>When a transaction is executed, the contract type is created through a call to
<code>Contract::load</code> method. This method receives a handle to the runtime that the
contract can use, and should use it to load the application state. For our
implementation, we will load the state and create the <code>CounterContract</code>
instance:</p>
<pre><code class="language-rust ignore">    async fn load(runtime: ContractRuntime&lt;Self&gt;) -&gt; Self {
        let state = CounterState::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");
        CounterContract { state, runtime }
    }</code></pre>
<p>When the transaction finishes executing successfully, there's a final step where
all loaded application contracts are called in order to do any final checks and
persist its state to storage. That final step is a call to the <code>Contract::store</code>
method, which can be thought of as similar to executing a destructor. In our
implementation we will persist the state back to storage:</p>
<pre><code class="language-rust ignore">    async fn store(mut self) {
        self.state.save().await.expect("Failed to save state");
    }</code></pre>
<p>It's possible to do more than just saving the state, and the
<a href="developers/backend/../advanced_topics/contract_finalize.html">Contract finalization section</a>
provides more details on that.</p>
<h2 id="instantiating-our-application"><a class="header" href="#instantiating-our-application">Instantiating our Application</a></h2>
<p>The first thing that happens when an application is created from a bytecode is
that it is instantiated. This is done by calling the contract's
<code>Contract::instantiate</code> method.</p>
<p><code>Contract::instantiate</code> is only called once when the application is created and
only on the microchain that created the application.</p>
<p>Deployment on other microchains will use the <code>Default</code> value of all sub-views in
the state if the state uses the view paradigm.</p>
<p>For our example application, we'll want to initialize the state of the
application to an arbitrary number that can be specified on application creation
using its instantiation parameters:</p>
<pre><code class="language-rust ignore">    async fn instantiate(&amp;mut self, value: u64) {
        // Validate that the application parameters were configured correctly.
        self.runtime.application_parameters();

        self.state.value.set(value);
    }</code></pre>
<h2 id="implementing-the-increment-operation"><a class="header" href="#implementing-the-increment-operation">Implementing the increment operation</a></h2>
<p>Now that we have our counter's state and a way to initialize it to any value we
would like, we need a way to increment our counter's value. Execution requests
from block proposers or other applications are broadly called 'operations'.</p>
<p>To handle an operation, we need to implement the <code>Contract::execute_operation</code>
method. In the counter's case, the operation it will be receiving is a <code>u64</code>
which is used to increment the counter by that value:</p>
<pre><code class="language-rust ignore">    async fn execute_operation(&amp;mut self, operation: u64) -&gt; u64 {
        let new_value = self.state.value.get() + operation;
        self.state.value.set(new_value);
        new_value
    }</code></pre>
<h2 id="declaring-the-abi"><a class="header" href="#declaring-the-abi">Declaring the ABI</a></h2>
<p>Finally, we link our <code>Contract</code> trait implementation with the ABI of the
application:</p>
<pre><code class="language-rust ignore">impl WithContractAbi for CounterContract {
    type Abi = CounterAbi;
}</code></pre>
<h2 id="references-1"><a class="header" href="#references-1">References</a></h2>
<ul>
<li>
<p>The full trait definition of <code>Contract</code> can be found
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/linera-sdk/src/lib.rs">here</a>.</p>
</li>
<li>
<p>The full <code>Counter</code> example application can be found
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/counter">here</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-service-binary"><a class="header" href="#writing-the-service-binary">Writing the Service Binary</a></h1>
<p>The service binary is the second component of a Linera application. It is
compiled into a separate Bytecode from the contract and is run independently. It
is not metered (meaning that querying an application's service does not consume
gas), and can be thought of as a read-only view into your application.</p>
<p>Application states can be arbitrarily complex, and most of the time you don't
want to expose this state in its entirety to those who would like to interact
with your app. Instead, you might prefer to define a distinct set of queries
that can be made against your application.</p>
<p>The <code>Service</code> trait is how you define the interface into your application. The
<code>Service</code> trait is defined as follows:</p>
<pre><code class="language-rust ignore">pub trait Service: WithServiceAbi + ServiceAbi + Sized {
    /// Immutable parameters specific to this application.
    type Parameters: Serialize + DeserializeOwned + Send + Sync + Clone + Debug + 'static;

    /// Creates an in-memory instance of the service handler.
    async fn new(runtime: ServiceRuntime&lt;Self&gt;) -&gt; Self;

    /// Executes a read-only query on the state of this application.
    async fn handle_query(&amp;self, query: Self::Query) -&gt; Self::QueryResponse;
}</code></pre>
<p>Let's implement <code>Service</code> for our counter application.</p>
<p>First, we create a new type for the service, similarly to the contract:</p>
<pre><code class="language-rust ignore">linera_sdk::service!(CounterService);

pub struct CounterService {
    state: CounterState,
    runtime: Arc&lt;ServiceRuntime&lt;Self&gt;&gt;,
}</code></pre>
<p>Just like with the <code>CounterContract</code> type, this type usually has two types: the
application <code>state</code> and the <code>runtime</code>. We can omit the fields if we don't use
them, so in this example we're omitting the <code>runtime</code> field, since its only used
when constructing the <code>CounterService</code> type.</p>
<p>As before, the macro <code>service!</code> generates the necessary boilerplate for
implementing the service
<a href="https://component-model.bytecodealliance.org/design/wit.html">WIT interface</a>,
exporting the necessary resource types and functions so that the service can be
executed.</p>
<p>Next, we need to implement the <code>Service</code> trait for <code>CounterService</code> type. The
first step is to define the <code>Service</code>'s associated type, which is the global
parameters specified when the application is instantiated. In our case, the
global parameters aren't used, so we can just specify the unit type:</p>
<pre><code class="language-rust ignore">impl Service for CounterService {
    type Parameters = ();

    // ...
}</code></pre>
<p>Also like in contracts, we must implement a <code>load</code> constructor when implementing
the <code>Service</code> trait. The constructor receives the runtime handle and should use
it to load the application state:</p>
<pre><code class="language-rust ignore">    async fn new(runtime: ServiceRuntime&lt;Self&gt;) -&gt; Self {
        let state = CounterState::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");
        CounterService {
            state,
            runtime: Arc::new(runtime),
        }
    }</code></pre>
<p>Services don't have a <code>store</code> method because they are read-only and can't
persist any changes back to the storage.</p>
<p>The actual functionality of the service starts in the <code>handle_query</code> method. We
will accept GraphQL queries and handle them using the
<a href="https://github.com/async-graphql/async-graphql"><code>async-graphql</code> crate</a>. To
forward the queries to custom GraphQL handlers we will implement in the next
section, we use the following code:</p>
<pre><code class="language-rust ignore">    async fn handle_query(&amp;self, request: Request) -&gt; Response {
        let schema = Schema::build(
            QueryRoot {
                value: *self.state.value.get(),
            },
            MutationRoot {
                runtime: self.runtime.clone(),
            },
            EmptySubscription,
        )
        .finish();
        schema.execute(request).await
    }</code></pre>
<p>Finally, as before, the following code is needed to incorporate the ABI
definitions into your <code>Service</code> implementation:</p>
<pre><code class="language-rust ignore">impl WithServiceAbi for CounterService {
    type Abi = counter::CounterAbi;
}</code></pre>
<h2 id="adding-graphql-compatibility"><a class="header" href="#adding-graphql-compatibility">Adding GraphQL compatibility</a></h2>
<p>Finally, we want our application to have GraphQL compatibility. To achieve this
we need a <code>QueryRoot</code> to respond to queries and a <code>MutationRoot</code> for creating
serialized <code>Operation</code> values that can be placed in blocks.</p>
<p>In the <code>QueryRoot</code>, we only create a single <code>value</code> query that returns the
counter's value:</p>
<pre><code class="language-rust ignore">struct QueryRoot {
    value: u64,
}

#[Object]
impl QueryRoot {
    async fn value(&amp;self) -&gt; &amp;u64 {
        &amp;self.value
    }
}</code></pre>
<p>In the <code>MutationRoot</code>, we only create one <code>increment</code> method that returns a
serialized operation to increment the counter by the provided <code>value</code>:</p>
<pre><code class="language-rust ignore">struct MutationRoot {
    runtime: Arc&lt;ServiceRuntime&lt;CounterService&gt;&gt;,
}

#[Object]
impl MutationRoot {
    async fn increment(&amp;self, value: u64) -&gt; [u8; 0] {
        self.runtime.schedule_operation(&amp;value);
        []
    }
}</code></pre>
<p>We haven't included the imports in the above code. If you want the full source
code and associated tests check out the <a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/counter/src/service.rs">examples
section</a> on
GitHub.</p>
<h2 id="references-2"><a class="header" href="#references-2">References</a></h2>
<ul>
<li>
<p>The full trait definition of <code>Service</code> can be found
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/linera-sdk/src/lib.rs">here</a>.</p>
</li>
<li>
<p>The full <code>Counter</code> example application can be found
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/counter">here</a>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-the-application"><a class="header" href="#deploying-the-application">Deploying the Application</a></h1>
<p>The first step to deploy your application is to configure a wallet. This will
determine where the application will be deployed: either to a local net or to
the public deployment (i.e. a devnet or a testnet).</p>
<h2 id="local-network"><a class="header" href="#local-network">Local network</a></h2>
<p>To configure the local network, follow the steps in the
<a href="developers/backend/../getting_started/hello_linera.html#using-the-initial-test-wallet">Getting Started section</a>.</p>
<p>Afterwards, the <code>LINERA_WALLET</code>, <code>LINERA_STORAGE</code>, <code>LINERA_KEYSTORE</code> environment
variables should be set and can be used in the <code>publish-and-create</code> command to
deploy the application while also specifying:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  target/wasm32-unknown-unknown/release/my_counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<h2 id="devnets-and-testnets"><a class="header" href="#devnets-and-testnets">Devnets and Testnets</a></h2>
<p>To configure the wallet for the current testnet while creating a new microchain,
the following command can be used:</p>
<pre><code class="language-bash">linera wallet init --faucet https://faucet.testnet-conway.linera.net
linera wallet request-chain --faucet https://faucet.testnet-conway.linera.net
</code></pre>
<p>The Faucet will provide the new chain with some tokens, which can then be used
to deploy the application with the <code>publish-and-create</code> command. It requires
specifying:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  target/wasm32-unknown-unknown/release/my_counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<h2 id="interacting-with-the-application"><a class="header" href="#interacting-with-the-application">Interacting with the application</a></h2>
<p>To interact with the deployed application, a
<a href="developers/backend/../core_concepts/node_service.html">node service</a> must be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-chain-messages"><a class="header" href="#cross-chain-messages">Cross-Chain Messages</a></h1>
<p>On Linera, applications are meant to be multi-chain: They are instantiated on
every chain where they are used. An application has the same application ID and
bytecode everywhere, but a separate state on every chain. To coordinate, the
instances can send <em>cross-chain messages</em> to each other. A message sent by an
application is always handled by the <em>same</em> application on the target chain: The
handling code is guaranteed to be the same as the sending code, but the state
may be different.</p>
<p>For your application, you can specify any serializable type as the <code>Message</code>
type in your <code>Contract</code> implementation. To send a message, use the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/contract/struct.ContractRuntime.html"><code>ContractRuntime</code></a>
made available as an argument to the contract's
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/trait.Contract.html#tymethod.load"><code>Contract::load</code></a>
constructor. The runtime is usually stored inside the contract object, as we did
when <a href="developers/backend/./contract.html">writing the contract binary</a>. We can then call
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/contract/struct.ContractRuntime.html#method_prepare_message"><code>ContractRuntime::prepare_message</code></a>
to start preparing a message, and then <code>send_to</code> to send it to a destination
chain.</p>
<pre><code class="language-rust ignore">    self.runtime
        .prepare_message(message_contents)
        .send_to(destination_chain_id);</code></pre>
<p>After block execution in the <em>sending</em> chain, sent messages are placed in the
<em>target</em> chains' inboxes for processing. There is no guarantee that it will be
handled: For this to happen, an owner of the target chain needs to include it in
the <code>incoming_messages</code> in one of their blocks. When that happens, the
contract's <code>execute_message</code> method gets called on their chain.</p>
<p>While preparing the message to be sent, it is possible to enable authentication
forwarding and/or tracking. Authentication forwarding means that the message is
executed by the receiver with the same authenticated signer as the sender of the
message, while tracking means that the message is sent back to the sender if the
receiver rejects it. The example below enables both flags:</p>
<pre><code class="language-rust ignore">    self.runtime
        .prepare_message(message_contents)
        .with_tracking()
        .with_authentication()
        .send_to(destination_chain_id);</code></pre>
<h2 id="example-fungible-token"><a class="header" href="#example-fungible-token">Example: fungible token</a></h2>
<p>In the <a href="https://github.com/linera-io/linera-protocol/tree/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/fungible"><code>fungible</code> example
application</a>, such a message
can be the transfer of tokens from one chain to another. If the sender includes
a <code>Transfer</code> operation on their chain, it decreases their account balance and
sends a <code>Credit</code> message to the recipient's chain:</p>
<pre><code class="language-rust ignore">async fn execute_operation(&amp;mut self, operation: Self::Operation) -&gt; Self::Response {
        match operation {
            FungibleOperation::Transfer {
                owner,
                amount,
                target_account,
            } =&gt; {
                self.runtime
                    .check_account_permission(owner)
                    .expect("Permission for Transfer operation");
                self.state.debit(owner, amount).await;
                self.finish_transfer_to_account(amount, target_account, owner)
                    .await;
                FungibleResponse::Ok
            }
            // ...
        }
}</code></pre>
<pre><code class="language-rust ignore">    /// Executes the final step of a transfer where the tokens are sent to the destination.
    async fn finish_transfer_to_account(
        &amp;mut self,
        amount: Amount,
        target_account: Account,
        source: AccountOwner,
    ) {
        if target_account.chain_id == self.runtime.chain_id() {
            self.state.credit(target_account.owner, amount).await;
        } else {
            let message = Message::Credit {
                target: target_account.owner,
                amount,
                source,
            };
            self.runtime
                .prepare_message(message)
                .with_authentication()
                .with_tracking()
                .send_to(target_account.chain_id);
        }
    }</code></pre>
<p>On the recipient's chain, <code>execute_message</code> is called, which increases their
account balance.</p>
<pre><code class="language-rust ignore">    async fn execute_message(&amp;mut self, message: Message) {
        match message {
            Message::Credit {
                amount,
                target,
                source,
            } =&gt; {
                let is_bouncing = self
                    .runtime
                    .message_is_bouncing()
                    .expect("Delivery status is available when executing a message");
                let receiver = if is_bouncing { source } else { target };
                self.state.credit(receiver, amount).await;
            }
            // ...
        }
    }</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-other-applications"><a class="header" href="#calling-other-applications">Calling other Applications</a></h1>
<p>We have seen that cross-chain messages sent by an application on one chain are
always handled by the <em>same</em> application on the target chain.</p>
<p>This section is about calling other applications using <em>cross-application
calls</em>.</p>
<p>Such calls happen on the same chain and are made with the helper method
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/contract/struct.ContractRuntime.html#method_call_application"><code>ContractRuntime::call_application</code></a>:</p>
<pre><code class="language-rust ignore">    pub fn call_application&lt;A: ContractAbi + Send&gt;(
        &amp;mut self,
        authenticated: bool,
        application: ApplicationId&lt;A&gt;,
        call: &amp;A::Operation,
    ) -&gt; A::Response</code></pre>
<p>The <code>authenticated</code> argument specifies whether the callee is allowed to perform
actions that require authentication either</p>
<ul>
<li>on behalf of the signer of the original block that caused this call, or</li>
<li>on behalf of the calling application.</li>
</ul>
<p>The <code>application</code> argument is the callee's application ID, and <code>A</code> is the
callee's ABI.</p>
<p>The <code>call</code> argument is the operation requested by the application call.</p>
<h2 id="example-crowd-funding"><a class="header" href="#example-crowd-funding">Example: crowd-funding</a></h2>
<p>The <code>crowd-funding</code> example application allows the application creator to launch
a campaign with a funding target. That target can be an amount specified in any
type of token based on the <code>fungible</code> application. Others can then pledge tokens
of that type to the campaign, and if the target is not reached by the deadline,
they are refunded.</p>
<p>If Alice used the <code>fungible</code> example to create a Pugecoin application (with an
impressionable pug as its mascot), then Bob can create a <code>crowd-funding</code>
application, use Pugecoin's application ID as <code>CrowdFundingAbi::Parameters</code>, and
specify in <code>CrowdFundingAbi::InstantiationArgument</code> that his campaign will run
for one week and has a target of 1000 Pugecoins.</p>
<p>Now let's say Carol wants to pledge 10 Pugecoin tokens to Bob's campaign. She
can make her pledge by running the <code>linera service</code> and making a query to Bob's
application:</p>
<pre><code class="language-json">mutation { pledge(owner: "User:841…6c0", amount: "10") }
</code></pre>
<p>This will add a block to Carol's chain containing the pledge operation that gets
handled by <code>CrowdFunding::execute_operation</code>, resulting in one cross-application
call and two cross-chain messages:</p>
<p>First <code>CrowdFunding::execute_operation</code> calls the <code>fungible</code> application on
Carol's chain to transfer 10 tokens to Carol's account on Bob's chain:</p>
<pre><code class="language-rust ignore">// ...
let call = fungible::Operation::Transfer {
    owner,
    amount,
    target_account,
};
// ...
self.runtime
    .call_application(/* authenticated by owner */ true, fungible_id, &amp;call);</code></pre>
<p>This causes <code>Fungible::execute_operation</code> to be run, which will create a
cross-chain message sending the amount 10 to the Pugecoin application instance
on Bob's chain.</p>
<p>After the cross-application call returns, <code>CrowdFunding::execute_operation</code>
continues to create another cross-chain message
<code>crowd_funding::Message::PledgeWithAccount</code>, which informs the crowd-funding
application on Bob's chain that the 10 tokens are meant for the campaign.</p>
<p>When Bob now adds a block to his chain that handles the two incoming messages,
first <code>Fungible::execute_message</code> gets executed, and then
<code>CrowdFunding::execute_message</code>. The latter makes another cross-application call
to transfer the 10 tokens from Carol's account to the crowd-funding
application's account (both on Bob's chain). That is successful because Carol
does now have 10 tokens on this chain and she authenticated the transfer
indirectly by signing her block. The crowd-funding application now makes a note
in its application state on Bob's chain that Carol has pledged 10 Pugecoin
tokens.</p>
<h1 id="references-3"><a class="header" href="#references-3">References</a></h1>
<p>For the complete code, please take a look at the
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/crowd-funding/src/contract.rs"><code>crowd-funding</code></a>
and the
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/fungible/src/contract.rs"><code>fungible</code></a>
application contracts in the <code>examples</code> folder in <code>linera-protocol</code>.</p>
<p>The implementation of the Runtime made available to contracts is defined in
<a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/linera-sdk/src/contract/runtime.rs">this file</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-data-blobs"><a class="header" href="#using-data-blobs">Using Data Blobs</a></h1>
<p>Some applications may want to use static assets, like images or other data: e.g.
the <code>non-fungible</code> example application implements NFTs, and each NFT has an
associated image.</p>
<p>Data blobs are pieces of binary data that, once published on <em>any</em> chain, can be
used on <em>all</em> chains. What format they are in and what they are used for is
determined by the application(s) that read(s) them.</p>
<p>You can use the <code>linera publish-data-blob</code> command to publish the contents of a
file, as an operation in a block on one of your chains. This will print the ID
of the new blob, including its hash. Alternatively, you can run <code>linera service</code>
and use the <code>publishDataBlob</code> GraphQL mutation.</p>
<p>Applications can now use <code>runtime.read_data_blob(blob_hash)</code> to read the blob.
This works on any chain, not only the one that published it. The first time your
client executes a block reading a blob, it will download the blob from the
validators if it doesn't already have it locally.</p>
<p>In the case of the NFT app, it is only the service, not the contract, that
actually uses the blob data to display it as an image in the frontend. But we
still want to make sure that the user has the image locally as soon as they
receive an NFT, even if they don't view it yet. This can be achieved by calling
<code>runtime.assert_data_blob_exists(blob_hash)</code> in the contract: It will make sure
the data is available, without actually loading it.</p>
<p>For the complete code please take a look at the <a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/non-fungible/src/contract.rs"><code>non-fungible</code>
contract</a>
and <a href="https://github.com/linera-io/linera-protocol/blob/fd6b3cc05da4729f1c44cdd87e225a339890517e/examples/non-fungible/src/service.rs">service</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-logs-from-an-application"><a class="header" href="#printing-logs-from-an-application">Printing Logs from an Application</a></h1>
<p>Applications can use the <a href="https://crates.io/crates/log"><code>log</code> crate</a> to print
log messages with different levels of importance. Log messages are useful during
development, but they may also be useful for end users. By default the
<code>linera service</code> command will log the messages from an application if they are
of the "info" importance level or higher (briefly, <code>log::info!</code>, <code>log::warn!</code>
and <code>log::error!</code>).</p>
<p>During development it is often useful to log messages of lower importance (such
as <code>log::debug!</code> and <code>log::trace!</code>). To enable them, the <code>RUST_LOG</code> environment
variable must be set before running <code>linera service</code>. The example below enables
trace level messages from applications and enables warning level messages from
other parts of the <code>linera</code> binary:</p>
<pre><code class="language-ignore">export RUST_LOG="warn,linera_execution::wasm=trace"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<p>Linera applications can be tested using normal Rust unit tests or integration
tests. Unit tests use a mock runtime for execution, so it's useful for testing
the application as if it were running by itself on a single chain. Integration
tests use a simulated validator for testing. This allows creating chains and
adding blocks to them in order to test interactions between multiple microchains
and multiple applications.</p>
<p>Applications should consider having both types of tests. Unit tests should be
used to focus on the application's internals and core functionality. Integration
tests should be used to test how the application behaves on a more complex
environment that's closer to the real network. Both types of test are running in
native Rust.</p>
<blockquote>
<p>For Rust tests, the <code>cargo test</code> command can be used to run both the unit and
integration tests.</p>
</blockquote>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Unit tests are written beside the application's source code (i.e., inside the
<code>src</code> directory of the project). The main purpose of a unit test is to test
parts of the application in an isolated environment. Anything that's external is
usually mocked. When the <code>linera-sdk</code> is compiled with the <code>test</code> feature
enabled, the <code>ContractRuntime</code> and <code>SystemRuntime</code> types are actually mock
runtimes, and can be configured to return specific values for different tests.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>A simple unit test is shown below, which tests if the method <code>execute_operation</code>
method changes the application state of the <code>Counter</code> application.</p>
<pre><code class="language-rust ignore">    #[test]
    fn operation() {
        let runtime = ContractRuntime::new().with_application_parameters(());
        let state = CounterState::load(runtime.root_view_storage_context())
            .blocking_wait()
            .expect("Failed to read from mock key value store");
        let mut counter = CounterContract { state, runtime };

        let initial_value = 72_u64;
        counter
            .instantiate(initial_value)
            .now_or_never()
            .expect("Initialization of counter state should not await anything");

        let increment = 42_308_u64;

        let response = counter
            .execute_operation(increment)
            .now_or_never()
            .expect("Execution of counter operation should not await anything");

        let expected_value = initial_value + increment;

        assert_eq!(response, expected_value);
        assert_eq!(*counter.state.value.get(), initial_value + increment);
    }</code></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration tests</a></h2>
<p>Integration tests are usually written separately from the application's source
code (i.e., inside a <code>tests</code> directory that's beside the <code>src</code> directory).</p>
<p>Integration tests use the helper types from <code>linera_sdk::test</code> to set up a
simulated Linera network, and publish blocks to microchains in order to execute
the application.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>A simple integration test that execution a block containing an operation for the
<code>Counter</code> application is shown below.</p>
<pre><code class="language-rust ignore">#[tokio::test(flavor = "multi_thread")]
async fn single_chain_test() {
    let (validator, module_id) =
        TestValidator::with_current_module::&lt;counter::CounterAbi, (), u64&gt;().await;
    let mut chain = validator.new_chain().await;

    let initial_state = 42u64;
    let application_id = chain
        .create_application(module_id, (), initial_state, vec![])
        .await;

    let increment = 15u64;
    chain
        .add_block(|block| {
            block.with_operation(application_id, increment);
        })
        .await;

    let final_value = initial_state + increment;
    let QueryOutcome { response, .. } =
        chain.graphql_query(application_id, "query { value }").await;
    let state_value = response["value"].as_u64().expect("Failed to get the u64");
    assert_eq!(state_value, final_value);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-linera-application-frontends"><a class="header" href="#writing-linera-application-frontends">Writing Linera application frontends</a></h1>
<p>Linera comes with a Web client library that supports calling applications using
a JavaScript API directly inside Web pages.</p>
<p>After you complete this section, you'll know how to build interactive frontends
for Linera applications, taking advantage of Linera's push notifications to
implement realtime reactivity.</p>
<p>We're going to be building a frontend for the <code>counter</code> example we covered in
<a href="developers/backend.html">Writing Application Backends</a>, so make sure to either complete that
first or deploy the completed application from the <code>linera-protocol</code> <code>examples</code>
directory and take a note of the resulting application ID.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frontend-architecture-overview"><a class="header" href="#frontend-architecture-overview">Frontend Architecture Overview</a></h1>
<p>The Linera client library is written in Rust. To make it available to Web
applications, we first compile it to WebAssembly, then wrap it with some
JavaScript convenience APIs using
<a href="https://github.com/rustwasm/wasm-bindgen"><code>wasm-bindgen</code></a>. This wrapper will
first download the client WebAssembly blob, and then forward calls to it, doing
marshalling as necessary.</p>
<p>In addition, on the Web some system APIs are provided in the browser as
JavaScript APIs, so making system calls for these is replaced by FFI calls to
the equivalent browser APIs. Notably:</p>
<ul>
<li>to get the current date/time, we use the JavaScript
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/now"><code>Date::now</code></a>
API</li>
<li>as our source of cryptographic randomness, we use the
<a href="https://www.w3.org/TR/WebCryptoAPI/#Crypto-method-getRandomValues">Web Crypto API</a></li>
<li><a href="https://tokio.rs/">Tokio</a> is replaced by JavaScript promises on the browser
event loop</li>
<li>communication with validators over gRPC is replaced with
<a href="https://grpc.io/docs/platforms/web/basics/">gRPC-Web</a> over the browser
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch"><code>fetch</code> API</a></li>
<li>filesystem access is replaced with
<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API">IndexedDB</a></li>
<li>the client is run single-threaded, except for bytecode execution, which uses
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API">Web Workers</a></li>
</ul>
<p>The architecture for a dApp frontend with the client library embedded can be
summarized as follows:</p>
<pre class="mermaid">graph TD

classDef empty fill:none,stroke:none

subgraph &quot;@linera/client (Rust)&quot;
	linera-web-client[&quot;linera-web-client&quot;]
	  --&gt; linera-protocol[&quot;linera-protocol&quot;]
end

subgraph &quot;Browser APIs&quot;
	linera-protocol --&gt; web-workers-api[&quot;Web Worker API&quot;]
  linera-protocol --&gt; wasm-api[&quot;WASM API&quot;]
  linera-protocol --&gt; fetch-api[&quot;Fetch API&quot;]
  linera-protocol --&gt; crypto-api[&quot;Crypto API&quot;]
  browser-apis[&quot;. . .&quot;]:::empty
end

fetch-api &lt;--&gt; network[&quot;Linera network&quot;]@{shape: &quot;lean-r&quot;}

subgraph &quot;Hosted dApp (JS)&quot;
  hosted-frontend[&quot;Frontend&quot;] --&gt; linera-web-client
end
</pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="setting-up-the-frontend-development-environment"><a class="header" href="#setting-up-the-frontend-development-environment">Setting up the Frontend Development Environment</a></h1>
<h2 id="supported-browsers"><a class="header" href="#supported-browsers">Supported browsers</a></h2>
<p>The Linera client library is supported by most mainstream browsers at the time
of writing (Baseline 2023). It does make use of some fairly modern features, so
if your browser version is too old you may struggle to follow this tutorial.
Specifically, your browser should support:</p>
<ul>
<li><a href="https://caniuse.com/import-maps">import maps</a></li>
<li><a href="https://caniuse.com/sharedarraybuffer"><code>SharedArrayBuffer</code></a></li>
<li><a href="https://caniuse.com/wasm-threads">WebAssembly threading primitives</a></li>
<li><a href="https://caniuse.com/mdn-javascript_operators_await_top_level">top-level <code>await</code></a>
— this will be used for brevity in the tutorial, but is easy to factor out if
your browser doesn't support it</li>
</ul>
<h2 id="creating-a-basic-html-page"><a class="header" href="#creating-a-basic-html-page">Creating a basic HTML page</a></h2>
<p>Let's start by creating a simple HTML UI. This page won't connect to Linera yet,
but we can use it as scaffolding to get our development environment set up.
We'll call this page <code>index.html</code>, and it will be the only file we need to edit
to build our frontend.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;Counter&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Chain: &lt;span id="chain-id"&gt;requesting chain…&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Clicks: &lt;span id="count"&gt;0&lt;/span&gt;&lt;/p&gt;
    &lt;button id="increment"&gt;Click me!&lt;/button&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
<h2 id="serving-your-frontend"><a class="header" href="#serving-your-frontend">Serving your frontend</a></h2>
<p>In order to use the JavaScript client API, we will need a Web server. Since we
use a
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer"><code>SharedArrayBuffer</code></a>
to share memory between WebAssembly threads, running your frontend from disk
using a <code>file://</code> URI will not work, as <code>SharedArrayBuffer</code> requires
<a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/crossOriginIsolated">cross-origin isolation</a>
for security.</p>
<p>In this tutorial we'll be using
<a href="https://github.com/http-party/http-server"><code>http-server</code></a>, but any server will
do so long as it can set the <code>Cross-Origin-Opener-Policy</code> and
<code>Cross-Origin-Embedder-Policy</code> headers.</p>
<p>To use <code>http-server</code>, first ensure you have Node.js installed. On Ubuntu, this
can be accomplished with:</p>
<pre><code class="language-shellsession">sudo apt install nodejs
</code></pre>
<p>Then, the command</p>
<pre><code class="language-shellsession">npx http-party/http-server \
  --header Cross-Origin-Embedder-Policy:require-corp \
  --header Cross-Origin-Opener-Policy:same-origin
</code></pre>
<p>can be used to serve our HTML page on <code>localhost</code>.</p>
<div id="admonition-info" class="admonition admonish-info" role="note" aria-labelledby="admonition-info-title">
<div class="admonition-title">
<div id="admonition-info-title">
<p>Info</p>
</div>
<a class="admonition-anchor-link" href="developers/frontend/setup.html#admonition-info"></a>
</div>
<div>
<p>Note that we use <code>http-party/http-server</code> here to use <code>http-server</code>
from GitHub.  Writing just <code>http-server</code> will pull the version from
npm, which at the time of writing is very old and doesn't support
custom headers.</p>
</div>
</div>
<h2 id="getting-the-client-library"><a class="header" href="#getting-the-client-library">Getting the client library</a></h2>
<p>The entire Linera client, WebAssembly and all, is published to the Node package
repository as <a href="https://www.npmjs.com/package/@linera/client"><code>@linera/client</code></a>.
We'll include it into our <code>node_modules</code> with:</p>
<pre><code class="language-shellsession">npm install @linera/client@0.15.3
</code></pre>
<div id="admonition-a-note-on-bundlers" class="admonition admonish-warning" role="note" aria-labelledby="admonition-a-note-on-bundlers-title">
<div class="admonition-title">
<div id="admonition-a-note-on-bundlers-title">
<p>A note on bundlers</p>
</div>
<a class="admonition-anchor-link" href="developers/frontend/setup.html#admonition-a-note-on-bundlers"></a>
</div>
<div>
<p>We're serving our <code>node_modules</code> here, so no bundling step is
required.  However, if you do choose to bundle your frontend, it is
important that both the Web worker entry point and the
<code>@linera/client</code> library itself remain in separate files, with their
signatures intact, in order for the Web worker to be able to refer to
them.  For example, if using Vite, make sure to define an extra
entrypoint for <code>@linera/client</code>, preserve its signature, and exclude
it from dependency optimization:</p>
<pre><code class="language-typescript">export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        index: 'index.html',
        linera: '@linera/client',
      },
      preserveEntrySignatures: 'strict',
    },
  },
  optimizeDeps: {
    exclude: [
      '@linera/client',
    ],
  },
})
</code></pre>
</div>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="interacting-with-linera"><a class="header" href="#interacting-with-linera">Interacting with Linera</a></h1>
<p>Add a <code>&lt;script type="module"&gt;</code> to your page. The location of this module doesn't
matter: module scripts are deferred until after page load. This is where we will
write all the JavaScript necessary to interact with Linera.</p>
<h2 id="importing-the-linera-client-library"><a class="header" href="#importing-the-linera-client-library">Importing the Linera client library</a></h2>
<p>To add the Linera client library to your page, put the following import map into
the <code>&lt;head&gt;</code> of your HTML:</p>
<pre><code class="language-html">&lt;script type="importmap"&gt;
  {
    "imports": {
      "@linera/client": "./node_modules/@linera/client/dist/linera_web.js"
    }
  }
&lt;/script&gt;
</code></pre>
<p>Now the module <code>@linera/client</code> is available for import in your module:</p>
<pre><code class="language-html">&lt;script type="module"&gt;
  import * as linera from '@linera/client';
&lt;/script&gt;
</code></pre>
<h2 id="referring-to-the-counter-app"><a class="header" href="#referring-to-the-counter-app">Referring to the counter app</a></h2>
<p>We'll need the application ID of the counter app deployed on our network of
choice. This tutorial uses Testnet, and the following application ID refers to a
counter app published there:</p>
<pre><code class="language-javascript">const COUNTER_APP_ID =
  '2b1a0df8868206a4b7d6c2fdda911e4355d6c0115b896d4947ef8e535ee3c6b8';
</code></pre>
<p>If you wish to use a different network or deploy your own backend, you may need
to change the application ID. So long as it points to an application satisfying
the counter ABI, the rest of this tutorial will work without modification.</p>
<h2 id="initialization"><a class="header" href="#initialization">Initialization</a></h2>
<p>The first thing we need to do to interact with the Linera client library is
initialize it. This will download the WebAssembly binary, create a new memory
for it, and initialize the memory.</p>
<pre><code class="language-javascript">await linera.default();
</code></pre>
<h2 id="getting-a-wallet"><a class="header" href="#getting-a-wallet">Getting a wallet</a></h2>
<p>If you have a wallet file available, you can use the <code>linera.Wallet.fromJson</code>
function to create a <code>linera.Wallet</code> from it. However, for the purposes of the
tutorial, we will connect to the Testnet faucet and create a new wallet with a
fresh chain owning some tokens. We will also update our <code>#chain-id</code> element to
let the user know the ID of their new chain.</p>
<pre><code class="language-javascript">const faucet = await new linera.Faucet(
  'https://faucet.testnet-conway.linera.net',
);
const wallet = await faucet.createWallet();
const client = await new linera.Client(wallet);
document.getElementById('chain-id').innerText = await faucet.claimChain(client);
</code></pre>
<h2 id="communicating-with-the-application"><a class="header" href="#communicating-with-the-application">Communicating with the application</a></h2>
<p>Calling the method <code>client.application(applicationId)</code> will get you an object
representing the application backend.</p>
<pre><code class="language-javascript">const backend = await client.frontend().application(COUNTER_APP_ID);
</code></pre>
<p>You can query the backend application using the <code>query</code> method, which takes an
arbitrary string that will be passed to the backend as a request, and returns a
<code>Promise</code> of the response. We can use this to update our <code>#count</code> element with
the current value of the counter.</p>
<pre><code class="language-javascript">async function updateCount() {
  const response = await backend.query('{ "query": "query { value }" }');
  document.getElementById('count').innerText = JSON.parse(response).data.value;
}

updateCount();
</code></pre>
<p>The counter application uses GraphQL as its request language. By convention,
Linera applications accept GraphQL as strings of JSON in the
<a href="https://www.apollographql.com/docs/apollo-server/v2/requests">Apollo Server POST format</a>,
but your application is free to accept whatever format it wants.</p>
<p>GraphQL <code>query</code> operations can be used to inspect the state of the application,
while <code>mutation</code> operations cause the client to propose new blocks with the
result of the requested modification. Let's attach an event handler to our
button that proposes an increment to the counter value.</p>
<pre><code class="language-javascript">document.getElementById('increment').addEventListener('click', () =&gt; {
  backend.query('{ "query": "mutation { increment(value: 1) }" }');
});
</code></pre>
<h2 id="notifications-and-reactivity"><a class="header" href="#notifications-and-reactivity">Notifications and reactivity</a></h2>
<p>If you click the button, the value of the counter will go up, but the UI element
currently won't change to reflect it. Let's fix that.</p>
<p>The <code>Client</code> object also supports adding a callback for notifications. This is
key to Linera's reactivity: if something happens to one of a client's chains,
this callback will immediately be called with a notification object containing
information about the event.</p>
<p>In this case the only updates we're interested in are new blocks, which imply
that the counter value has changed, so whenever we see a new block let's update
the counter.</p>
<pre><code class="language-javascript">client.onNotification(notification =&gt; {
  if (notification.reason.NewBlock) updateCount();
});
</code></pre>
<p>We're the sole owner of this chain, so the value query is purely local: nobody
could have updated the chain state but us. In the general case, though, other
users on other clients could update the chain with new blocks or by sending it
messages, and we'd get immediately notified in just the same way.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>That's it! In a few lines of code we've implemented an application frontend that
communicates with the Linera testnet and allows bidirectional communication with
an application, including realtime updates when the chain state changes.</p>
<p>A somewhat fleshed-out version of the code from this tutorial can be found in
the <code>examples/hosted-counter</code> subdirectory of the
<a href="https://github.com/linera-io/linera-web"><code>linera-web</code> repository</a>, next to some
more complicated examples. Alternatively, you can
<a href="https://demos.linera.net/hosted/counter">try it out online</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="connecting-with-external-wallet-providers"><a class="header" href="#connecting-with-external-wallet-providers">Connecting with external wallet providers</a></h2>
<p>The Linera client library allows you to sign transactions with anything that
satisfies
<a href="https://github.com/linera-io/linera-protocol/blob/testnet_conway/linera-web/docs/interfaces/Signer.md">the <code>Signer</code> interface</a>.
This means you can integrate with external software wallets, hardware wallets,
Internet-connected wallet services… the only limit is your imagination!</p>
<p>To get started building your own signer implementation, have a look at
<a href="https://github.com/linera-io/linera-protocol/blob/testnet_conway/linera-web/signer/src/private-key.ts">our sample in-memory implementation</a>.
Alternatively, you can use a pre-built wallet integration provided by Linera or
our partners.</p>
<h3 id="metamask"><a class="header" href="#metamask">MetaMask</a></h3>
<p>MetaMask is the most popular crypto wallet on the Web today. Though oriented
primarily at Ethereum, it's flexible enough to allow signing other types of data
too.</p>
<p>We provide an implementation using MetaMask's blind-signing capabilities to sign
Linera transactions in the
<a href="https://www.npmjs.com/package/@linera/signer"><code>@linera/signer</code></a> package on npm.
Our counter demo also sports a
<a href="https://github.com/linera-io/linera-protocol/tree/testnet_conway/examples/counter/metamask">MetaMask-based frontend</a>
that exemplifies signing application transactions with MetaMask.</p>
<h3 id="dynamic"><a class="header" href="#dynamic">Dynamic</a></h3>
<p><a href="https://dynamic.xyz">Dynamic</a> provide a production-quality embedded wallet that
is fully compatible with Linera, and can be used to sign in securely using a
wide range of Web2 and Web3 identity providers.</p>
<p>Dynamic have made available both a
<a href="https://www.dynamic.xyz/docs/guides/chains/linera">recipe for Linera integration</a>
and a
<a href="https://github.com/dynamic-labs/examples/tree/main/examples/vite-linera-counter">fully-featured frontend</a>,
based on the counter demo developed in this manual, that uses Dynamic to sign
transactions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>In this section, we present additional topics related to the Linera protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-finalization"><a class="header" href="#contract-finalization">Contract Finalization</a></h1>
<p>When a transaction finishes executing successfully, there's a final step where
all loaded application contracts have their <code>Contract::store</code> implementation
called. This can be seen to be similar to executing a destructor. In that sense,
applications may want to perform some final operations after execution finished.
While finalizing, contracts may send messages, read and write to the state, but
are not allowed to call other applications, because they are all also in the
process of finalizing.</p>
<p>While finalizing, contracts can force the transaction to fail by panicking. The
block is then rejected, even if the entire transaction's operation had succeeded
before the application's <code>Contract::store</code> was called. This allows a contract to
reject transactions if other applications don't follow any required constraints
it establishes after it responds to a cross-application call.</p>
<p>As an example, a contract that executes a cross-application call with
<code>Operation::StartSession</code> may require the same caller to perform another
cross-application call with <code>Operation::EndSession</code> before the transaction ends.</p>
<pre><code class="language-rust edition2021"><span class="boring">extern crate serde;
</span><span class="boring">extern crate linera_sdk;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use linera_sdk::linera_base_types::*;
</span><span class="boring">use linera_sdk::*;
</span><span class="boring">use linera_sdk::abi::*;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">use linera_sdk::views::{linera_views, RegisterView, RootView, ViewStorageContext};
</span><span class="boring">use crate::linera_sdk::views::View as _;
</span><span class="boring">use linera_sdk::linera_base_types::ApplicationId;
</span>
#[derive(RootView)]
#[view(context = ViewStorageContext)]
pub struct MyState {
    pub value: RegisterView&lt;u64&gt;,
    // ...
}

#[derive(Serialize, Deserialize, Debug)]
pub enum Operation { StartSession, EndSession }

pub struct MyAbi;

impl ContractAbi for MyAbi {
    type Operation = Operation;
    type Response = ();
}

pub struct MyContract {
    state: MyState,
    runtime: ContractRuntime&lt;Self&gt;,
    active_sessions: HashSet&lt;ApplicationId&gt;,
}

impl WithContractAbi for MyContract {
    type Abi = MyAbi;
}

impl Contract for MyContract {
    type Message = ();
    type InstantiationArgument = ();
    type Parameters = ();
    type EventValue = ();

    async fn load(runtime: ContractRuntime&lt;Self&gt;) -&gt; Self {
        let state = MyState::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");

        MyContract {
            state,
            runtime,
            active_sessions: HashSet::new(),
        }
    }

    async fn instantiate(&amp;mut self, (): Self::InstantiationArgument) {}

    async fn execute_operation(&amp;mut self, operation: Self::Operation) -&gt; Self::Response {
        let caller_id = self.runtime
            .authenticated_caller_id()
            .expect("Missing caller ID");

        match operation {
            Operation::StartSession =&gt; {
                assert!(
                    self.active_sessions.insert(caller_id),
                    "Can't start more than one session for the same caller"
                );
            }
            Operation::EndSession =&gt; {
                assert!(
                    self.active_sessions.remove(&amp;caller_id),
                    "Session was not started"
                );
            }
        }
    }

    async fn execute_message(&amp;mut self, message: Self::Message) {
        unreachable!("This example doesn't support messages");
    }

    async fn store(mut self) {
        assert!(
            self.active_sessions.is_empty(),
            "Some sessions have not ended"
        );

        self.state.save().await.expect("Failed to save state");
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validators"><a class="header" href="#validators">Validators</a></h1>
<p>Validators run the servers that allow users to download and create blocks. They
validate, execute and cryptographically certify the blocks of all the chains.</p>
<blockquote>
<p>In Linera, every chain is backed by the same set of validators and has the
same level of security.</p>
</blockquote>
<p>The main function of validators is to guarantee the integrity of the
infrastructure in the sense that:</p>
<ul>
<li>
<p>Each block is valid, i.e. it has the correct format, its operations are
allowed, the received messages are in the correct order, and e.g. the balance
was correctly computed.</p>
</li>
<li>
<p>Every message received by one chain was actually sent by another chain.</p>
</li>
<li>
<p>If one block on a particular height is certified, no other block on the same
height is.</p>
</li>
</ul>
<p>These properties are guaranteed to hold as long as two thirds of the validators
(weighted by their stake) follow the protocol. In the future, deviating from the
protocol may cause a validator to be considered malicious and to lose their
<em>stake</em>.</p>
<p>Validators also play a role in the liveness of the system by making sure that
the history of the chains stays available. However, since validators do not
propose blocks on most chains (see <a href="developers/advanced_topics/block_creation.html">next section</a>), they do
<em>not</em> guarantee that any particular operation or message will eventually be
executed on a chain. Instead, chain owners decide whether and when to propose
new blocks, and which operations and messages to include. The current
implementation of the Linera client automatically includes all incoming messages
in new blocks. The operations are the actions the chain owner explicitly adds,
e.g. transfer.</p>
<h2 id="architecture-of-a-validator"><a class="header" href="#architecture-of-a-validator">Architecture of a validator</a></h2>
<p>Since every chain uses the same validators, adding more chains does not require
adding validators. Instead, it requires each individual validator to scale out
by adding more computation units, also known as "workers" or "physical shards".</p>
<p>In the end, a Linera validator resembles a Web2 service made of</p>
<ul>
<li>
<p>a load balancer (aka. ingress/egress), currently implemented by the binary
<code>linera-proxy</code>,</p>
</li>
<li>
<p>a number of workers, currently implemented by the binary <code>linera-server</code>,</p>
</li>
<li>
<p>a shared database, currently implemented by the abstract interface
<code>linera-storage</code>.</p>
</li>
</ul>
<pre><code class="language-ignore">Example of Linera network

                    │                                             │
                    │                                             │
┌───────────────────┼───────────────────┐     ┌───────────────────┼───────────────────┐
│ validator 1       │                   │     │ validator N       │                   │
│             ┌─────┴─────┐             │     │             ┌─────┴─────┐             │
│             │   load    │             │     │             │   load    │             │
│       ┌─────┤  balancer ├────┐        │     │       ┌─────┤  balancer ├──────┐      │
│       │     └───────────┘    │        │     │       │     └─────┬─────┘      │      │
│       │                      │        │     │       │           │            │      │
│       │                      │        │     │       │           │            │      │
│  ┌────┴─────┐           ┌────┴─────┐  │     │  ┌────┴───┐  ┌────┴────┐  ┌────┴───┐  │
│  │  worker  ├───────────┤  worker  │  │ ... │  │ worker ├──┤  worker ├──┤ worker │  │
│  │    1     │           │    2     │  │     │  │    1   │  │    2    │  │    3   │  │
│  └────┬─────┘           └────┬─────┘  │     │  └────┬───┘  └────┬────┘  └────┬───┘  │
│       │                      │        │     │       │           │            │      │
│       │                      │        │     │       │           │            │      │
│       │     ┌───────────┐    │        │     │       │     ┌─────┴─────┐      │      │
│       └─────┤  shared   ├────┘        │     │       └─────┤  shared   ├──────┘      │
│             │ database  │             │     │             │ database  │             │
│             └───────────┘             │     │             └───────────┘             │
└───────────────────────────────────────┘     └───────────────────────────────────────┘

</code></pre>
<p>Inside a validator, components communicate using the internal network of the
validator. Notably, workers use direct Remote Procedure Calls (RPCs) with each
other to deliver cross-chain messages.</p>
<p>Note that the number of workers may vary for each validator. Both the load
balancer and the shared database are represented as a single entity but are
meant to scale out in production.</p>
<blockquote>
<p>For local testing during development, we currently use a single worker and a
testing in-memory service as a shared database.</p>
</blockquote>
<!--
## Configuring Networks, Workers, and Proxies

In [a previous section](../getting_started/hello_linera.md), we used the
`linera net up` command to start a local network. This should be sufficient for
most use cases when you're running a local network.

```bash
linera net up
```

However, it is possible to customize and configure the parameters of the
network.

To do this, you need the `linera-protocol` repository and the
`./scripts/run_local.sh` script.

`run_local.sh` uses the `validator_n.toml` file from the `configuration/`
directory to configure validator number `n`.

```bash
linera-server generate --validators configuration/validator_{1,2,3,4}.toml --committee committee.json
```

generates keys and writes them, together with the options from the TOML files,
to `server_1.json`, ..., `server_4.json`. It also stores the set of the new
validators' public keys in `committee.json`.

```bash
linera --wallet wallet.json --storage rocksdb:linera.db create-genesis-config 10 --genesis genesis.json --initial-funding 10 --committee committee.json
```

creates a configuration for the initial state of the network, `genesis.json`,
with 10 chains, each with a balance of 10. It also creates a `wallet.json` for a
client who owns all those chains and initializes the corresponding local node
`linera.db`.

To start the newly configured network, each validator `n` must start their
proxy:

```bash
linera-proxy server_n.json &
```

And all shards; for shard `i`:

```bash
linera-server run --storage rocksdb:server_n_i.db --server server_n.json --shard i --genesis genesis.json &
```

This will create a separate database file `server_n_i.db` for each shard. In a
production network, these would be running on different machines.

## Changing the Set of Validators

If a new validator wants to start participating, or an old one wants to leave,
all chains must be updated.

The system has one designated _admin chain_, where the validators can join or
leave, and where new _epochs_ are defined. During every epoch, the set of
validators is fixed. If you own the admin chain, you can use the `set-validator`
and `remove-validator` commands to start a new epoch with a modified set of
validators:

```bash
linera --wallet wallet.json set-validator --name 5b611b86cc1f54f73a4abfb4a2167c7327cc85a74cb2a5502431f67b554850b4 --address 127.0.0.1:9100 --votes 3
linera --wallet wallet.json remove-validator --name f65a585f05852f0610e2460a99c23faa3969f3cfce8a519f843a793dbfb4cb84
```

Chain owners must then create a block that receives the `SetCommittees` message
from the admin chain, and have it certified by the old validators. Only the
_next_ block in their chain will be certified by the new validator set!

The _admin chain_ is currently managed by a single user. In the future, it will
be a _public chain_ (i.e. managed by validators). We anticipate that Linera
epochs will change once per day (or less) and that several subsequent epochs
will overlap so that chain owners have enough time to migrate their chains.
(Chain migration may also be delegated to third parties. See
[next section](block_creation.html).)

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-new-blocks"><a class="header" href="#creating-new-blocks">Creating New Blocks</a></h1>
<blockquote>
<p>In Linera, the responsibility of proposing blocks is separate from the task of
validating blocks.</p>
</blockquote>
<p>While all chains are validated in the same way, the Linera protocol defines
several types of chains, depending on how new blocks are produced.</p>
<ul>
<li>
<p>The simplest and lowest-latency type of chain is called <em>single-owner</em> chain.</p>
</li>
<li>
<p>Other types of Linera chains not currently supported in the SDK include
<em>multi-user chains</em> and <em>public chains</em> (see the
<a href="https://linera.io/whitepaper">whitepaper</a> for more context).</p>
</li>
</ul>
<blockquote>
<p>For most types of chains (all but <em>public chains</em>), Linera validators do not
need to exchange messages with each other.</p>
</blockquote>
<p>Instead, the wallets (aka. <code>linera</code> clients) of chain owners make the system
progress by proposing blocks and actively providing any additional required data
to the validators. For instance, client commands such as <code>transfer</code>,
<code>publish-module</code>, or <code>open-chain</code> perform multiple steps to append a block
containing the token transfer, application publishing, or chain creation
operation:</p>
<ul>
<li>
<p>The Linera client creates a new block containing the desired operation and new
incoming messages, if there are any. It also contains the most recent block's
hash to designate its parent. The client sends the new block to all
validators.</p>
</li>
<li>
<p>The validators validate the block, i.e. check that the block satisfies the
conditions listed above, and send a cryptographic signature to the client,
indicating that they vote to append the new block. But only if they have not
voted for a different block on the same height earlier!</p>
</li>
<li>
<p>The client ideally receives a vote from every validator, but only a quorum of
votes (say, two thirds) are required: These constitute a "certificate",
proving that the block was confirmed. The client sends the certificate to
every validator.</p>
</li>
<li>
<p>The validators "execute" the block: They update their own view of the most
recent state of the chain by applying all messages and operations, and if it
generated any cross-chain messages, they send these to the appropriate
workers.</p>
</li>
</ul>
<p>To guarantee that each incoming message in a block was actually sent by another
chain, a validator will, in the second step, only <em>vote</em> for a block if it has
already executed the block that sent it. However, when receiving a valid
certificate for a block that receives a message it has not seen yet, it will
accept and <em>execute</em> the block anyway. The certificate is proof that most other
validators have seen the message, so it must be correct.</p>
<p>In the case of single-owner chains, clients must be carefully implemented so
that they never propose multiple blocks at the same height. Otherwise, the chain
may be stuck: once each of the two conflicting blocks has been signed by enough
validators, it becomes impossible to collect a quorum of votes for either block.</p>
<p>In the future, we anticipate that most users will use <em>multi-user chains</em> even
if they are the only owners of their chains. Multi-user chains have two
confirmation steps instead of one, but it is not possible to accidentally make a
chain unextendable. They also allow users to delegate certain administrative
tasks to third-parties, notably to help with epoch changes (i.e. when the
validators change if reconfigured).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications-that-handle-assets"><a class="header" href="#applications-that-handle-assets">Applications that Handle Assets</a></h1>
<p>In general, if you send tokens to a chain owned by someone else, you rely on
them for asset availability: if they don't handle your messages, you don't have
access to your tokens.</p>
<p>Fortunately, Linera provides a solution based on temporary chains: if the number
of parties who want to participate is limited and known in advance, we can:</p>
<ul>
<li>make them all chain owners using the <code>linera change-ownership</code> command,</li>
<li>allow only one application's operations on the chain,</li>
<li>and allow only that operation to close the chain, using
<code>linera change-application-permissions</code>.</li>
</ul>
<p>Such an application should have a designated operation or message that causes it
to close the chain: when that operation is executed, it should send back all
remaining assets, and call the runtime's <code>close_chain</code> method.</p>
<p>Once the chain is closed, owners can still create blocks to reject messages.
That way, even assets that are in flight can be returned.</p>
<p>The
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/matching-engine"><code>matching-engine</code> example application</a>
does this:</p>
<pre><code class="language-rust ignore">    async fn execute_operation(&amp;mut self, operation: Operation) -&gt; Self::Response {
        match operation {
            // ...
            Operation::CloseChain =&gt; {
                for order_id in self.state.orders.indices().await.unwrap() {
                    match self.modify_order(order_id, ModifyAmount::All).await {
                        Some(transfer) =&gt; self.send_to(transfer),
                        // Orders with amount zero may have been cleared in an earlier iteration.
                        None =&gt; continue,
                    }
                }
                self.runtime
                    .close_chain()
                    .expect("The application does not have permissions to close the chain.");
            }
        }
    }</code></pre>
<p>This enables doing atomic swaps using the Matching Engine: if you make a bid,
you are guaranteed that at any point in time you can get back either the tokens
you are offering or the tokens you bought.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experimental-topics"><a class="header" href="#experimental-topics">Experimental Topics</a></h1>
<p>In this section, we present some experimental features of the Linera protocol.</p>
<p>Experimental features are generally not available on the Linera testnet. You may
have to compile Linera from sources from the <code>main</code> branch of
<a href="https://github.com/linera-io/linera-protocol">the repository</a>, then run a
<a href="developers/getting_started/hello_linera.html#using-a-local-test-network">local test network</a>.</p>
<p>You may also need to select specific Cargo features during compilation using
<code>--features</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="machine-learning-on-linera"><a class="header" href="#machine-learning-on-linera">Machine Learning on Linera</a></h1>
<p>The Linera application contract / service split allows for securely and
efficiently running machine learning models on the edge.</p>
<p>The application's contract retrieves the correct model with all the correctness
guarantees enforced by the consensus algorithm, while the client performs
inference off-chain, in the un-metered service. Since the service is running on
the user's own hardware, it can be implicitly trusted.</p>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<p>The existing examples use the <a href="https://github.com/huggingface/candle"><code>candle</code></a>
framework by <a href="https://huggingface.co/">Hugging Face</a> as the underlying ML
framework.</p>
<p><code>candle</code> is a minimalist ML framework for Rust with a focus on performance and
usability. It also compiles to Wasm and has great support for Wasm both in and
outside the browser. Check candle's
<a href="https://github.com/huggingface/candle/tree/main/candle-wasm-examples">examples</a>
for inspiration on the types of models which are supported.</p>
<h3 id="getting-started-1"><a class="header" href="#getting-started-1">Getting started</a></h3>
<p>To add ML capabilities to your existing Linera project, you'll need to add the
<code>candle-core</code>, <code>getrandom</code>, <code>rand</code> and <code>tokenizers</code> dependencies to your Linera
project:</p>
<pre><code class="language-toml">candle-core = "0.4.1"
getrandom = { version = "0.2.12", default-features = false, features = ["custom"] }
rand = "0.8.5"
</code></pre>
<p>Optionally, to run Large Language Models, you'll also need the
<code>candle-transformers</code> and <code>transformers</code> crate:</p>
<pre><code class="language-toml">candle-transformers = "0.4.1"
tokenizers = { git = "https://github.com/christos-h/tokenizers", default-features = false, features = ["unstable_wasm"] }
</code></pre>
<h3 id="providing-randomness"><a class="header" href="#providing-randomness">Providing randomness</a></h3>
<p>ML frameworks use random numbers to perform inference. Linera services run in a
Wasm VM which does not have access to the OS Rng. For this reason, we need to
manually seed RNG used by <code>candle</code>. We do this by writing a custom <code>getrandom</code>.</p>
<p>Create a file under <code>src/random.rs</code> and add the following:</p>
<pre><code class="language-rust ignore">use std::sync::{Mutex, OnceLock};

use rand::{rngs::StdRng, Rng, SeedableRng};

static RNG: OnceLock&lt;Mutex&lt;StdRng&gt;&gt; = OnceLock::new();

fn custom_getrandom(buf: &amp;mut [u8]) -&gt; Result&lt;(), getrandom::Error&gt; {
    let seed = [0u8; 32];
    RNG.get_or_init(|| Mutex::new(StdRng::from_seed(seed)))
        .lock()
        .expect("failed to get RNG lock")
        .fill(buf);
    Ok(())
}

getrandom::register_custom_getrandom!(custom_getrandom);</code></pre>
<p>This will enable <code>candle</code> and any other crates which rely on <code>getrandom</code> access
to a deterministic RNG. If deterministic behaviour is not desired, the System
API can be used to seed the RNG from a timestamp.</p>
<h3 id="loading-the-model-into-the-service"><a class="header" href="#loading-the-model-into-the-service">Loading the model into the service</a></h3>
<p>Models cannot currently be saved on-chain; for more information see the
<code>Limitations</code> below.</p>
<p>To perform model inference, the model must be loaded into the service. To do
this we'll use the <code>fetch_url</code> API when a query is made against the service:</p>
<pre><code class="language-rust ignore">impl Service for MyService {
    async fn handle_query(&amp;self, request: Request) -&gt; Response {
        // do some stuff here
        let raw_weights = self.runtime.fetch_url("https://my-model-provider.com/model.bin");
        // do more stuff here
    }
}</code></pre>
<p>This can be served from a local webserver or pulled directly from a model
provider such as Hugging Face.</p>
<p>At this point we have the raw bytes which correspond to the models and
tokenizer. <code>candle</code> supports multiple formats for storing model weights, both
quantized and not (<code>gguf</code>, <code>ggml</code>, <code>safetensors</code>, etc.).</p>
<p>Depending on the model format that you're using, <code>candle</code> exposes convenience
functions to convert the bytes into a typed <code>struct</code> which can then be used to
perform inference. Below is an example for a non-quantized Llama 2 model:</p>
<pre><code class="language-rust ignore">    fn load_llama_model(cursor: &amp;mut Cursor&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;(Llama, Cache), candle_core::Error&gt; {
        let config = llama2_c::Config::from_reader(cursor)?;
        let weights =
            llama2_c_weights::TransformerWeights::from_reader(cursor, &amp;config, &amp;Device::Cpu)?;
        let vb = weights.var_builder(&amp;config, &amp;Device::Cpu)?;
        let cache = llama2_c::Cache::new(true, &amp;config, vb.pp("rot"))?;
        let llama = Llama::load(vb, config.clone())?;
        Ok((llama, cache))
    }</code></pre>
<h3 id="inference"><a class="header" href="#inference">Inference</a></h3>
<p>Performing inference using <code>candle</code> is not a 'one-size-fits-all' process.
Different models require different logic to perform inference so the specifics
of how to perform inference are beyond the scope of this document.</p>
<p>Luckily, there are multiple examples which can be used as guidelines on how to
perform inference in Wasm:</p>
<ul>
<li><a href="https://github.com/linera-io/linera-protocol/tree/main/examples/llm">Llm Stories</a></li>
<li><a href="https://github.com/linera-io/linera-protocol/tree/main/examples/gen-nft">Generative NFTs</a></li>
<li><a href="https://github.com/huggingface/candle/tree/main/candle-wasm-examples">Candle Wasm Examples</a></li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="hardware-acceleration"><a class="header" href="#hardware-acceleration">Hardware acceleration</a></h3>
<p>Although SIMD instructions <em>are</em> supported by the service runtime, general
purpose GPU hardware acceleration is
<a href="https://github.com/linera-io/linera-protocol/issues/1931">not currently supported</a>.
Therefore, performance in local model inference is degraded for larger models.</p>
<h3 id="on-chain-models"><a class="header" href="#on-chain-models">On-chain models</a></h3>
<p>Due to block-size constraints, models need to be stored off-chain until the
introduction of the
<a href="https://github.com/linera-io/linera-protocol/issues/1981">Blob API</a>. The Blob
API will enable large binary blobs to be stored on-chain, the correctness and
availability of which is guaranteed by the validators.</p>
<h3 id="maximum-model-size"><a class="header" href="#maximum-model-size">Maximum model size</a></h3>
<p>The maximum size of a model which can be loaded into an application's service is
currently constrained by:</p>
<ol>
<li>The addressable memory of the service's Wasm runtime being 4 GiB.</li>
<li>Not being able to load models directly to the GPU.</li>
</ol>
<p>It is recommended that smaller models (50 MB - 100 MB) are used at current state
of development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-evm-smart-contracts-on-linera"><a class="header" href="#using-evm-smart-contracts-on-linera">Using EVM Smart Contracts on Linera</a></h1>
<p>Thanks to the experimental integration of
<a href="https://bluealloy.github.io/revm/"><code>Revm</code></a> in Linera, it is now possible to run
smart contracts compiled for the Ethereum Virtual Machine (EVM) within Linera
microchains.</p>
<p>The main purpose of this integration is to allow opensource smart contracts
originally written for Ethereum to be more easily migrated to the Linera
protocol and composed with existing Linera applications.</p>
<h2 id="overview-and-code-examples"><a class="header" href="#overview-and-code-examples">Overview and code examples</a></h2>
<p>We generally assume that EVM smart contracts are written in
<a href="https://soliditylang.org/">Solidity</a> and compiled to EVM bytecode using the
Solidity compiler.</p>
<p>Transactions running on the EVM are still following the programming model of the
Linera protocol, notably they can only access the local state of the microchain
that executes them. Inside a microchain, contracts may call each other as usual,
possibly across virtual machines.</p>
<p>The main features of Linera, such as cross-chain messaging, are also supported
in the EVM. These functionalities are exposed through a Solidity library
<a href="https://github.com/linera-io/linera-protocol/tree/main/linera-execution/solidity/Linera.sol"><code>Linera.sol</code></a>.</p>
<p>Frontends may interact with EVM contracts using custom EVM-like RPCs or using a
Rust/Wasm application as a proxy.</p>
<p>Code examples for the features described below can be found under the directory
<a href="https://github.com/linera-io/linera-protocol/tree/main/linera-service/tests/fixtures"><code>linera-service/tests/fixtures</code></a>.</p>
<h2 id="publishing-evm-smart-contracts"><a class="header" href="#publishing-evm-smart-contracts">Publishing EVM smart contracts</a></h2>
<p>The process for publishing EVM smart contracts is similar to that for Wasm smart
contracts, with the key difference being the need to specify the virtual machine
used (the default is Wasm).</p>
<p>For EVM contracts, there is only one bytecode file (unlike Wasm, which requires
separate <code>contract</code> and <code>service</code> binaries). Therefore, the same file must be
passed twice:</p>
<pre><code class="language-bash">linera publish-and-create \
  counter.bytecode counter.bytecode \
  --vm-runtime evm \
  --json-parameters "42"
</code></pre>
<p>Here, <code>counter.bytecode</code> contains the compiled contract, and "42" is passed as a
constructor argument via the <code>--json-parameters</code> flag.</p>
<p>Constructor arguments for the EVM contract are passed through application
parameters. Instantiation-specific arguments are provided separately.</p>
<h2 id="calling-other-smart-contracts"><a class="header" href="#calling-other-smart-contracts">Calling other smart contracts.</a></h2>
<p>EVM smart contracts on Linera can invoke other EVM contracts using standard
Solidity syntax.</p>
<h3 id="evm-contracts-calling-wasm-smart-contracts"><a class="header" href="#evm-contracts-calling-wasm-smart-contracts">EVM Contracts calling Wasm smart contracts.</a></h3>
<p>To call a Wasm smart contract from an EVM contract, use the following Solidity
command:</p>
<pre><code class="language-solidity">	bytes memory return_value = Linera.try_call_application(address, input);
</code></pre>
<ul>
<li><code>address</code>: the address of the Wasm smart contract, as a <code>bytes32</code>.</li>
<li><code>input</code>: the bytes representing the BCS-serialized <code>ContractAbi::Operation</code>
input.</li>
</ul>
<p>The serialization code can be generated using the <code>serde-reflection</code> crate.</p>
<h3 id="wasm-smart-contracts-calling-evm-contracts"><a class="header" href="#wasm-smart-contracts-calling-evm-contracts">Wasm smart contracts calling EVM Contracts.</a></h3>
<p>Wasm smart contracts can call EVM contracts using the <code>alloy-sol-types</code> crate.
This crate enables construction of Solidity-compatible types and supports RLP
serialization/deserialization.</p>
<p>The Wasm contract call-evm-counter demonstrates this functionality.</p>
<ul>
<li>
<p>For operations, the input type is <code>Vec&lt;u8&gt;</code>.</p>
</li>
<li>
<p>For service calls, the input type is <code>EvmQuery</code>.</p>
</li>
</ul>
<p>Note: Linera distinguishes between contract and service code execution contexts.</p>
<h2 id="multichain-evm-applications"><a class="header" href="#multichain-evm-applications">Multichain EVM applications.</a></h2>
<p>To operate across multiple chains, an EVM application must implement the
following functions:</p>
<pre><code class="language-solidity">    function instantiate(bytes memory input) external
    function execute_message(bytes memory input) external
</code></pre>
<ul>
<li>
<p><code>instantiate</code> is called on the creator chain.</p>
</li>
<li>
<p><code>execute_message</code> handles incoming cross-chain messages.</p>
</li>
</ul>
<p>Additional SDK functions available include:</p>
<pre><code class="language-solidity">    Linera.chain_ownership()
    Linera.read_data_blob()
    Linera.assert_data_blob_exists()
    Linera.validation_round()
    Linera.message_id()
    Linera.message_is_bouncing()
</code></pre>
<h2 id="difference-between-evm-applications-in-ethereum-and-linera"><a class="header" href="#difference-between-evm-applications-in-ethereum-and-linera">Difference between EVM applications in Ethereum and Linera.</a></h2>
<ul>
<li>
<p><code>Reentrancy</code>: Reentrancy is currently not supported on Linera. Contracts
relying on it will fail with a clean error. In the future, reentrancy may be
allowed as an option.</p>
</li>
<li>
<p><code>Address Computation</code>: Contract addresses are computed differently from
Ethereum.</p>
</li>
<li>
<p><code>Gas Limits</code>: Following Infura's practice, Linera imposes a gas limit of
20,000,000 for service calls in EVM contracts. Contract execution is similarly
constrained.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devnets"><a class="header" href="#devnets">Devnets</a></h1>
<p>This section discusses how to deploy developer networks, aka "Devnets", for
testing and development purposes.</p>
<p>Devnets always start from a genesis configuration and an empty state. Validator
nodes are run by the core Linera team. Devnets do not handle real assets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-devnets-with-docker-compose"><a class="header" href="#running-devnets-with-docker-compose">Running devnets with Docker Compose</a></h1>
<p>In this section, we use Docker Compose to run a simple devnet with a single
validator.</p>
<p>Docker Compose is a tool for defining and managing multi-container Docker
applications. It allows you to describe the services, networks, and volumes of
your application in a single YAML file (docker-compose.yml). With Docker
Compose, you can easily start, stop, and manage all the containers in your
application as a single unit using simple commands like docker-compose up and
docker-compose down.</p>
<p>For a more complete setup, consider using Kind as described
<a href="operators/devnets/kind.html">in the next section</a>.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>This section covers everything you need to install to run a Linera network with
Docker Compose.</p>
<p>Note: This section has been tested only on Linux.</p>
<h3 id="docker-compose-requirements"><a class="header" href="#docker-compose-requirements">Docker Compose Requirements</a></h3>
<p>To install Docker Compose see the
<a href="https://docs.docker.com/compose/install/">installing Docker Compose</a> section in
the Docker docs.</p>
<h3 id="installing-the-linera-toolchain"><a class="header" href="#installing-the-linera-toolchain">Installing the Linera Toolchain</a></h3>
<p>To install the Linera Toolchain refer to the
<a href="operators/devnets/../../developers/getting_started/installation.html#installing-from-github">installation section</a>.</p>
<p>You want to install the toolchain from GitHub, as you'll be using the repository
to run the Docker Compose validator service.</p>
<h2 id="running-with-docker-compose"><a class="header" href="#running-with-docker-compose">Running with Docker Compose</a></h2>
<p>To run a local devnet with Docker Compose, navigate to the root of the
<code>linera-protocol</code> repository and run:</p>
<pre><code class="language-bash">cd docker &amp;&amp; ./compose.sh
</code></pre>
<p>This will take some time as Docker images are built from the Linera source. When
the service is ready, a temporary wallet and database are available under the
<code>docker</code> subdirectory.</p>
<p>Referencing these variables with the <code>linera</code> binary will enable you to interact
with the devnet:</p>
<pre><code class="language-bash">$ linera --wallet wallet.json --storage rocksdb:linera.db sync
2024-06-07T14:19:32.751359Z  INFO linera: Synchronizing chain information
2024-06-07T14:19:32.771842Z  INFO linera::client_context: Saved user chain states
2024-06-07T14:19:32.771850Z  INFO linera: Synchronized chain information in 20 ms
$ linera --wallet wallet.json --storage rocksdb:linera.db query-balance
2024-06-07T14:19:36.958149Z  INFO linera: Evaluating the local balance of e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65 by staging execution of known incoming messages
2024-06-07T14:19:36.959481Z  INFO linera: Balance obtained after 1 ms
10.
</code></pre>
<p>The network is transient, so killing the script will perform a cleanup operation
destroying wallets, storage and volumes associated with the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-devnets-with-kind"><a class="header" href="#running-devnets-with-kind">Running devnets with <code>kind</code></a></h1>
<p>In this section, we use <code>kind</code> to run a full devnet (network of validators)
locally.</p>
<p>Kind (Kubernetes in Docker) is a tool for running local Kubernetes clusters
using Docker container nodes. Kind uses Docker to create a cluster of containers
that simulate the Kubernetes control plane and worker nodes, allowing developers
to easily create, manage, and test multi-node clusters on their local machine.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>This section covers everything you need to install to run a Linera network with
<code>kind.</code></p>
<h3 id="linera-toolchain-requirements"><a class="header" href="#linera-toolchain-requirements">Linera Toolchain Requirements</a></h3>
<p>The operating systems currently supported by the Linera toolchain can be
summarized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Linux x86 64-bit</th><th>Mac OS (M1 / M2)</th><th>Mac OS (x86)</th><th>Windows</th></tr></thead><tbody>
<tr><td>✓ Main platform</td><td>✓ Working</td><td>✓ Working</td><td>Untested</td></tr>
</tbody></table>
</div>
<p>The main prerequisites to install the Linera toolchain are Rust, Wasm, and
Protoc. They can be installed as follows on Linux:</p>
<ul>
<li>
<p>Rust and Wasm</p>
<ul>
<li><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li><code>rustup target add wasm32-unknown-unknown</code></li>
</ul>
</li>
<li>
<p>Protoc</p>
<ul>
<li><code>curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protoc-21.11-linux-x86_64.zip</code></li>
<li><code>unzip protoc-21.11-linux-x86_64.zip -d $HOME/.local</code></li>
<li>If <code>~/.local</code> is not in your path, add it:
<code>export PATH="$PATH:$HOME/.local/bin"</code></li>
</ul>
</li>
<li>
<p>On certain Linux distributions, you may have to install development packages
such as <code>g++</code>, <code>libclang-dev</code> and <code>libssl-dev</code>.</p>
</li>
</ul>
<p>For MacOS support see the installation section on
<a href="https://github.com/linera-io/linera-protocol/blob/main/INSTALL.md">GitHub</a>.</p>
<p>This manual was tested with the following Rust toolchain:</p>
<pre><code class="language-text">[toolchain]
channel = "1.86.0"
components = [ "clippy", "rustfmt", "rust-src" ]
targets = [ "wasm32-unknown-unknown" ]
profile = "minimal"
</code></pre>
<h3 id="local-kubernetes-requirements"><a class="header" href="#local-kubernetes-requirements">Local Kubernetes Requirements</a></h3>
<p>To run <code>kind</code> locally, you also need the following dependencies:</p>
<ol>
<li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation"><code>kind</code></a></li>
<li><a href="https://kubernetes.io/docs/tasks/tools/"><code>kubectl</code></a></li>
<li><a href="https://docs.docker.com/get-docker/"><code>docker</code></a></li>
<li><a href="https://helm.sh/docs/intro/install/"><code>helm</code></a></li>
<li><a href="https://github.com/databus23/helm-diff"><code>helm-diff</code></a></li>
<li><a href="https://github.com/helmfile/helmfile?tab=readme-ov-file#installation"><code>helmfile</code></a></li>
</ol>
<h3 id="installing-the-linera-toolchain-1"><a class="header" href="#installing-the-linera-toolchain-1">Installing the Linera Toolchain</a></h3>
<p>To install the <code>Linera</code> toolchain, download the Linera source from
<a href="https://github.com/linera-io/linera-protocol">GitHub</a>:</p>
<pre><code class="language-bash">git clone https://github.com/linera-io/linera-protocol.git
cd linera-protocol
git checkout -t origin/testnet_conway  # Current release branch
</code></pre>
<p>and to install the Linera toolchain:</p>
<pre><code class="language-bash">cargo install --locked --path linera-service --features kubernetes
</code></pre>
<h2 id="running-with-kind"><a class="header" href="#running-with-kind">Running with <code>kind</code></a></h2>
<p>To run a local devnet with <code>kind</code>, navigate to the root of the <code>linera-protocol</code>
repository and run:</p>
<pre><code class="language-bash">linera net up --kubernetes
</code></pre>
<p>This will take some time as Docker images are built from the Linera source. When
the cluster is ready, some text is written to the process output containing the
exports required to configure your wallet for the devnet - something like:</p>
<pre><code class="language-bash">export LINERA_WALLET="/tmp/.tmpIOelqk/wallet_0.json"
export LINERA_KEYSTORE="/tmp/.tmpIOelqk/keystore_0.json"
export LINERA_STORAGE="rocksdb:/tmp/.tmpIOelqk/client_0.db"
</code></pre>
<p>Exporting these variables in a new terminal will enable you to interact with the
devnet:</p>
<pre><code class="language-bash">$ linera sync-balance
2024-05-21T22:30:12.061199Z  INFO linera: Synchronizing chain information and querying the local balance
2024-05-21T22:30:12.061218Z  WARN linera: This command is deprecated. Use `linera sync &amp;&amp; linera query-balance` instead.
2024-05-21T22:30:12.065787Z  INFO linera::client_context: Saved user chain states
2024-05-21T22:30:12.065792Z  INFO linera: Operation confirmed after 4 ms
1000000.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testnets"><a class="header" href="#testnets">Testnets</a></h1>
<p>This section discusses how to deploy a validator node and join an existing
Testnet.</p>
<p>In a Testnet, the validator nodes are run by different operators. Testnets will
gain in stability and decentralization over time in preparation of the mainnet
launch. Testnets do not handle real assets.</p>
<blockquote>
<p>In the initial Testnets of Linera, the set of validator nodes will be managed
by the Linera Core team.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h1>
<p>This section covers requirements for setting up a Linera Validator and joining a
Testnet. The validator deployment has been comprehensively tested under
<strong>Linux</strong>. There is no official support for MacOS or Windows yet.</p>
<h2 id="installing-the-linera-toolchain-2"><a class="header" href="#installing-the-linera-toolchain-2">Installing the Linera Toolchain</a></h2>
<blockquote>
<p>When installing the Linera Toolchain, you <strong>must</strong> check out the
<code>testnet_conway</code> branch.</p>
</blockquote>
<p>To install the Linera Toolchain refer to the
<a href="operators/testnets/../../developers/getting_started/installation.html#installing-from-github">installation section</a>.</p>
<p>You want to install the toolchain from GitHub, as you'll be using the repository
to run the Docker Compose validator service.</p>
<h2 id="docker-compose-requirements-1"><a class="header" href="#docker-compose-requirements-1">Docker Compose Requirements</a></h2>
<p>Linera validators run under Docker compose.</p>
<p>To install Docker Compose see the
<a href="https://docs.docker.com/compose/install/">installing Docker Compose</a> section in
the Docker docs.</p>
<h2 id="key-management"><a class="header" href="#key-management">Key Management</a></h2>
<p>Currently keys in Linera are stored in a JSON file in your local filesystem. For
convenience, they are currently plaintext. The key is usually called
<code>server.json</code> and is found in the <code>docker/</code> directory in the core protocol
repository.</p>
<p>Make sure to back up your keys once they are generated because if they are lost,
they are currently unrecoverable.</p>
<h2 id="infrastructure-requirements"><a class="header" href="#infrastructure-requirements">Infrastructure Requirements</a></h2>
<h3 id="automatic-ssl-with-caddy-recommended"><a class="header" href="#automatic-ssl-with-caddy-recommended">Automatic SSL with Caddy (Recommended)</a></h3>
<p>Starting with the Conway testnet, validators now include <strong>Caddy</strong> as a built-in
web server that automatically handles:</p>
<ol>
<li><strong>SSL/TLS certificates</strong> via Let's Encrypt (ACME protocol)</li>
<li><strong>HTTP/2 and gRPC support</strong> out of the box</li>
<li><strong>Automatic HTTPS redirection</strong> from port 80 to 443</li>
<li><strong>CORS headers</strong> for Web client support</li>
<li><strong>Security headers</strong> (HSTS, X-Frame-Options, etc.)</li>
</ol>
<p><strong>Required ports:</strong></p>
<ul>
<li><strong>Port 80</strong>: HTTP (for ACME challenge and redirect to HTTPS)</li>
<li><strong>Port 443</strong>: HTTPS (main validator endpoint)</li>
</ul>
<p>The deploy script automatically configures Caddy when you provide your email
address for Let's Encrypt certificates.</p>
<h3 id="manual-load-balancer-configuration-optional"><a class="header" href="#manual-load-balancer-configuration-optional">Manual Load Balancer Configuration (Optional)</a></h3>
<p>If you prefer to use your own load balancer instead of the built-in Caddy
server, ensure it has:</p>
<ol>
<li>Support HTTP/2 connections</li>
<li>Support gRPC connections</li>
<li>Support long-lived HTTP/2 connections</li>
<li>Support a maximum body size of up to 20 MB</li>
<li>Provide TLS termination with a certificate signed by a known CA</li>
<li>CORS headers for Web client support</li>
<li>Redirect traffic from port 443 to port 19100 (the internal proxy port)</li>
</ol>
<h3 id="using-nginx"><a class="header" href="#using-nginx">Using Nginx</a></h3>
<p>Minimum supported version: 1.18.0.</p>
<p>Below is an example Nginx configuration which upholds the infrastructure
requirements found in <code>/etc/nginx/sites-available/default</code>:</p>
<pre><code class="language-ignore">server {
        listen 80 http2;

        location / {
                grpc_pass grpc://127.0.0.1:19100;
        }
}

server {
    listen 443 ssl http2;
    server_name &lt;hostname&gt;; # e.g. my-subdomain.my-domain.net

    # SSL certificates
    ssl_certificate &lt;ssl-cert-path&gt;; # e.g. /etc/letsencrypt/live/my-subdomain.my-domain.net/fullchain.pem
    ssl_certificate_key &lt;ssl-key-path&gt;; # e.g. /etc/letsencrypt/live/my-subdomain.my-domain.net/privkey.pem;

    # Proxy traffic to the service running on port 19100.
    location / {
        grpc_pass grpc://127.0.0.1:19100;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Access-Control-Allow-Origin *;
    }

    keepalive_timeout 10m 60s;
    grpc_read_timeout 10m;
    grpc_send_timeout 10m;

    client_header_timeout 10m;
    client_body_timeout 10m;
}
</code></pre>
<h3 id="using-external-caddy"><a class="header" href="#using-external-caddy">Using External Caddy</a></h3>
<p>If you're running Caddy separately (not using the built-in Docker Compose
service), minimum supported version is v2.4.3.</p>
<p>The built-in Caddy configuration automatically handles SSL certificates and
proxying. If you need to customize it, you can modify <code>docker/Caddyfile</code>:</p>
<pre><code class="language-caddy">{
    email {$EMAIL}
}

{$DOMAIN:localhost} {
    # Automatic HTTPS with Let's Encrypt

    # Reverse proxy to the Linera proxy container (gRPC over HTTPS)
    reverse_proxy https://proxy:443 {
        transport http {
            versions h2c 2
            dial_timeout 60s
            response_header_timeout 60s
            tls_insecure_skip_verify
        }

        header_up Host {host}
        header_up X-Real-IP {remote}
        header_up X-Forwarded-For {remote}
        header_up X-Forwarded-Proto {scheme}
    }

    # Security headers
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains"
        X-Frame-Options "SAMEORIGIN"
        X-Content-Type-Options "nosniff"
        X-XSS-Protection "1; mode=block"
        -Server
    }

    encode gzip
}
</code></pre>
<h3 id="scylladb-configuration"><a class="header" href="#scylladb-configuration">ScyllaDB Configuration</a></h3>
<p>ScyllaDB is an open-source distributed NoSQL database built for high-performance
and low-latency. Linera validators use ScyllaDB as their persistent storage.</p>
<h4 id="automatic-configuration"><a class="header" href="#automatic-configuration">Automatic Configuration</a></h4>
<p>The Docker Compose setup includes ScyllaDB with automatic configuration:</p>
<ul>
<li><strong>Developer mode</strong> enabled for simplified setup</li>
<li><strong>Overprovisioned mode</strong> for resource-constrained environments</li>
<li><strong>Auto-configuration</strong> via <code>SCYLLA_AUTO_CONF=1</code> environment variable</li>
</ul>
<h4 id="manual-kernel-tuning-if-required"><a class="header" href="#manual-kernel-tuning-if-required">Manual Kernel Tuning (If Required)</a></h4>
<p>ScyllaDB performs best with certain kernel parameters tuned. The most important
is the number of events allowed in asynchronous I/O contexts.</p>
<p>To check current value:</p>
<pre><code class="language-bash">cat /proc/sys/fs/aio-max-nr
</code></pre>
<p>If the value is less than 1048576, increase it:</p>
<pre><code class="language-bash">echo 1048576 | sudo tee /proc/sys/fs/aio-max-nr
</code></pre>
<p>To make this change persistent across reboots:</p>
<pre><code class="language-bash">echo "fs.aio-max-nr = 1048576" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p /etc/sysctl.conf
</code></pre>
<blockquote>
<p><strong>Note</strong>: The Kubernetes deployment automatically sets this via <code>sysctls</code> in
the pod spec, but Docker Compose deployments may require manual configuration
on the host.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h2 id="one-click-deploy"><a class="header" href="#one-click-deploy">One-Click Deploy</a></h2>
<p>After downloading the <code>linera-protocol</code> repository and checking out the testnet
branch <code>testnet_conway</code>, you can run
<code>scripts/deploy-validator.sh &lt;hostname&gt; &lt;email&gt;</code> to deploy a Linera validator.</p>
<p>For example:</p>
<pre><code class="language-bash">$ git fetch origin
$ git checkout -t origin/testnet_conway
$ scripts/deploy-validator.sh linera.mydomain.com admin@mydomain.com
</code></pre>
<p>The email address is required for ACME/Let's Encrypt SSL certificate generation.</p>
<h3 id="what-the-deploy-script-does"><a class="header" href="#what-the-deploy-script-does">What the Deploy Script Does</a></h3>
<p>The one-click deploy script automatically:</p>
<ol>
<li><strong>Configures Caddy</strong> for automatic SSL/TLS certificates via Let's Encrypt</li>
<li><strong>Opens only ports 80 and 443</strong> - no manual load balancer needed!</li>
<li><strong>Sets up ScyllaDB</strong> with automatic configuration and developer mode</li>
<li><strong>Configures monitoring</strong> with Prometheus and Grafana</li>
<li><strong>Enables automatic updates</strong> via Watchtower (checks every 30 seconds)</li>
<li><strong>Generates validator keys</strong> and configuration files</li>
<li><strong>Downloads genesis configuration</strong> from the testnet bucket</li>
</ol>
<p>The deployment automatically listens for new image updates and will pull them
automatically.</p>
<h3 id="deploy-script-options"><a class="header" href="#deploy-script-options">Deploy Script Options</a></h3>
<p>The deploy script accepts the following arguments:</p>
<ul>
<li><code>&lt;hostname&gt;</code> (required): The domain name for your validator</li>
<li><code>&lt;email&gt;</code> (required): Email address for ACME/Let's Encrypt certificates</li>
</ul>
<p>And the following optional flags:</p>
<ul>
<li><code>--local-build</code>: Build Docker image locally instead of using registry image</li>
<li><code>--remote-image</code>: Explicitly use remote Docker image from registry
(deprecated, now default)</li>
<li><code>--skip-genesis</code>: Skip downloading the genesis configuration (use existing)</li>
<li><code>--force-genesis</code>: Force re-download of genesis configuration even if it
exists</li>
<li><code>--custom-tag TAG</code>: Use a custom Docker image tag for testing (no _release
suffix)</li>
<li><code>--xfs-path PATH</code>: Optional XFS partition path for optimal ScyllaDB
performance</li>
<li><code>--cache-size SIZE</code>: Optional ScyllaDB cache size (default: 4G, e.g. 2G, 8G,
16G)</li>
<li><code>--dry-run</code>: Preview what would be done without executing</li>
<li><code>--verbose</code> or <code>-v</code>: Enable verbose output</li>
<li><code>--help</code> or <code>-h</code>: Show help message</li>
</ul>
<blockquote>
<p>Note: By default, the script uses the pre-built Docker image from the official
registry. Use <code>--local-build</code> if you want to build from source.</p>
</blockquote>
<h3 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h3>
<p>You can customize the deployment further using environment variables:</p>
<ul>
<li><code>ACME_EMAIL</code>: Override the email for Let's Encrypt certificates</li>
<li><code>LINERA_IMAGE</code>: Use a custom Docker image (overrides all image settings)</li>
<li><code>DOCKER_REGISTRY</code>: Override the Docker registry (default:
us-docker.pkg.dev/linera-io-dev/linera-public-registry)</li>
<li><code>IMAGE_NAME</code>: Override the image name (default: linera)</li>
<li><code>IMAGE_TAG</code>: Override the image tag (default: <code>&lt;branch&gt;_release</code>)</li>
<li><code>GENESIS_URL</code>: Override the genesis configuration URL</li>
<li><code>GENESIS_BUCKET</code>: GCP bucket for genesis files</li>
<li><code>GENESIS_PATH_PREFIX</code>: Path prefix in bucket (default: uses branch name)</li>
<li><code>NUM_SHARDS</code>: Number of validator shards (default: 4)</li>
<li><code>PORT</code>: Internal validator port (default: 19100)</li>
<li><code>METRICS_PORT</code>: Metrics collection port (default: 21100)</li>
<li><code>SCYLLA_XFS_PATH</code>: Optional XFS partition mount path for ScyllaDB data</li>
<li><code>SCYLLA_CACHE_SIZE</code>: ScyllaDB cache size (default: 4G)</li>
</ul>
<p>For example:</p>
<pre><code class="language-bash"># Deploy with more shards
NUM_SHARDS=8 scripts/deploy-validator.sh validator.example.com admin@example.com

# Deploy with XFS partition for optimal ScyllaDB performance
scripts/deploy-validator.sh validator.example.com admin@example.com \
  --xfs-path /mnt/xfs-scylla --cache-size 8G

# Deploy with custom image tag (for testing)
scripts/deploy-validator.sh validator.example.com admin@example.com \
  --custom-tag devnet_2025_08_21

# Build Docker image locally instead of using registry
scripts/deploy-validator.sh validator.example.com admin@example.com --local-build
</code></pre>
<p>The public key and account key will be printed after the command has finished
executing, for example:</p>
<pre><code class="language-bash">$ scripts/deploy-validator.sh linera.mydomain.com admin@mydomain.com
...
Public Key: 02a580bbda90f0ab10f015422d450b3e873166703af05abd77d8880852a3504e4d,009b2ecc5d39645e81ff01cfe4ceeca5ec207d822762f43b35ef77b2367666a7f8
</code></pre>
<p>The public key and account key, in this case beginning with <code>02a</code> and <code>009</code>
respectively, must be communicated to the Linera Protocol core team along with
the chosen host name for onboarding in the next epoch.</p>
<p>For a more bespoke deployment, refer to the manual installation instructions
below.</p>
<blockquote>
<p><strong>Note</strong>: If you have previously deployed a validator you may need to remove
old docker volumes (<code>docker_linera-scylla-data</code> and <code>docker_linera-shared</code>).</p>
</blockquote>
<h3 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h3>
<p>Before running the deploy script, ensure your system meets these requirements:</p>
<ol>
<li><strong>Ports</strong>: Ensure ports 80 and 443 are open and not in use</li>
<li><strong>Domain</strong>: Your domain must point to this server's IP address</li>
<li><strong>Kernel tuning</strong>: The deploy script will automatically configure AIO
settings via the scylla-setup container. If automatic configuration fails,
you may need to manually run:
<pre><code class="language-bash">echo 1048576 | sudo tee /proc/sys/fs/aio-max-nr
echo "fs.aio-max-nr = 1048576" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p
</code></pre>
</li>
<li><strong>XFS partition</strong> (optional, for maximum performance): For production
deployments with high I/O requirements, consider using a dedicated XFS
partition for ScyllaDB:
<pre><code class="language-bash"># Example: Create and mount XFS partition
sudo mkfs.xfs /dev/nvme1n1  # Replace with your device
sudo mkdir -p /mnt/xfs-scylla
sudo mount /dev/nvme1n1 /mnt/xfs-scylla
# Then use: --xfs-path /mnt/xfs-scylla
</code></pre>
Note: Standard Docker volumes work fine for most deployments</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h1>
<p>If you don't want to use the provided deploy script, you can instead choose to
manually roll out your validator deployment.</p>
<h2 id="setting-up-a-linera-validator"><a class="header" href="#setting-up-a-linera-validator">Setting up a Linera Validator</a></h2>
<p>For the next section, we'll be working out of the <code>docker</code> subdirectory in the
<code>linera-protocol</code> repository.</p>
<h3 id="creating-your-validator-configuration"><a class="header" href="#creating-your-validator-configuration">Creating your Validator Configuration</a></h3>
<p>Validators are configured using a TOML file. You can use the following template
to set up your own validator configuration:</p>
<pre><code class="language-toml">server_config_path = "server.json"
host = "&lt;your-host&gt;" # e.g. my-subdomain.my-domain.net
port = 443

[external_protocol]
Grpc = "Tls"

[internal_protocol]
Grpc = "ClearText"

[[proxies]]
host = "proxy"
public_port = 443
private_port = 20100
metrics_port = 21100

# Adjust depending on the number of shards you have
[[shards]]
host = "docker-shard-1"
port = 19100
metrics_port = 21100

[[shards]]
host = "docker-shard-2"
port = 19100
metrics_port = 21100

[[shards]]
host = "docker-shard-3"
port = 19100
metrics_port = 21100

[[shards]]
host = "docker-shard-4"
port = 19100
metrics_port = 21100

</code></pre>
<h3 id="genesis-configuration"><a class="header" href="#genesis-configuration">Genesis Configuration</a></h3>
<p>The genesis configuration describes the committee of validators and chains at
the point of network creation. It is required for validators to function.</p>
<p>Initially, the genesis configuration for each Testnet will be found in a public
bucket managed by the Linera Protocol core team.</p>
<p>An example can be found here:</p>
<pre><code class="language-bash">wget "https://storage.googleapis.com/linera-io-dev-public/testnet-conway/genesis.json"
</code></pre>
<h3 id="creating-your-keys"><a class="header" href="#creating-your-keys">Creating Your Keys</a></h3>
<p>Now that the
<a href="operators/testnets/manual-installation.html#creating-your-validator-configuration">validator configuration</a>
has been created and the
<a href="operators/testnets/manual-installation.html#genesis-configuration">genesis configuration</a> is
available, the validator private keys can be generated.</p>
<p>To generate the private keys, the <code>linera-server</code> binary is used:</p>
<pre><code class="language-bash">linera-server generate --validators /path/to/validator/configuration.toml
</code></pre>
<p>This will generate a file called <code>server.json</code> with the information required for
a validator to operate, including a cryptographic keypair.</p>
<p>The public key will be printed after the command has finished executing, for
example:</p>
<pre><code class="language-bash">$ linera-server generate --validators /path/to/validator/configuration.toml
2024-07-01T16:51:32.881519Z  INFO linera_server: Wrote server config server.json
02a580bbda90f0ab10f015422d450b3e873166703af05abd77d8880852a3504e4d,009b2ecc5d39645e81ff01cfe4ceeca5ec207d822762f43b35ef77b2367666a7f8
</code></pre>
<p>The public key and account key, in this case beginning with <code>02a</code> and <code>009</code>
respectively, must be communicated to the Linera Protocol core team along with
the chosen host name for onboarding in the next epoch.</p>
<blockquote>
<p>Note: Before being included in the next epoch, validator nodes will receive no
traffic from existing users.</p>
</blockquote>
<h3 id="using-the-linera-docker-image"><a class="header" href="#using-the-linera-docker-image">Using the Linera Docker image</a></h3>
<h4 id="option-1-use-pre-built-image-recommended"><a class="header" href="#option-1-use-pre-built-image-recommended">Option 1: Use Pre-built Image (Recommended)</a></h4>
<p>By default, the Linera Docker images are available from the official registry.
The images are tagged based on the branch:</p>
<ul>
<li><code>latest</code> for the main branch</li>
<li><code>{branch}_release</code> for release branches</li>
</ul>
<p>The default image path is:</p>
<pre><code class="language-text">us-docker.pkg.dev/linera-io-dev/linera-public-registry/linera:{tag}
</code></pre>
<p>You can pull the image directly:</p>
<pre><code class="language-bash">docker pull us-docker.pkg.dev/linera-io-dev/linera-public-registry/linera:latest
</code></pre>
<h4 id="option-2-build-locally"><a class="header" href="#option-2-build-locally">Option 2: Build Locally</a></h4>
<p>If you prefer to build the Linera Docker image locally, run the following
command from the root of the <code>linera-protocol</code> repository:</p>
<pre><code class="language-bash">docker build --build-arg git_commit="$(git rev-parse --short HEAD)" -f docker/Dockerfile . -t linera
</code></pre>
<p>This can take several minutes.</p>
<p>When using docker-compose, set the <code>LINERA_IMAGE</code> environment variable to use
your locally built image:</p>
<pre><code class="language-bash">export LINERA_IMAGE=linera
</code></pre>
<h3 id="configuring-caddy-for-ssltls"><a class="header" href="#configuring-caddy-for-ssltls">Configuring Caddy for SSL/TLS</a></h3>
<p>The validator deployment includes Caddy for automatic SSL certificate
management. Before starting the validator, ensure you have:</p>
<ol>
<li><strong>Set environment variables</strong>:</li>
</ol>
<pre><code class="language-bash">export DOMAIN="your-validator.example.com"
export ACME_EMAIL="admin@example.com"
</code></pre>
<ol start="2">
<li><strong>Opened required ports</strong>:
<ul>
<li>Port 80 (HTTP - for ACME challenge)</li>
<li>Port 443 (HTTPS - main validator endpoint)</li>
</ul>
</li>
</ol>
<p>The <code>docker/Caddyfile</code> is pre-configured to automatically obtain Let's Encrypt
certificates and handle gRPC traffic.</p>
<h3 id="running-a-validator-node"><a class="header" href="#running-a-validator-node">Running a Validator Node</a></h3>
<p>Now that the genesis configuration is available at <code>docker/genesis.json</code> and the
server configuration is available at <code>docker/server.json</code>, the validator can be
started by running from inside the <code>docker</code> directory:</p>
<pre><code class="language-bash"># Using the default pre-built image
cd docker &amp;&amp; docker compose up -d

# Or, if you built the image locally
cd docker &amp;&amp; LINERA_IMAGE=linera docker compose up -d
</code></pre>
<p>This will run the Docker Compose deployment in a detached mode, which includes:</p>
<ul>
<li><strong>Caddy</strong>: Web server with automatic SSL (ports 80/443)</li>
<li><strong>ScyllaDB</strong>: High-performance database</li>
<li><strong>Proxy</strong>: Main validator proxy service</li>
<li><strong>Shards</strong>: 4 validator shard replicas</li>
<li><strong>Prometheus &amp; Grafana</strong>: Monitoring stack</li>
<li><strong>Watchtower</strong>: Automatic container updates</li>
</ul>
<p>It can take a few minutes for all services to initialize, especially ScyllaDB.</p>
<h4 id="scylladb-performance-optimization-optional"><a class="header" href="#scylladb-performance-optimization-optional">ScyllaDB Performance Optimization (Optional)</a></h4>
<p>For production deployments with high I/O requirements, you can optimize ScyllaDB
performance by using a dedicated XFS partition:</p>
<ol>
<li>
<p><strong>Create an XFS partition</strong> (if not already available):</p>
<pre><code class="language-bash">sudo mkfs.xfs /dev/nvme1n1  # Replace with your device
sudo mkdir -p /mnt/xfs-scylla
sudo mount /dev/nvme1n1 /mnt/xfs-scylla
</code></pre>
</li>
<li>
<p><strong>Create a docker-compose.override.yml</strong> file in the <code>docker</code> directory:</p>
<pre><code class="language-yaml">services:
  scylla:
    volumes:
      - /mnt/xfs-scylla/scylla-data:/var/lib/scylla
    environment:
      SCYLLA_AUTO_CONF: 1
      SCYLLA_DIRECT_IO_MODE: 'true'
      SCYLLA_CACHE_SIZE: '8G' # Adjust based on available RAM
</code></pre>
</li>
<li>
<p><strong>Set proper permissions</strong>:</p>
<pre><code class="language-bash">sudo mkdir -p /mnt/xfs-scylla/scylla-data
sudo chown -R 999:999 /mnt/xfs-scylla/scylla-data
</code></pre>
</li>
</ol>
<p>Note: Standard Docker volumes work fine for most deployments. XFS optimization
is only needed for very high throughput scenarios.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying installation</a></h1>
<p>To verify the installation, you can use the <code>linera query-validator</code> command.
For example:</p>
<pre><code class="language-bash">$ linera wallet init --faucet https://faucet.testnet-conway.linera.net
$ linera wallet request-chain --faucet https://faucet.testnet-conway.linera.net
$ linera query-validator grpcs:my-domain.com:443

RPC API hash: kd/Ru73B4ZZjXYkFqqSzoWzqpWi+NX+8IJLXOODjSko
GraphQL API hash: eZqzuBlLT0bcoQUjOCPf2j22NfZUWG95id4pdlUmhgs
WIT API hash: 4/gsw8G+47OUoEWK6hJRGt9R69RanU/OidmX7OKhqfk
Source code: https://github.com/linera-io/linera-protocol/tree/

0cd20d06af5262540535347d4cc6e5952a921d1a6a7f6dd0982159c9311cfb3e
</code></pre>
<p>The last line is the hash of the network's genesis configuration. If this
command exits successfully your validator is now operational and ready to be
on-boarded.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="monitoring-and-logging"><a class="header" href="#monitoring-and-logging">Monitoring and Logging</a></h1>
<p>This section covers how to monitor the behaviour and performance of your
validator once deployed.</p>
<h2 id="monitoring"><a class="header" href="#monitoring">Monitoring</a></h2>
<p>The validator deployment includes a complete monitoring stack:</p>
<ul>
<li><strong><a href="https://prometheus.io/">Prometheus</a></strong>: Metrics collection (port 9090)</li>
<li><strong><a href="https://grafana.com/">Grafana</a></strong>: Visualization dashboards (port 3000)</li>
<li><strong>Watchtower</strong>: Automatic container updates (checks every 30 seconds)</li>
</ul>
<h3 id="accessing-grafana"><a class="header" href="#accessing-grafana">Accessing Grafana</a></h3>
<ol>
<li>Open your browser to <code>http://your-server-ip:3000</code></li>
<li>Default credentials:
<ul>
<li>Username: <code>admin</code></li>
<li>Password: <code>admin</code> (you'll be prompted to change it)</li>
</ul>
</li>
<li>Navigate to the "General" dashboard for validator metrics</li>
</ol>
<p>The dashboard displays:</p>
<ul>
<li>Request latency percentiles</li>
<li>Error rates</li>
<li>Throughput metrics</li>
<li>Resource utilization</li>
</ul>
<p><img src="operators/testnets/dashboard-example.png" alt="img.png" /></p>
<h3 id="available-services-and-ports"><a class="header" href="#available-services-and-ports">Available Services and Ports</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Service</th><th>Port</th><th>Purpose</th></tr></thead><tbody>
<tr><td>Caddy (web)</td><td>80, 443</td><td>SSL/TLS termination and reverse proxy</td></tr>
<tr><td>Grafana</td><td>3000</td><td>Monitoring dashboards</td></tr>
<tr><td>Prometheus</td><td>9090</td><td>Metrics collection</td></tr>
<tr><td>Proxy</td><td>19100</td><td>Internal validator proxy (not exposed externally)</td></tr>
<tr><td>ScyllaDB</td><td>9042</td><td>Database (internal only)</td></tr>
</tbody></table>
</div>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>Logging is handled by Docker Compose, capturing stdout/stderr from all services.</p>
<h3 id="viewing-logs"><a class="header" href="#viewing-logs">Viewing Logs</a></h3>
<pre><code class="language-bash"># View all logs
docker compose logs

# View logs for specific service
docker compose logs web          # Caddy web server
docker compose logs proxy        # Validator proxy
docker compose logs scylla       # ScyllaDB
docker compose logs shard        # Validator shards (all replicas)

# Follow logs in real-time
docker compose logs -f

# View last 100 lines
docker compose logs --tail=100

# View logs for multiple services
docker compose logs web proxy

# View logs with timestamps
docker compose logs -t
</code></pre>
<h3 id="common-log-checks"><a class="header" href="#common-log-checks">Common Log Checks</a></h3>
<pre><code class="language-bash"># Check SSL certificate status
docker compose logs web | grep -i "certificate"

# Check for errors
docker compose logs | grep -i error

# Check ScyllaDB initialization
docker compose logs scylla | grep -i "started"

# Monitor shard health
docker compose logs shard | grep -i "health"
</code></pre>
<h3 id="log-rotation"><a class="header" href="#log-rotation">Log Rotation</a></h3>
<p>Docker automatically rotates logs. To configure log rotation, add to your
<code>docker-compose.yml</code>:</p>
<pre><code class="language-yaml">services:
  proxy:
    logging:
      driver: 'json-file'
      options:
        max-size: '100m'
        max-file: '10'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging"><a class="header" href="#debugging">Debugging</a></h1>
<p>This section covers potential issues with validator deployments and how to
resolve them.</p>
<h2 id="common-issues"><a class="header" href="#common-issues">Common Issues</a></h2>
<p>Below we outline a few of the common occurrences with Linera validator
deployments and how to resolve them.</p>
<h3 id="shard-init-process-is-stuck"><a class="header" href="#shard-init-process-is-stuck"><code>shard-init</code> process is stuck</a></h3>
<p>The <code>shard-init</code> process is responsible for initializing the database and
shards.</p>
<p>The database inside a validator, ScyllaDB, can take some time to initialize as
it performs performance checks and tunes itself against the underlying
hardware - this should take about 10 minutes.</p>
<p>If the <code>shard-init</code> process is <em>still</em> stuck after that, the issue is usually:</p>
<ol>
<li>Not enough events allowed in async I/O contexts. A resolution is outlined
<a href="operators/testnets/requirements.html#scylladb-configuration">here</a>.</li>
<li>Stale volumes from a previous deployment. Docker doesn't clean up volumes
automatically when deleting an old deployment via <code>docker compose down</code> or
even when running <code>docker system prune -a</code>. The old stale volumes need to be
removed explicitly via <code>docker volume rm ...</code>.</li>
</ol>
<p>If neither of these fixes resolves the issue, a closer inspection of the logs is
required.</p>
<h3 id="pull-access-denied"><a class="header" href="#pull-access-denied"><code>pull access denied</code></a></h3>
<p>When deploying a validator, the system uses pre-built Docker images from the
official registry by default. You can also build the Docker image yourself using
the <code>--local-build</code> flag.</p>
<p>The Docker Compose manifest looks for the <code>LINERA_IMAGE</code> environment variable.
If not set, it defaults to:</p>
<pre><code class="language-text">us-docker.pkg.dev/linera-io-dev/linera-public-registry/linera:latest
</code></pre>
<p>If you encounter pull access issues:</p>
<ol>
<li>
<p><strong>Check network connectivity</strong> to the registry:</p>
<pre><code class="language-bash">docker pull us-docker.pkg.dev/linera-io-dev/linera-public-registry/linera:latest
</code></pre>
</li>
<li>
<p><strong>Build locally instead</strong> if registry access fails:</p>
<pre><code class="language-bash">scripts/deploy-validator.sh &lt;host&gt; &lt;email&gt; --local-build
</code></pre>
<p>Or manually:</p>
<pre><code class="language-bash">docker build --build-arg git_commit="$(git rev-parse --short HEAD)" -f docker/Dockerfile . -t linera
export LINERA_IMAGE=linera
</code></pre>
</li>
<li>
<p><strong>Use a custom image</strong> by setting <code>LINERA_IMAGE</code>:</p>
<pre><code class="language-bash">export LINERA_IMAGE=my-registry/my-image:my-tag
</code></pre>
</li>
</ol>
<h3 id="access-denied-to-genesisjson"><a class="header" href="#access-denied-to-genesisjson"><code>Access denied to genesis.json</code></a></h3>
<p>This occurs when the genesis configuration URL is malformed via string
formatting. The deploy script uses the name of the current branch to create the
URL so make sure you have checked out <code>testnet_conway</code>.</p>
<h3 id="ssl-certificate-issues-with-caddy"><a class="header" href="#ssl-certificate-issues-with-caddy">SSL Certificate Issues with Caddy</a></h3>
<p>If Caddy fails to obtain SSL certificates:</p>
<ol>
<li><strong>Check domain DNS</strong>: Ensure your domain points to the server's public IP</li>
<li><strong>Check ports</strong>: Verify ports 80 and 443 are open and reachable:
<pre><code class="language-bash">sudo netstat -tlnp | grep -E ':80|:443'
</code></pre>
</li>
<li><strong>Check Caddy logs</strong>:
<pre><code class="language-bash">docker compose logs web
</code></pre>
</li>
<li><strong>Rate limiting</strong>: Let's Encrypt has rate limits. If hit, wait or use
staging:
<pre><code class="language-bash"># Edit docker/Caddyfile and add to the global section:
acme_ca https://acme-staging-v02.api.letsencrypt.org/directory
</code></pre>
</li>
</ol>
<h3 id="port-conflicts"><a class="header" href="#port-conflicts">Port Conflicts</a></h3>
<p>The validator now uses these ports:</p>
<ul>
<li><strong>80</strong>: HTTP (Caddy for ACME challenge)</li>
<li><strong>443</strong>: HTTPS (Caddy reverse proxy)</li>
<li><strong>3000</strong>: Grafana dashboard</li>
<li><strong>9090</strong>: Prometheus metrics</li>
<li><strong>19100</strong>: Internal proxy port (not exposed externally anymore)</li>
</ul>
<p>If you see port binding errors:</p>
<pre><code class="language-bash"># Check what's using the ports
sudo lsof -i :80
sudo lsof -i :443

# Stop conflicting services or change ports in docker-compose.yml
</code></pre>
<h2 id="support"><a class="header" href="#support">Support</a></h2>
<p>Support and communication with the core team is done via the <code>#validator</code>
private channel in the <a href="https://discord.com/invite/linera">Linera Discord</a>.</p>
<p>If there are any outstanding issues which could not be resolved by consulting
this document, you can reach out there.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>
<p><strong>Address</strong>: A unique public alphanumeric identifier used to designate the
identity of an entity on the Linera network.</p>
</li>
<li>
<p><strong>Admin Chain</strong>: The Linera Network has one designated <em>admin chain</em> where
validators can join or leave and where new epochs are defined.</p>
</li>
<li>
<p><strong>Application</strong>: Similar to a smart-contract on Ethereum, an application is
code deployed on the Linera network which is executed by all validators. An
application has a metered <em>contract</em> which executes 'business logic' and
modifies state and an unmetered 'service' which is a read-only view into an
application's state.</p>
</li>
<li>
<p><strong>Byzantine Fault-Tolerant (BFT)</strong>: A system which can operate correctly and
achieve consensus even if components of the system fail or act maliciously.</p>
</li>
<li>
<p><strong>Block Height</strong>: The number of blocks preceding a given block on a specific
microchain.</p>
</li>
<li>
<p><strong>Block Proposal</strong>: A candidate block proposed by a chain owner which may be
selected at the next block height.</p>
</li>
<li>
<p><strong>Bytecode</strong>: A collection of bytes corresponding to a program that can be run
by the virtual machine. This is either a Wasm or EVM bytecode.</p>
</li>
<li>
<p><strong>Client</strong>: The <code>linera</code> program, which is a local node and wallet operated by
users to make requests to the network. In Linera, clients drive the network by
proposing new blocks and validators are mostly reactive.</p>
</li>
<li>
<p><strong>Certificate</strong>: A value with signatures from a quorum of validators. Values
can be confirmed blocks, meaning that the block has been added to the chain
and is final. There are other values that are used for reaching consensus,
before certifying a confirmed block.</p>
</li>
<li>
<p><strong>Committee</strong>: The set of all validators for a particular <em>epoch</em>, together
with their voting weights.</p>
</li>
<li>
<p><strong>Chain Owner</strong>: The owner of a <em>user chain</em> or <em>multi-user chain</em>. This is
represented as the alphanumeric identifier derived from the hash of the
owner's public key.</p>
</li>
<li>
<p><strong>Channel</strong>: A broadcast mechanism enabling publish-subscribe behavior across
chains.</p>
</li>
<li>
<p><strong>Contract</strong>: The metered part of an application which executes business logic
and can modify the application's state.</p>
</li>
<li>
<p><strong>Cross-Application Call</strong>: A call from one application to another on the
<em>same chain</em>.</p>
</li>
<li>
<p><strong>Cross-Chain Message</strong>: A message containing a data payload which is sent
from one chain to another. Cross-Chain messages are the asynchronous
communication primitive which enable communication on the same application
running on different chains.</p>
</li>
<li>
<p><strong>Devnet</strong>: An experimental deployment of the Linera protocol meant for
testing and development. In a Devnet, the validator nodes are often run by the
same operator for simplicity. Devnets may be shut down and restarted from a
genesis configuration any time. Devnets do not handle real assets.</p>
</li>
<li>
<p><strong>Epoch</strong>: A period of time when a particular set of validators with
particular voting weights can certify new blocks. Since each chain has to
transition explicitly from one epoch to the next, epochs can overlap.</p>
</li>
<li>
<p><strong>Genesis Configuration</strong>: The configuration determining the state of a newly
created network; the voting weights of the initial set of validators, the
initial fee structure, and initial chains that the network starts with.</p>
</li>
<li>
<p><strong>Inbox</strong>: A commutative data structure storing incoming messages for a given
chain.</p>
</li>
<li>
<p><strong>Mainnet</strong>: A deployment meant to be used in production, with real assets.</p>
</li>
<li>
<p><strong>Message</strong>: See 'Cross-Chain Message'.</p>
</li>
<li>
<p><strong>Microchain</strong>: A lightweight chain of blocks holding a subset of the
network's state running on every validator. This is used interchangeably with
'chain'. <em>All</em> Linera chains are microchains.</p>
</li>
<li>
<p><strong>Network</strong>: The totality of all protocol participants. A network is the
combination of committee, clients and auditors.</p>
</li>
<li>
<p><strong>Operation</strong>: Operations are either transactions directly added to a block by
the creator (and signer) of the block, or calls to an application from
another. Users typically use operations to start interacting with an
application on their own chain.</p>
</li>
<li>
<p><strong>Multi-user Chain</strong>: A microchain which is owned by more than one user. Users
take turns proposing blocks and the likelihood of selection is proportional to
their <em>weight</em>.</p>
</li>
<li>
<p><strong>Project</strong>: The collection of files and dependencies which are built into the
bytecode which is instantiated as an application on the Linera Network.</p>
</li>
<li>
<p><strong>Public Chain</strong>: A microchain with full BFT consensus with a strict set of
permissions relied on for the operation of the network.</p>
</li>
<li>
<p><strong>Quorum</strong>: A set of validators representing &gt; ⅔ of the total stake. A quorum
is required to create a certificate.</p>
</li>
<li>
<p><strong>Single-Owner Chain</strong>: See 'User Chain'.</p>
</li>
<li>
<p><strong>Service</strong>: An unmetered read-only view into an application's state.</p>
</li>
<li>
<p><strong>Shard</strong>: A logical subset of all microchains on a given validator. This
corresponds directly to a physical <em>worker</em>.</p>
</li>
<li>
<p><strong>Stake</strong>: An amount of tokens pledged by a validator or auditor, as a
collateral to guarantee their honest and correct participation in the network.</p>
</li>
<li>
<p><strong>Testnet</strong>: A deployment of the Linera protocol meant for testing and
development. In a Testnet, the validator nodes are operated by multiple
operators. Testnets will gain in stability and decentralization over time in
preparation of the mainnet launch. Testnets do not handle real assets.</p>
</li>
<li>
<p><strong>User Chain</strong>: Used interchangeably with <em>Single-Owner Chain</em>. User chains
are chains which are owned by a single user on the network. Only the chain
owner can propose blocks, and therefore only the chain owner can forcibly
advance the state of a user chain.</p>
</li>
<li>
<p><strong>Validator</strong>: Validators run the servers that allow users to download and
create blocks. They validate, execute and cryptographically certify the blocks
of all the chains.</p>
</li>
<li>
<p><strong>View</strong>: Views are like an Object-Relational Mapping (ORM) for mapping
complex types onto key-value stores. Views group complex state changes into a
set of elementary operations and commit them atomically. They are full or
partial in-memory representations of complex types saved on disk in a
key-value store</p>
</li>
<li>
<p><strong>Wallet</strong>: A file containing a user's public and private keys along with
configuration and information regarding the chains they own.</p>
</li>
<li>
<p><strong>WebAssembly (Wasm)</strong>: A binary compilation target and instruction format
that runs on a stack-based VM. Linera applications are compiled to Wasm and
run on Wasm VMs inside validators and clients.</p>
</li>
<li>
<p><strong>Web3</strong>: A natural evolution of the internet focusing on decentralization by
leveraging blockchains and smart contracts.</p>
</li>
<li>
<p><strong>Worker</strong>: A process which runs a subset of all microchains on a given
validator. This corresponds directly to a logical <em>shard</em>.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-b074573a.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-ba43d0c1.js"></script>

        <!-- Custom JS scripts -->
        <script src="custom-6e1704cf.js"></script>
        <script src="mermaid-eefea253.min.js"></script>
        <script src="mermaid-init-4a2716e5.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
