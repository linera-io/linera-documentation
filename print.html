<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="The Linera Developer Manual">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-d0866e17.css">
        <link rel="stylesheet" href="css/general-e9745eeb.css">
        <link rel="stylesheet" href="css/chrome-d7ced664.css">
        <link rel="stylesheet" href="css/print-ad67d350.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome-799aeb25.css">
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight-56612340.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/theme-061c46ea.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-b049fe7b.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const html = document.documentElement;
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/linera-io/linera-documentation" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="images/linera_banner_db73e9b.svg" alt="The Linera banner" /></p>
<h1 id="the-linera-manual"><a class="header" href="#the-linera-manual">The Linera Manual</a></h1>
<p>Welcome to the Linera manual, a decentralized protocol designed for <strong>highly
scalable, low-latency Web3 applications</strong>.</p>
<p>The documentation is split into two parts:</p>
<ol>
<li>The <a href="developers.html">Developers</a> section is intended for developers who wish
to learn more about Linera and its programming model by prototyping
applications using the Linera Rust SDK.</li>
<li>The <a href="operators.html">Operators</a> section is intended for operators who wish to
run Linera validators.</li>
</ol>
<blockquote>
<p><strong>NEW: Publish and test your Web3 application on the Linera Testnet!</strong></p>
<p>Install
<a href="developers/getting_started/installation.html#installing-from-cratesio">the Linera CLI tool</a>
then follow the instructions on
<a href="developers/getting_started/hello_linera.html#using-the-testnet">this page</a> to
claim a microchain and publish your first application on the current Testnet.</p>
</blockquote>
<p>To join our community and get involved in the development of the Linera
ecosystem, check out our
<a href="https://github.com/linera-io/linera-protocol">GitHub repository</a>, our
<a href="https://linera.io">Website</a>, and find us on social media channels such as
<a href="https://www.youtube.com/@linera_io">YouTube</a>, <a href="https://x.com/linera_io">X</a>,
<a href="https://t.me/linera_official">Telegram</a>, and
<a href="https://discord.gg/linera">Discord</a>.</p>
<p>Let's get started!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="developer-manual"><a class="header" href="#developer-manual">Developer Manual</a></h1>
<p>This section of the Linera Manual is for developers building applications on
Linera.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>In this section, we will cover the necessary steps to install the Linera
toolchain and give a short example to get started with the Linera SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>Let's start with the installation of the Linera development tools.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>The Linera toolchain consists of two crates:</p>
<ul>
<li>
<p><code>linera-sdk</code> is the main library to program Linera applications in Rust.</p>
</li>
<li>
<p><code>linera-service</code> defines a number of binaries, including:</p>
<ul>
<li><code>linera</code> -- the main client tool, used to operate development wallets,</li>
<li><code>linera-proxy</code> -- the proxy service, acting as a public entrypoint for each
validator,</li>
<li><code>linera-server</code> -- the service run by each worker of a validator, hidden
behind the proxy.</li>
</ul>
</li>
</ul>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>The operating systems currently supported by the Linera toolchain can be
summarized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Linux x86 64-bit</th><th>Mac OS (M1 / M2)</th><th>Mac OS (x86)</th><th>Windows</th></tr></thead><tbody>
<tr><td>✓ Main platform</td><td>✓ Working</td><td>✓ Working</td><td>Untested</td></tr>
</tbody></table>
</div>
<p>The main prerequisites to install the Linera toolchain are Rust, Wasm, and
Protoc. They can be installed as follows on Linux:</p>
<ul>
<li>
<p>Rust and Wasm</p>
<ul>
<li><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li><code>rustup target add wasm32-unknown-unknown</code></li>
</ul>
</li>
<li>
<p>Protoc</p>
<ul>
<li><code>curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protoc-21.11-linux-x86_64.zip</code></li>
<li><code>unzip protoc-21.11-linux-x86_64.zip -d $HOME/.local</code></li>
<li>If <code>~/.local</code> is not in your path, add it:
<code>export PATH="$HOME/.local/bin:$PATH"</code></li>
</ul>
</li>
<li>
<p>On certain Linux distributions, you may have to install development packages
such as <code>g++</code>, <code>libclang-dev</code> and <code>libssl-dev</code>.</p>
</li>
</ul>
<p>For MacOS support and for additional requirements needed to test the Linera
protocol itself, see the installation section on
<a href="https://github.com/linera-io/linera-protocol/blob/main/INSTALL.md">GitHub</a>.</p>
<p>This manual was tested with the following Rust toolchain:</p>
<pre><code class="language-text">[toolchain]
channel = "1.81.0"
components = [ "clippy", "rustfmt", "rust-src" ]
targets = [ "wasm32-unknown-unknown" ]
profile = "minimal"
</code></pre>
<h2 id="installing-from-cratesio"><a class="header" href="#installing-from-cratesio">Installing from crates.io</a></h2>
<p>You may install the Linera binaries with</p>
<pre><code class="language-bash">cargo install --locked linera-storage-service@0.13.1
cargo install --locked linera-service@0.13.1 --features storage-service
</code></pre>
<p>and use <code>linera-sdk</code> as a library for Linera Wasm applications:</p>
<pre><code class="language-bash">cargo add linera-sdk@0.13.1
</code></pre>
<p>The version number <code>0.13.1</code> corresponds to the
current Testnet of Linera. The minor version may change frequently but should
not induce breaking changes.</p>
<h2 id="installing-from-github"><a class="header" href="#installing-from-github">Installing from GitHub</a></h2>
<p>Download the source from <a href="https://github.com/linera-io/linera-protocol">GitHub</a>:</p>
<pre><code class="language-bash">git clone https://github.com/linera-io/linera-protocol.git
cd linera-protocol
git checkout -t origin/testnet_archimedes  # Current release branch
</code></pre>
<p>To install the Linera toolchain locally from source, you may run:</p>
<pre><code class="language-bash">cargo install --locked --path linera-storage-service
cargo install --locked --path linera-service --features storage-service
</code></pre>
<p>Alternatively, for developing and debugging, you may instead use the binaries
compiled in debug mode, e.g. using <code>export PATH="$PWD/target/debug:$PATH"</code>.</p>
<p>This manual was tested against the following commit of the
<a href="https://github.com/linera-io/linera-protocol">repository</a>:</p>
<pre><code class="language-text">f84b66720b92b2eab86622e26b56c3aa2adbc0c0
</code></pre>
<h2 id="bash-helper-optional"><a class="header" href="#bash-helper-optional">Bash helper (optional)</a></h2>
<p>Consider adding the output of <code>linera net helper</code> to your <code>~/.bash_profile</code> to
help with <a href="developers/getting_started/../core_concepts/wallets.html#automation-in-bash">automation</a>.</p>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting help</a></h2>
<p>If installation fails, reach out to the team (e.g. on
<a href="https://discord.gg/linera">Discord</a>) to help troubleshoot your issue or
<a href="https://github.com/linera-io/linera-protocol/issues/new">create an issue</a> on
GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-linera"><a class="header" href="#hello-linera">Hello, Linera</a></h1>
<p>In this section, you will learn how to interact with the current Testnet, run a
local development network, then compile and deploy your first application from
scratch.</p>
<p>By the end of this section, you will have a
<a href="developers/getting_started/../core_concepts/microchains.html">microchain</a> on the Testnet and/or on your
local network, and a working application that can be queried using GraphQL.</p>
<h2 id="using-the-testnet"><a class="header" href="#using-the-testnet">Using the Testnet</a></h2>
<p>The Linera Testnet is a deployment of the Linera protocol useful for developers
and able to host applications.</p>
<blockquote>
<p>The current Testnet (codename "Archimedes") is the first deployment of Linera
run in partnership with external validators. While it should be considered
stable, it will be replaced by a new Testnet when needed. The next Linera
Testnet will be restarted from a clean slate and a new genesis block.</p>
</blockquote>
<p>To interact with the Testnet, some tokens are needed. A Faucet service is
available to create new microchains and obtain some test tokens. To do so, this
must be configured when initializing the wallet:</p>
<pre><code class="language-bash">linera wallet init --with-new-chain --faucet https://faucet.testnet-archimedes.linera.net
</code></pre>
<p>This creates a new microchain on Testnet with some initial test tokens, and the
chain is automatically added to the newly instantiated wallet.</p>
<blockquote>
<p>Make sure to use a Linera toolchain
<a href="developers/getting_started/installation.html#installing-from-cratesio">compatible with the current Testnet</a>.</p>
</blockquote>
<h2 id="starting-a-local-test-network"><a class="header" href="#starting-a-local-test-network">Starting a Local Test Network</a></h2>
<p>Another option is to start your own local development network. A development
network consists of a number of <a href="developers/getting_started/../advanced_topics/validators.html">validators</a>,
each of which consists of an ingress proxy (aka. a "load balancer") and a number
of workers (aka. "physical shards").</p>
<p>To start a local network, run the following command:</p>
<pre><code class="language-bash">linera net up
</code></pre>
<p>This will start a validator with the default number of shards and create a
temporary directory storing the entire network state.</p>
<p>This will set up a number of initial chains and create an initial wallet to
operate them.</p>
<h3 id="using-the-initial-test-wallet"><a class="header" href="#using-the-initial-test-wallet">Using the Initial Test Wallet</a></h3>
<p><code>linera net up</code> prints Bash statements on its standard output to help you
configure your terminal to use the initial wallet of the new test network, for
instance:</p>
<pre><code class="language-bash">export LINERA_WALLET="/var/folders/3d/406tbklx3zx2p3_hzzpfqdbc0000gn/T/.tmpvJ6lJI/wallet.json"
export LINERA_STORAGE="rocksdb:/var/folders/3d/406tbklx3zx2p3_hzzpfqdbc0000gn/T/.tmpvJ6lJI/linera.db"
</code></pre>
<p>This wallet is only valid for the lifetime of a single network. Every time a
local network is restarted, the wallet needs to be reconfigured.</p>
<h2 id="interacting-with-the-network"><a class="header" href="#interacting-with-the-network">Interacting with the Network</a></h2>
<blockquote>
<p>In the following examples, we assume that either the wallet was initialized to
interact with the Devnet or the variables <code>LINERA_WALLET</code> and <code>LINERA_STORAGE</code>
are both set and point to the initial wallet of the running local network.</p>
</blockquote>
<p>The main way of interacting with the network and deploying applications is using
the <code>linera</code> client.</p>
<p>To check that the network is working, you can synchronize your
<a href="developers/getting_started/../core_concepts/wallets.html">default chain</a> with the rest of the network and
display the chain balance as follows:</p>
<pre><code class="language-bash">linera sync
linera query-balance
</code></pre>
<p>You should see an output number, e.g. <code>10</code>.</p>
<h2 id="building-an-example-application"><a class="header" href="#building-an-example-application">Building an Example Application</a></h2>
<p>Applications running on Linera are <a href="https://webassembly.org/">Wasm</a> bytecode.
Each validator and client has a built-in Wasm virtual machine (VM) which can
execute bytecode.</p>
<p>Let's build the <code>counter</code> application from the <code>examples/</code> subdirectory:</p>
<pre><code class="language-bash">cd examples/counter &amp;&amp; cargo build --release --target wasm32-unknown-unknown
</code></pre>
<h2 id="publishing-your-application"><a class="header" href="#publishing-your-application">Publishing your Application</a></h2>
<p>You can publish the bytecode and create an application using it on your local
network using the <code>linera</code> client's <code>publish-and-create</code> command and provide:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  ../target/wasm32-unknown-unknown/release/counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<p>Congratulations! You've published your first application on Linera!</p>
<h2 id="querying-your-application"><a class="header" href="#querying-your-application">Querying your Application</a></h2>
<p>Now let's query your application to get the current counter value. To do that,
we need to use the client running in
<a href="developers/getting_started/../core_concepts/node_service.html"><em>service</em> mode</a>. This will expose a bunch of
APIs locally which we can use to interact with applications on the network.</p>
<pre><code class="language-bash">linera service
</code></pre>
<!-- TODO: add graphiql image here -->
<p>Navigate to <code>http://localhost:8080</code> in your browser to access GraphiQL, the
<a href="https://graphql.org">GraphQL</a> IDE. We'll look at this in more detail in a
<a href="developers/getting_started/../core_concepts/node_service.html#graphiql-ide">later section</a>; for now, list
the applications deployed on your default chain e476… by running:</p>
<pre><code class="language-gql">query {
  applications(
    chainId: "e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65"
  ) {
    id
    description
    link
  }
}
</code></pre>
<p>Since we've only deployed one application, the results returned have a single
entry.</p>
<p>At the bottom of the returned JSON there is a field <code>link</code>. To interact with
your application copy and paste the link into a new browser tab.</p>
<p>Finally, to query the counter value, run:</p>
<pre><code class="language-gql">query {
  value
}
</code></pre>
<p>This will return a value of <code>42</code>, which is the initialization argument we
specified when deploying our application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-linera-protocol"><a class="header" href="#the-linera-protocol">The Linera Protocol</a></h1>
<p>We now describe the main concepts of the Linera protocol in more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview-1"><a class="header" href="#overview-1">Overview</a></h1>
<p>Linera is a decentralized infrastructure optimized for Web3 applications that
require guaranteed performance for an unlimited number of active users.</p>
<p>The core idea of the Linera protocol is to run many lightweight blockchains,
called <strong>microchains</strong>, in parallel in a single set of validators.</p>
<h2 id="how-does-it-work"><a class="header" href="#how-does-it-work">How does it work?</a></h2>
<p>In Linera, user wallets operate their own microchains. The owner of a chain
chooses when to add new blocks to the chain and what goes inside the blocks.
Such chains with a single user are called <strong>user chains</strong>.</p>
<p>Users may add new blocks to their chains in order to process <strong>incoming
messages</strong> from other chains or to execute secure <strong>operations</strong> on their
accounts, for instance to transfer assets to another user.</p>
<p>Importantly, validators ensure that all new blocks are <strong>valid</strong>. For instance,
transfer operations must originate from accounts with sufficient funds; and
incoming messages must have been actually sent from another chain. Blocks are
verified by validators in the same way for every chain.</p>
<p>A Linera <strong>application</strong> is a Wasm program that defines its own state and
operations. Users can publish bytecode and initialize an application on one
chain, and it will be automatically deployed to all chains where it is needed,
with a separate state on each chain.</p>
<p>To ensure coordination across chains, an application may rely on asynchronous
<strong>cross-chain messages</strong>. Message payloads are application-specific and opaque
to the rest of the system.</p>
<pre><code class="language-ignore">                               ┌───┐     ┌───┐     ┌───┐
                       Chain A │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
                                                     ▲
                                           ┌─────────┘
                                           │
                               ┌───┐     ┌─┴─┐     ┌───┐
                       Chain B │   ├────►│   ├────►│   │
                               └───┘     └─┬─┘     └───┘
                                           │         ▲
                                           │         │
                                           ▼         │
                               ┌───┐     ┌───┐     ┌─┴─┐
                       Chain C │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
</code></pre>
<p>The number of applications present on a single chain is not limited. On the same
chain, applications are <strong>composed</strong> as usual using synchronous calls.</p>
<p>The current Linera SDK uses <strong>Rust</strong> as a source language to create Wasm
applications. It relies on the normal Rust toolchains so that Rust programmers
can work in their preferred environments.</p>
<h2 id="how-does-linera-compare-to-existing-multi-chain-infrastructure"><a class="header" href="#how-does-linera-compare-to-existing-multi-chain-infrastructure">How does Linera compare to existing multi-chain infrastructure?</a></h2>
<p>Linera is the first infrastructure designed to support many chains in parallel,
and notably an arbitrary number of <strong>user chains</strong> meant to be operated by user
wallets.</p>
<p>In traditional multi-chain infrastructures, each chain usually runs a full
blockchain protocol in a separate set of validators. Creating a new chain or
exchanging messages between chains is expensive. As a result, the total number
of chains is generally limited. Some chains may be specialized to a given use
case: these are called "app chains".</p>
<p>In contrast, Linera is optimized for a large number of user chains:</p>
<ul>
<li>
<p>Users only create blocks in their chain when needed;</p>
</li>
<li>
<p>Creating a microchain does not require onboarding validators;</p>
</li>
<li>
<p>All chains have the same level of security;</p>
</li>
<li>
<p>Microchains communicate efficiently using the internal networks of validators;</p>
</li>
<li>
<p>Validators are internally sharded (like a regular web service) and may adjust
their capacity elastically by adding or removing internal workers.</p>
</li>
</ul>
<blockquote>
<p>Besides user chains, the <a href="https://linera.io/whitepaper">Linera protocol</a> is
designed to support other types of microchains, called "permissioned" and
"public" chains. Public chains are operated by validators. In this regard,
they are similar to classical blockchains. Permissioned chains are meant to be
used for temporary interactions between users, such as atomic swaps.</p>
</blockquote>
<h2 id="why-build-on-top-of-linera"><a class="header" href="#why-build-on-top-of-linera">Why build on top of Linera?</a></h2>
<p>We believe that many high-value use cases are currently out of reach of existing
Web3 infrastructures because of the challenges of serving <strong>many active users</strong>
simultaneously without degrading user experience (unpredictable fees, latency,
etc).</p>
<p>Examples of applications that require processing time-sensitive transactions
created by many simultaneous users include:</p>
<ul>
<li>
<p>real-time micro-payments and micro-rewards,</p>
</li>
<li>
<p>social data feeds,</p>
</li>
<li>
<p>real-time auction systems,</p>
</li>
<li>
<p>turn-based games,</p>
</li>
<li>
<p>version control systems for software, data pipelines, or AI training
pipelines.</p>
</li>
</ul>
<p>Lightweight user chains are instrumental in providing elastic scalability but
they have other benefits as well. Because user chains have fewer blocks than
traditional blockchains, in Linera, the full-nodes of user chains will be
embedded into the users' wallets, typically deployed as a browser extension.</p>
<p>This means that Web UIs connected to a wallet will be able to query the state of
the user chain directly (no API provider, no light client) using familiar
frameworks (React/GraphQL). Furthermore, wallets will be able to leverage the
full node as well for security purposes, including to display meaningful
confirmation messages to users.</p>
<h2 id="what-is-the-current-state-of-the-development-of-linera"><a class="header" href="#what-is-the-current-state-of-the-development-of-linera">What is the current state of the development of Linera?</a></h2>
<p>The
<a href="https://github.com/linera-io/linera-protocol">reference open-source implementation</a>
of Linera is under active development. It already includes a Web3 SDK with the
necessary features to prototype simple Web3 applications and test them locally
on the same machine and deploying them to the Devnet.</p>
<p>Web UIs (possibly reactive) can already be built on top of Wasm-embedded GraphQL
services, and tested locally in the browser.</p>
<p>The main limitations of our current Web3 SDK include:</p>
<ul>
<li>
<p>Web UIs need to query a local HTTP service acting as a wallet. This setup is
meant to be temporary and for testing only: in the future, web UIs will
securely connect to a Wallet installed as a browser extension, as usual.</p>
</li>
<li>
<p>Only user chains are currently documented in this manual. Permissioned chains
(aka "temporary" chains) were recently added. Support for public chains is in
progress.</p>
</li>
</ul>
<p>The main development workstreams of Linera, beyond its SDK, can be broken down
as follows.</p>
<h3 id="core-protocol"><a class="header" href="#core-protocol">Core Protocol</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
User chains</li>
<li><input disabled="" type="checkbox" checked=""/>
Permissioned chains (core protocol only)</li>
<li><input disabled="" type="checkbox" checked=""/>
Cross-chain messages</li>
<li><input disabled="" type="checkbox" checked=""/>
Cross-chain pub/sub channels (initial version)</li>
<li><input disabled="" type="checkbox" checked=""/>
Bytecode publishing</li>
<li><input disabled="" type="checkbox" checked=""/>
Application creation</li>
<li><input disabled="" type="checkbox" checked=""/>
Reconfigurations of validators</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for gas fees</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for storage fees and storage limits</li>
<li><input disabled="" type="checkbox" checked=""/>
External service (aka. "Faucet") to help users create their first chain</li>
<li><input disabled="" type="checkbox" checked=""/>
Permissioned chains (adding operation access control, demo of atomic
swaps, etc)</li>
<li><input disabled="" type="checkbox" checked=""/>
Avoid repeatedly loading chain states from storage</li>
<li><input disabled="" type="checkbox" checked=""/>
Blob storage usable by system and user applications
(generalizing/replacing bytecode storage)</li>
<li><input disabled="" type="checkbox"/>
Support for easy onboarding of user chains into a new application
(removing the need to accept requests)</li>
<li><input disabled="" type="checkbox"/>
Replace pub/sub channels with data streams (removing the need to accept
subscriptions)</li>
<li><input disabled="" type="checkbox"/>
Allow chain clients to control which chains they track (lazily/actively)
and execute (do not execute all tracked chains)</li>
<li><input disabled="" type="checkbox"/>
Multi-signed events to facilitate future bridges to external chains</li>
<li><input disabled="" type="checkbox"/>
Public chains (adding leader election, inbox constraints, etc)</li>
<li><input disabled="" type="checkbox"/>
Transaction scripts</li>
<li><input disabled="" type="checkbox"/>
Support for dynamic shard assignment</li>
<li><input disabled="" type="checkbox"/>
Support for archiving chains</li>
<li><input disabled="" type="checkbox"/>
Tokenomics and incentives for all stakeholders</li>
<li><input disabled="" type="checkbox"/>
Governance on the admin chain (e.g. DPoS, onboarding of validators)</li>
<li><input disabled="" type="checkbox"/>
Permissionless auditing protocol</li>
</ul>
<h3 id="wasm-vm-integration"><a class="header" href="#wasm-vm-integration">Wasm VM integration</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Support for the Wasmer VM</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for the Wasmtime VM (experimental)</li>
<li><input disabled="" type="checkbox" checked=""/>
Test gas metering and deterministic execution across VMs</li>
<li><input disabled="" type="checkbox" checked=""/>
Composing Wasm applications on the same chain</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for non-blocking (yet deterministic) calls to storage</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for read-only GraphQL services in Wasm</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for mocked system APIs</li>
<li><input disabled="" type="checkbox" checked=""/>
Improve host/guest stub generation to make mocks easier</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for running Wasm applications in the browser</li>
</ul>
<h3 id="storage"><a class="header" href="#storage">Storage</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Object management library ("linera-views") on top of Key-Value store
abstraction</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for Rocksdb</li>
<li><input disabled="" type="checkbox" checked=""/>
Experimental support for DynamoDB</li>
<li><input disabled="" type="checkbox" checked=""/>
Derive macros for GraphQL</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for ScyllaDB</li>
<li><input disabled="" type="checkbox" checked=""/>
Make library fully extensible by users (requires better GraphQL macros)</li>
<li><input disabled="" type="checkbox" checked=""/>
In-memory storage service for testing purposes</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for Web storage (IndexedDB)</li>
<li><input disabled="" type="checkbox"/>
Performance benchmarks and improvements (including faster state hashing)</li>
<li><input disabled="" type="checkbox"/>
Better configuration management</li>
<li><input disabled="" type="checkbox"/>
Local Write-Ahead Log</li>
<li><input disabled="" type="checkbox"/>
Production-grade support for the chosen main database</li>
<li><input disabled="" type="checkbox"/>
Tooling for debugging</li>
<li><input disabled="" type="checkbox"/>
Make the storage library easy to use outside of Linera</li>
</ul>
<h3 id="validator-infrastructure"><a class="header" href="#validator-infrastructure">Validator Infrastructure</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Simple TCP/UDP networking (used for benchmarks only)</li>
<li><input disabled="" type="checkbox" checked=""/>
GRPC networking</li>
<li><input disabled="" type="checkbox" checked=""/>
Basic frontend (aka. proxy) supporting fixed internal shards</li>
<li><input disabled="" type="checkbox" checked=""/>
Observability</li>
<li><input disabled="" type="checkbox" checked=""/>
Kubernetes support in CI</li>
<li><input disabled="" type="checkbox" checked=""/>
Deployment using a cloud provider</li>
<li><input disabled="" type="checkbox"/>
Horizontally scalable frontend (aka. proxy)</li>
<li><input disabled="" type="checkbox"/>
Dynamic shard assignment</li>
<li><input disabled="" type="checkbox"/>
Cloud integration to demonstrate elastic scaling</li>
</ul>
<h3 id="web3-sdk"><a class="header" href="#web3-sdk">Web3 SDK</a></h3>
<ul>
<li><input disabled="" type="checkbox" checked=""/>
Traits for contract and service interfaces</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for unit testing</li>
<li><input disabled="" type="checkbox" checked=""/>
Support for integration testing</li>
<li><input disabled="" type="checkbox" checked=""/>
Local GraphQL service to query and browse system state</li>
<li><input disabled="" type="checkbox" checked=""/>
Local GraphQL service to query and browse application states</li>
<li><input disabled="" type="checkbox" checked=""/>
Use GraphQL mutations to execute operations and create blocks</li>
<li><input disabled="" type="checkbox" checked=""/>
ABIs for contract and service interfaces</li>
<li><input disabled="" type="checkbox" checked=""/>
Allowing message sender to pay for message execution fees</li>
<li><input disabled="" type="checkbox" checked=""/>
Wallet as a browser extension (no VM)</li>
<li><input disabled="" type="checkbox" checked=""/>
Wallet as a browser extension (with Wasm VM)</li>
<li><input disabled="" type="checkbox"/>
Easier communication with EVM chains</li>
<li><input disabled="" type="checkbox"/>
Bindings to use native cryptographic primitives from Wasm</li>
<li><input disabled="" type="checkbox"/>
Allowing applications to pay for user fees</li>
<li><input disabled="" type="checkbox"/>
Allowing applications to use permissioned chains and public chains</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="microchains"><a class="header" href="#microchains">Microchains</a></h1>
<p>This section provides an introduction to microchains, the main building block of
the Linera Protocol. For a more formal treatment refer to the
<a href="https://linera.io/whitepaper">whitepaper</a>.</p>
<h2 id="background"><a class="header" href="#background">Background</a></h2>
<p>A <strong>microchain</strong> is a chain of blocks describing successive changes to a shared
state. We will use the terms <em>chain</em> and <em>microchain</em> interchangeably. Linera
microchains are similar to the familiar notion of blockchain, with the following
important specificities:</p>
<ul>
<li>
<p>An arbitrary number of microchains can coexist in a Linera network, all
sharing the same set of validators and the same level of security. Creating a
new microchain only takes one transaction on an existing chain.</p>
</li>
<li>
<p>The task of proposing new blocks in a microchain can be assumed either by
validators or by end users (or rather their wallets) depending on the
configuration of a chain. Specifically, microchains can be <em>single-owner</em>,
<em>permissioned</em>, or <em>public</em>, depending on who is authorized to propose blocks.</p>
</li>
</ul>
<h2 id="cross-chain-messaging"><a class="header" href="#cross-chain-messaging">Cross-Chain Messaging</a></h2>
<p>In traditional networks with a single blockchain, every transaction can access
the application's entire execution state. This is not the case in Linera where
the state of an application is spread across multiple microchains, and the state
on any individual microchain is only affected by the blocks of that microchain.</p>
<p>Cross-chain messaging is a way for different microchains to communicate with
each other asynchronously. This method allows applications and data to be
distributed across multiple chains for better scalability. When an application
on one chain sends a message to itself on another chain, a cross-chain request
is created. These requests are implemented using remote procedure calls (RPCs)
within the validators' internal network, ensuring that each request is executed
only once.</p>
<p>Instead of immediately modifying the target chain, messages are placed first in
the target chain's <strong>inbox</strong>. When an owner of the target chain creates its next
block in the future, they may reference a selection of messages taken from the
current inbox in the new block. This executes the selected messages and applies
their messages to the chain state.</p>
<p>Below is an example set of chains sending asynchronous messages to each other
over consecutive blocks.</p>
<pre><code class="language-ignore">                               ┌───┐     ┌───┐     ┌───┐
                       Chain A │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
                                                     ▲
                                           ┌─────────┘
                                           │
                               ┌───┐     ┌─┴─┐     ┌───┐
                       Chain B │   ├────►│   ├────►│   │
                               └───┘     └─┬─┘     └───┘
                                           │         ▲
                                           │         │
                                           ▼         │
                               ┌───┐     ┌───┐     ┌─┴─┐
                       Chain C │   ├────►│   ├────►│   │
                               └───┘     └───┘     └───┘
</code></pre>
<p>The Linera protocol allows receivers to discard messages but not to change the
ordering of selected messages inside the communication queue between two chains.
If a selected message fails to execute, the wallet will automatically reject it
when proposing the receiver's block. The current implementation of the Linera
client always selects as many messages as possible from inboxes, and never
discards messages unless they fail to execute.</p>
<h2 id="chain-ownership-semantics"><a class="header" href="#chain-ownership-semantics">Chain Ownership Semantics</a></h2>
<p>Active chains can have one or multiple owners. Chains with zero owners are
permanently deactivated.</p>
<p>In Linera, the validators guarantee <em>safety</em>: On each chain, at each height,
there is at most one unique block.</p>
<p>But <em>liveness</em>—actually adding blocks to a chain at all—relies on the owners.
There are different types of rounds and owners, optimized for different use
cases:</p>
<ul>
<li>First an optional <em>fast</em> round, where a <em>super owner</em> can propose blocks that
get confirmed with very particularly low latency, optimal for single-owner
chains with no contention.</li>
<li>Then a number of <em>multi-leader rounds</em>, where all <em>regular owners</em> can propose
blocks. This works well even if there is occasional, temporary contention: an
owner using multiple devices, or multiple people using the same chain
infrequently.</li>
<li>And finally <em>single-leader rounds</em>: These give each regular chain owner a time
slot in which only they can propose a new block, without being hindered by any
other owners' proposals. This is ideal for chains with many users that are
trying to commit blocks at the same time.</li>
</ul>
<p>The number of multi-leader rounds is configurable: On chains with fluctuating
levels of activity, this allows the system to dynamically switch to
single-leader mode whenever all multi-leader rounds fail during periods of high
contention. Chains that very often have high activity from multiple owners can
set the number of multi-leader rounds to 0.</p>
<p>For more detail and examples on how to open and close chains, see the wallet
section on <a href="developers/core_concepts/wallets.html#opening-a-chain">chain management</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallets"><a class="header" href="#wallets">Wallets</a></h1>
<p>As in traditional blockchains, Linera wallets are in charge of holding user
private keys. However, instead of signing transactions, Linera wallets are meant
to sign blocks and propose them to extend the chains owned by their users.</p>
<p>In practice, wallets include a node which tracks a subset of Linera chains. We
will see in the <a href="developers/core_concepts/node_service.html">next section</a> how a Linera wallet can run a
GraphQL service to expose the state of its chains to web frontends.</p>
<blockquote>
<p>The command-line tool <code>linera</code> is the main way for developers to interact with
a Linera network and manage the user wallets present locally on the system.</p>
</blockquote>
<p>Note that this command-line tool is intended mainly for development purposes.
Our goal is that end users eventually manage their wallets in a
<a href="developers/core_concepts/overview.html#web3-sdk">browser extension</a>.</p>
<h2 id="selecting-a-wallet"><a class="header" href="#selecting-a-wallet">Selecting a Wallet</a></h2>
<p>The private state of a wallet is conventionally stored in a file <code>wallet.json</code>,
while the state of its node is stored in a file <code>linera.db</code>.</p>
<p>To switch between wallets, you may use the <code>--wallet</code> and <code>--storage</code> options of
the <code>linera</code> tool, e.g. as in
<code>linera --wallet wallet2.json --storage rocksdb:linera2.db</code>.</p>
<p>You may also define the environment variables <code>LINERA_STORAGE</code> and
<code>LINERA_WALLET</code> to the same effect. E.g. <code>LINERA_STORAGE=$PWD/wallet2.json</code> and
<code>LINERA_WALLET=$PWD/wallet2.json</code>.</p>
<p>Finally, if <code>LINERA_STORAGE_$I</code> and <code>LINERA_WALLET_$I</code> are defined for some
number <code>I</code>, you may call <code>linera --with-wallet $I</code> (or <code>linera -w $I</code> for
short).</p>
<h2 id="chain-management"><a class="header" href="#chain-management">Chain Management</a></h2>
<h3 id="listing-chains"><a class="header" href="#listing-chains">Listing Chains</a></h3>
<p>To list the chains present in your wallet, you may use the command <code>show</code>:</p>
<pre><code class="language-bash">linera wallet show
╭──────────────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────────────────────────────────╮
│ Chain ID                                                         ┆ Latest Block                                                                         │
╞══════════════════════════════════════════════════════════════════╪══════════════════════════════════════════════════════════════════════════════════════╡
│ 668774d6f49d0426f610ad0bfa22d2a06f5f5b7b5c045b84a26286ba6bce93b4 ┆ Public Key:         3812c2bf764e905a3b130a754e7709fe2fc725c0ee346cb15d6d261e4f30b8f1 │
│                                                                  ┆ Owner:              c9a538585667076981abfe99902bac9f4be93714854281b652d07bb6d444cb76 │
│                                                                  ┆ Block Hash:         -                                                                │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:20.820840                                       │
│                                                                  ┆ Next Block Height:  0                                                                │
├╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┼╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┤
│ 91c7b394ef500cd000e365807b770d5b76a6e8c9c2f2af8e58c205e521b5f646 ┆ Public Key:         29c19718a26cb0d5c1d28102a2836442f53e3184f33b619ff653447280ccba1a │
│                                                                  ┆ Owner:              efe0f66451f2f15c33a409dfecdf76941cf1e215c5482d632c84a2573a1474e8 │
│                                                                  ┆ Block Hash:         51605cad3f6a210183ac99f7f6ef507d0870d0c3a3858058034cfc0e3e541c13 │
│                                                                  ┆ Timestamp:          2023-04-10 13:52:21.885221                                       │
│                                                                  ┆ Next Block Height:  1                                                                │
╰──────────────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────────────────────────────────╯

</code></pre>
<p>Each row represents a chain present in the wallet. On the left is the unique
identifier on the chain, and on the right is metadata for that chain associated
with the latest block.</p>
<h3 id="default-chain"><a class="header" href="#default-chain">Default Chain</a></h3>
<p>Each wallet has a default chain that all commands apply to unless you specify
another <code>--chain</code> on the command line.</p>
<p>The default chain is set initially, when the first chain is added to the wallet.
You can check the default chain for your wallet by running:</p>
<pre><code class="language-bash">linera wallet show
</code></pre>
<p>The Chain ID which is in green text instead of white text is your default chain.</p>
<p>To change the default chain for your wallet, use the <code>set-default</code> command:</p>
<pre><code class="language-bash">linera wallet set-default &lt;chain-id&gt;
</code></pre>
<h3 id="opening-a-chain"><a class="header" href="#opening-a-chain">Opening a Chain</a></h3>
<p>The Linera protocol defines semantics for how new chains are created, we call
this "opening a chain". A chain cannot be opened in a vacuum, it needs to be
created by an existing chain on the network.</p>
<h4 id="open-a-chain-for-your-own-wallet"><a class="header" href="#open-a-chain-for-your-own-wallet">Open a Chain for Your Own Wallet</a></h4>
<p>To open a chain for your own wallet, you can use the <code>open-chain</code> command:</p>
<pre><code class="language-bash">linera open-chain
</code></pre>
<p>This will create a new chain (using the wallet's default chain) and add it to
the wallet. Use the <code>wallet show</code> command to see your existing chains.</p>
<h4 id="open-a-chain-for-another-wallet"><a class="header" href="#open-a-chain-for-another-wallet">Open a Chain for Another Wallet</a></h4>
<p>Opening a chain for another <code>wallet</code> requires an extra two steps. Let's
initialize a second wallet:</p>
<pre><code class="language-bash">linera --wallet wallet2.json --storage rocksdb:linera2.db wallet init --genesis target/debug/genesis.json
</code></pre>
<p>First <code>wallet2</code> must create an unassigned keypair. The public part of that
keypair is then sent to the <code>wallet</code> who is the chain creator.</p>
<pre><code class="language-bash">linera --wallet wallet2.json keygen
6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 # this is the public key for the unassigned keypair
</code></pre>
<p>Next, using the public key, <code>wallet</code> can open a chain for <code>wallet2</code>.</p>
<pre><code class="language-bash">linera open-chain --to-public-key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888
e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000
fc9384defb0bcd8f6e206ffda32599e24ba715f45ec88d4ac81ec47eb84fa111
</code></pre>
<p>The first line is the message ID specifying the cross-chain message that creates
the new chain. The second line is the new chain's ID.</p>
<p>Finally, to add the chain to <code>wallet2</code> for the given unassigned key we use the
<code>assign</code> command:</p>
<pre><code class="language-bash"> linera --wallet wallet2.json assign --key 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 --message-id e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000
</code></pre>
<h4 id="opening-a-chain-with-multiple-users"><a class="header" href="#opening-a-chain-with-multiple-users">Opening a Chain with Multiple Users</a></h4>
<p>The <code>open-chain</code> command is a simplified version of <code>open-multi-owner-chain</code>,
which gives you fine-grained control over the set and kinds of owners and rounds
for the new chain, and the timeout settings for the rounds. E.g. this creates a
chain with two owners and two multi-leader rounds.</p>
<pre><code class="language-bash">linera open-multi-owner-chain \
    --chain-id e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65010000000000000000000000 \
    --owner-public-keys 6443634d872afbbfcc3059ac87992c4029fa88e8feb0fff0723ac6c914088888 \
                        ca909dcf60df014c166be17eb4a9f6e2f9383314a57510206a54cd841ade455e \
    --multi-leader-rounds 2
</code></pre>
<p>The <code>change-ownership</code> command offers the same options to add or remove owners
and change round settings for an existing chain.</p>
<h2 id="setting-up-extra-wallets-automatically-with-linera-net-up"><a class="header" href="#setting-up-extra-wallets-automatically-with-linera-net-up">Setting up Extra Wallets Automatically with <code>linera net up</code></a></h2>
<p>For testing, rather than using <code>linera open-chain</code> and <code>linera assign</code> as above,
it is often more convenient to pass the option <code>--extra-wallets N</code> to
<code>linera net up</code>.</p>
<p>This option will create <code>N</code> additional user wallets and output Bash commands to
define the environment variables <code>LINERA_{WALLET,STORAGE}_$I</code> where <code>I</code> ranges
over <code>0..=N</code> (<code>I=0</code> being the wallet for the initial chains).</p>
<p>Once all the environment variables are defined, you may switch between wallets
using <code>linera --with-wallet I</code> or <code>linera -w I</code> for short.</p>
<h2 id="automation-in-bash"><a class="header" href="#automation-in-bash">Automation in Bash</a></h2>
<p>To automate the process of setting the variables <code>LINERA_WALLET*</code> and
<code>LINERA_STORAGE*</code> after creating a local test network in a shell, we provide a
Bash helper function <code>linera_spawn_and_read_wallet_variables</code>.</p>
<p>To define the function <code>linera_spawn_and_read_wallet_variables</code> in your shell,
run <code>source /dev/stdin &lt;&lt;&lt;"$(linera net helper 2&gt;/dev/null)"</code>. You may also add
the output of <code>linera net helper</code> to your <code>~/.bash_profile</code> for future sessions.</p>
<p>Once the function is defined, call
<code>linera_spawn_and_read_wallet_variables linera net up</code> instead of
<code>linera net up</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-service"><a class="header" href="#node-service">Node Service</a></h1>
<p>So far we've seen how to use the Linera client treating it as a binary in your
terminal. However, the client also acts as a node which:</p>
<ol>
<li>Executes blocks</li>
<li>Exposes a GraphQL API and IDE for dynamically interacting with applications
and the system</li>
<li>Listens for notifications from validators and automatically updates local
chains.</li>
</ol>
<p>To interact with the node service, run <code>linera</code> in <code>service</code> mode:</p>
<pre><code class="language-bash">linera service
</code></pre>
<p>This will run the node service on port 8080 by default (this can be overridden
using the <code>--port</code> flag).</p>
<h2 id="a-note-on-graphql"><a class="header" href="#a-note-on-graphql">A Note on GraphQL</a></h2>
<p>Linera uses GraphQL as the query language for interfacing with different parts
of the system. GraphQL enables clients to craft queries such that they receive
exactly what they want and nothing more.</p>
<p>GraphQL is used extensively during application development, especially to query
the state of an application from a front-end for example.</p>
<p>To learn more about GraphQL check out the
<a href="https://graphql.org/learn/">official docs</a>.</p>
<h2 id="graphiql-ide"><a class="header" href="#graphiql-ide">GraphiQL IDE</a></h2>
<p>Conveniently, the node service exposes a GraphQL IDE called GraphiQL. To use
GraphiQL start the node service and navigate to <code>localhost:8080/</code>.</p>
<p>Using the schema explorer on the left of the GraphiQL IDE you can dynamically
explore the state of the system and your applications.</p>
<p><img src="developers/core_concepts/graphiql.png" alt="graphiql.png" /></p>
<h2 id="graphql-system-api"><a class="header" href="#graphql-system-api">GraphQL System API</a></h2>
<p>The node service also exposes a GraphQL API which corresponds to the set of
system operations. You can explore the full set of operations by clicking on
<code>MutationRoot</code>.</p>
<h2 id="graphql-application-api"><a class="header" href="#graphql-application-api">GraphQL Application API</a></h2>
<p>To interact with an application, we run the Linera client in service mode. It
exposes a GraphQL API for every application running on any owned chain at
<code>localhost:8080/chains/&lt;chain-id&gt;/applications/&lt;application-id&gt;</code>.</p>
<p>Navigating there with your browser will open a GraphiQL interface which enables
you to graphically explore the state of your application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications"><a class="header" href="#applications">Applications</a></h1>
<p>The programming model of Linera is designed so that developers can take
advantage of microchains to scale their applications.</p>
<p>Linera uses the <a href="https://webassembly.org">WebAssembly (Wasm)</a> Virtual Machine to
execute user applications. Currently, the <a href="developers/core_concepts/../sdk.html">Linera SDK</a> is focused on
the <a href="https://www.rust-lang.org/">Rust</a> programming language.</p>
<p>Linera applications are structured using the familiar notion of <strong>Rust crate</strong>:
the external interfaces of an application (including instantiation parameters,
operations and messages) generally go into the library part of its crate, while
the core of each application is compiled into binary files for the Wasm
architecture.</p>
<h2 id="the-application-deployment-lifecycle"><a class="header" href="#the-application-deployment-lifecycle">The Application Deployment Lifecycle</a></h2>
<p>Linera Applications are designed to be powerful yet re-usable. For this reason
there is a distinction between the bytecode and an application instance on the
network.</p>
<p>Applications undergo a lifecycle transition aimed at making development easy and
flexible:</p>
<ol>
<li>The bytecode is built from a Rust project with the <code>linera-sdk</code> dependency.</li>
<li>The bytecode is published to the network on a microchain, and assigned an
identifier.</li>
<li>A user can create a new application instance, by providing the bytecode
identifier and instantiation arguments. This process returns an application
identifier which can be used to reference and interact with the application.</li>
<li>The same bytecode identifier can be used as many times needed by as many
users needed to create distinct applications.</li>
</ol>
<p>Importantly, the application deployment lifecycle is abstracted from the user,
and an application can be published with a single command:</p>
<pre><code class="language-bash">linera publish-and-create &lt;contract-path&gt; &lt;service-path&gt; &lt;init-args&gt;
</code></pre>
<p>This will publish the bytecode as well as instantiate the application for you.</p>
<h2 id="anatomy-of-an-application"><a class="header" href="#anatomy-of-an-application">Anatomy of an Application</a></h2>
<p>An <strong>application</strong> is broken into two major components, the <em>contract</em> and the
<em>service</em>.</p>
<p>The <strong>contract</strong> is gas-metered, and is the part of the application which
executes operations and messages, make cross-application calls and modifies the
application's state. The details are covered in more depth in the
<a href="developers/core_concepts/../sdk.html">SDK docs</a>.</p>
<p>The <strong>service</strong> is non-metered and read-only. It is used primarily to query the
state of an application and populate the presentation layer (think front-end)
with the data required for a user interface.</p>
<h2 id="operations-and-messages"><a class="header" href="#operations-and-messages">Operations and Messages</a></h2>
<blockquote>
<p>For this section we'll be using a simplified version of the example
application called "fungible" where users can send tokens to each other.</p>
</blockquote>
<p>At the system-level, interacting with an application can be done via operations
and messages.</p>
<p><strong>Operations</strong> are defined by an application developer and each application can
have a completely different set of operations. Chain owners then actively create
operations and put them in their block proposals to interact with an
application. Other applications may also call the application by providing an
operation for it to execute, this is called a cross-application call and always
happens within the same chain. Operations for cross-application calls may return
a response value back to the caller.</p>
<p>Taking the "fungible token" application as an example, an operation for a user
to transfer funds to another user would look like this:</p>
<pre><code class="language-rust"><span class="boring">extern crate serde;
</span><span class="boring">extern crate linera_sdk;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use linera_sdk::base::*;
</span>#[derive(Debug, Deserialize, Serialize)]
pub enum Operation {
    /// A transfer from a (locally owned) account to a (possibly remote) account.
    Transfer {
        owner: AccountOwner,
        amount: Amount,
        target_account: Account,
    },
    // Meant to be extended here
}</code></pre>
<p><strong>Messages</strong> result from the execution of operations or other messages. Messages
can be sent from one chain to another, always within the same application. Block
proposers also actively include messages in their block proposal, but unlike
with operations, they are only allowed to include them in the right order
(possibly skipping some), and only if they were actually created by another
chain (or by a previous block of the same chain). Messages that originate from
the same transaction are included as a single transaction in the receiving
block.</p>
<p>In our "fungible token" application, a message to credit an account would look
like this:</p>
<pre><code class="language-rust"><span class="boring">extern crate serde;
</span><span class="boring">extern crate linera_sdk;
</span><span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">use linera_sdk::base::*;
</span>#[derive(Debug, Deserialize, Serialize)]
pub enum Message {
    Credit { owner: AccountOwner, amount: Amount },
    // Meant to be extended here
}</code></pre>
<h3 id="authentication"><a class="header" href="#authentication">Authentication</a></h3>
<p>Operations in a block are always authenticated and messages may be
authenticated. The signer of a block becomes the authenticator of all the
operations in that block. As operations are being executed by applications,
messages can be created to be sent to other chains. When they are created, they
can be configured to be authenticated. In that case, the message receives the
same authentication as the operation that created it. If handling an incoming
message creates new messages, those may also be configured to have the same
authentication as the received message.</p>
<p>In other words, the block signer can have its authority propagated across chains
through series of messages. This allows applications to safely store user state
on chains that the user may not have the authority to produce blocks. The
application may also allow only the authorized user to change that state, and
not even the chain owner is able to override that.</p>
<p>The figure below shows four chains (A, B, C, D) and some blocks produced in
them. In this example, each chain is owned by a single owner (aka. address).
Owners are in charge of producing blocks and sign new blocks using their signing
keys. Some blocks show the operations and incoming messages they accept, where
the authentication is shown inside parenthesis. All operations produced are
authenticated by the block proposer, and if these are all single user chains,
the proposer is always the chain owner. Messages that have authentication use
the one from the operation or message that created it.</p>
<p>One example in the figure is that chain A produced a block with Operation 1,
which is authenticated by the owner of chain A (written <code>(a)</code>). That operation
sent a message to chain B, and assuming the message was sent with the
authentication forwarding enabled, it is received and executed in chain B with
the authentication of <code>(a)</code>. Another example is that chain D produced a block
with Operation 2, which is authenticated by the owner of chain D (written
<code>(d)</code>). That operation sent a message to chain C, which is executed with
authentication of <code>(d)</code> like the example before. Handling that message in chain
C produced a new message, which was sent to chain B. That message, when received
by chain B is executed with the authentication of <code>(d)</code>.</p>
<pre><code class="language-ignore">                            ┌───┐     ┌─────────────────┐     ┌───┐
       Chain A owned by (a) │   ├────►│ Operation 1 (a) ├────►│   │
                            └───┘     └────────┬────────┘     └───┘
                                               │
                                               └────────────┐
                                                            ▼
                                                ┌──────────────────────────┐
                            ┌───┐     ┌───┐     │ Message from chain A (a) │
       Chain B owned by (b) │   ├────►│   ├────►│ Message from chain C (d) |
                            └───┘     └───┘     │ Operation 3 (b)          │
                                                └──────────────────────────┘
                                                            ▲
                                                   ┌────────┘
                                                   │
                            ┌───┐     ┌──────────────────────────┐     ┌───┐
       Chain C owned by (c) │   ├────►│ Message from chain D (d) ├────►│   │
                            └───┘     └──────────────────────────┘     └───┘
                                                 ▲
                                     ┌───────────┘
                                     │
                            ┌─────────────────┐     ┌───┐     ┌───┐
       Chain D owned by (d) │ Operation 2 (d) ├────►│   ├────►│   │
                            └─────────────────┘     └───┘     └───┘
</code></pre>
<p>An example where this is used is in the Fungible application, where a <code>Claim</code>
operation allows retrieving money from a chain the user does not control (but
the user still trusts will produce a block receiving their message). Without the
<code>Claim</code> operation, users would only be able to store their tokens on their own
chains, and multi-owner and public chains would have their tokens shared between
anyone able to produce a block.</p>
<p>With the <code>Claim</code> operation, users can store their tokens on another chain where
they're able to produce blocks or where they trust the owner will produce blocks
receiving their messages. Only they are able to move their tokens, even on
chains where ownership is shared or where they are not able to produce blocks.</p>
<h2 id="registering-an-application-across-chains"><a class="header" href="#registering-an-application-across-chains">Registering an Application across Chains</a></h2>
<p>If Alice is using an application on her chain and starts interacting with Bob
via the application, e.g. sends him some tokens using the <code>fungible</code> example,
the application automatically gets registered on Bob's chain, too, as soon as he
handles the incoming cross-chain messages. After that, he can execute the
application's operations on his chain, too, and e.g. send tokens to someone.</p>
<p>But there are also cases where Bob may want to start using an application he
doesn't have yet. E.g. maybe Alice regularly makes posts using the <code>social</code>
example, and Bob wants to subscribe to her.</p>
<p>In that case, trying to execute an application-specific operation would fail,
because the application is not registered on his chain. He needs to request it
from Alice first:</p>
<pre><code class="language-bash">linera request-application &lt;application-id&gt; --target-chain-id &lt;alices-chain-id&gt;
</code></pre>
<p>Once Alice processes his message (which happens automatically if she is running
the client in service mode), he can start using the application.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-linera-applications"><a class="header" href="#writing-linera-applications">Writing Linera Applications</a></h1>
<p>In this section, we'll be exploring how to create Web3 applications using the
Linera SDK.</p>
<p>We'll use a simple "counter" application as a running example.</p>
<p>We'll focus on the backend of the application, which consists of two main parts:
a <em>smart contract</em> and its GraphQL service.</p>
<p>Both the contract and the service of an application are written in Rust using
the crate <a href="https://crates.io/crates/linera-sdk"><code>linera-sdk</code></a>, and compiled to
Wasm bytecode.</p>
<p>This section should be seen as a guide versus a reference manual for the SDK.
For the reference manual, refer to the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/">documentation of the crate</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-linera-project"><a class="header" href="#creating-a-linera-project">Creating a Linera Project</a></h1>
<p>To create your Linera project, use the <code>linera project new</code> command. The command
should be executed outside the <code>linera-protocol</code> folder. It sets up the
scaffolding and requisite files:</p>
<pre><code class="language-bash">linera project new my-counter
</code></pre>
<p><code>linera project new</code> bootstraps your project by creating the following key
files:</p>
<ul>
<li><code>Cargo.toml</code>: your project's manifest filled with the necessary dependencies
to create an app;</li>
<li><code>src/lib.rs</code>: the application's ABI definition;</li>
<li><code>src/state.rs</code>: the application's state;</li>
<li><code>src/contract.rs</code>: the application's contract, and the binary target for the
contract bytecode;</li>
<li><code>src/service.rs</code>: the application's service, and the binary target for the
service bytecode.</li>
</ul>
<blockquote>
<p>When writing Linera applications it is a convention to use your app's name as
a prefix for names of <code>trait</code>, <code>struct</code>, etc. Hence, in the following manual,
we will use <code>CounterContract</code>, <code>CounterService</code>, etc.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-application-state"><a class="header" href="#creating-the-application-state">Creating the Application State</a></h1>
<p>The state of a Linera application consists of onchain data that are persisted
between transactions.</p>
<p>The <code>struct</code> which defines your application's state can be found in
<code>src/state.rs</code>. To represent our counter, we're going to use a <code>u64</code> integer.</p>
<p>While we could use a plain data-structure for the entire application state:</p>
<pre><code class="language-rust ignore">struct Counter {
  value: u64
}</code></pre>
<p>in general, we prefer to manage persistent data using the concept of "views":</p>
<blockquote>
<p><a href="https://docs.rs/linera-views/latest/linera_views/">Views</a> allow an
application to load persistent data in memory and stage modifications in a
flexible way.</p>
<p>Views resemble the persistent objects of an
<a href="https://en.wikipedia.org/wiki/Object%E2%80%93relational_mapping">ORM</a>
framework, except that they are stored as a set of key-value pairs (instead of
a SQL row).</p>
</blockquote>
<p>In this case, the struct in <code>src/state.rs</code> should be replaced by</p>
<pre><code class="language-rust ignore">/// The application state.
#[derive(RootView, async_graphql::SimpleObject)]
#[view(context = "ViewStorageContext")]
pub struct Counter {
    pub value: RegisterView&lt;u64&gt;,
    // Additional fields here will get their own key in storage.
}</code></pre>
<p>and the occurrences of <code>Application</code> in the rest of the project should be
replaced by <code>Counter</code>.</p>
<p>The derive macro <code>async_graphql::SimpleObject</code> is related to GraphQL queries
discussed in the <a href="developers/sdk/service.html">next section</a>.</p>
<p>A <code>RegisterView&lt;T&gt;</code> supports modifying a single value of type <code>T</code>. Other data
structures available in the library
<a href="https://docs.rs/linera-views/latest/linera_views/"><code>linera_views</code></a> include:</p>
<ul>
<li><code>LogView</code> for a growing vector of values;</li>
<li><code>QueueView</code> for queues;</li>
<li><code>MapView</code> and <code>CollectionView</code> for associative maps; specifically, <code>MapView</code>
in the case of static values, and <code>CollectionView</code> when values are other
views.</li>
</ul>
<p>For an exhaustive list of the different constructions, refer to the crate
<a href="https://docs.rs/linera-views/latest/linera_views/">documentation</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="defining-the-abi"><a class="header" href="#defining-the-abi">Defining the ABI</a></h1>
<p>The Application Binary Interface (ABI) of a Linera application defines how to
interact with this application from other parts of the system. It includes the
data structures, data types, and functions exposed by on-chain contracts and
services.</p>
<p>ABIs are usually defined in <code>src/lib.rs</code> and compiled across all architectures
(Wasm and native).</p>
<p>For a reference guide, check out the
<a href="https://docs.rs/linera-base/latest/linera_base/abi/">documentation of the crate</a>.</p>
<h2 id="defining-a-marker-struct"><a class="header" href="#defining-a-marker-struct">Defining a marker struct</a></h2>
<p>The library part of your application (generally in <code>src/lib.rs</code>) must define a
public empty struct that implements the <code>Abi</code> trait.</p>
<pre><code class="language-rust">struct CounterAbi;</code></pre>
<p>The <code>Abi</code> trait combines the <code>ContractAbi</code> and <code>ServiceAbi</code> traits to include
the types that your application exports.</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application (both contract
/// and service).
pub trait Abi: ContractAbi + ServiceAbi {}</code></pre>
<p>Next, we're going to implement each of the two traits.</p>
<h2 id="contract-abi"><a class="header" href="#contract-abi">Contract ABI</a></h2>
<p>The <code>ContractAbi</code> trait defines the data types that your application uses in a
contract. Each type represents a specific part of the contract's behavior:</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application contract.
pub trait ContractAbi {
    /// The type of operation executed by the application.
    ///
    /// Operations are transactions directly added to a block by the creator (and signer)
    /// of the block. Users typically use operations to start interacting with an
    /// application on their own chain.
    type Operation: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The response type of an application call.
    type Response: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;
}</code></pre>
<p>All these types must implement the <code>Serialize</code>, <code>DeserializeOwned</code>, <code>Send</code>,
<code>Sync</code>, <code>Debug</code> traits, and have a <code>'static</code> lifetime.</p>
<p>In our example, we would like to change our <code>Operation</code> to <code>u64</code>, like so:</p>
<pre><code class="language-rust"><span class="boring">extern crate linera_base;
</span><span class="boring">use linera_base::abi::ContractAbi;
</span><span class="boring">struct CounterAbi;
</span>impl ContractAbi for CounterAbi {
    type Operation = u64;
    type Response = ();
}</code></pre>
<h2 id="service-abi"><a class="header" href="#service-abi">Service ABI</a></h2>
<p>The <code>ServiceAbi</code> is in principle very similar to the <code>ContractAbi</code>, just for the
service component of your application.</p>
<p>The <code>ServiceAbi</code> trait defines the types used by the service part of your
application:</p>
<pre><code class="language-rust ignore">/// A trait that includes all the types exported by a Linera application service.
pub trait ServiceAbi {
    /// The type of a query receivable by the application's service.
    type Query: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;

    /// The response type of the application's service.
    type QueryResponse: Serialize + DeserializeOwned + Send + Sync + Debug + 'static;
}</code></pre>
<p>For our Counter example, we'll be using GraphQL to query our application so our
<code>ServiceAbi</code> should reflect that:</p>
<pre><code class="language-rust"><span class="boring">extern crate linera_base;
</span><span class="boring">extern crate async_graphql;
</span><span class="boring">use linera_base::abi::ServiceAbi;
</span><span class="boring">struct CounterAbi;
</span>impl ServiceAbi for CounterAbi {
    type Query = async_graphql::Request;
    type QueryResponse = async_graphql::Response;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-contract-binary"><a class="header" href="#writing-the-contract-binary">Writing the Contract Binary</a></h1>
<p>The contract binary is the first component of a Linera application. It can
actually change the state of the application.</p>
<p>To create a contract, we need to create a new type and implement the <code>Contract</code>
trait for it, which is as follows:</p>
<pre><code class="language-rust ignore">pub trait Contract: WithContractAbi + ContractAbi + Sized {
    /// The type of message executed by the application.
    type Message: Serialize + DeserializeOwned + Debug;

    /// Immutable parameters specific to this application (e.g. the name of a token).
    type Parameters: Serialize + DeserializeOwned + Clone + Debug;

    /// Instantiation argument passed to a new application on the chain that created it
    /// (e.g. an initial amount of tokens minted).
    type InstantiationArgument: Serialize + DeserializeOwned + Debug;

    /// Creates an in-memory instance of the contract handler.
    async fn load(runtime: ContractRuntime&lt;Self&gt;) -&gt; Self;

    /// Instantiates the application on the chain that created it.
    async fn instantiate(&amp;mut self, argument: Self::InstantiationArgument);

    /// Applies an operation from the current block.
    async fn execute_operation(&amp;mut self, operation: Self::Operation) -&gt; Self::Response;

    /// Applies a message originating from a cross-chain message.
    async fn execute_message(&amp;mut self, message: Self::Message);

    /// Finishes the execution of the current transaction.
    async fn store(self);
}</code></pre>
<p>The full trait definition can be found
<a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/linera-sdk/src/lib.rs">here</a>.</p>
<p>There's quite a bit going on here, so let's break it down and take one method at
a time.</p>
<p>For this application, we'll be using the <code>load</code>, <code>execute_operation</code> and <code>store</code>
methods.</p>
<h2 id="the-contract-lifecycle"><a class="header" href="#the-contract-lifecycle">The Contract Lifecycle</a></h2>
<p>To implement the application contract, we first create a type for the contract:</p>
<pre><code class="language-rust ignore">pub struct CounterContract {
    state: Counter,
    runtime: ContractRuntime&lt;Self&gt;,
}</code></pre>
<p>This type usually contains at least two fields: the persistent <code>state</code> defined
earlier and a handle to the runtime. The runtime provides access to information
about the current execution and also allows sending messages, among other
things. Other fields can be added, and they can be used to store volatile data
that only exists while the current transaction is being executed, and discarded
afterwards.</p>
<p>When a transaction is executed, the contract type is created through a call to
<code>Contract::load</code> method. This method receives a handle to the runtime that the
contract can use, and should use it to load the application state. For our
implementation, we will load the state and create the <code>CounterContract</code>
instance:</p>
<pre><code class="language-rust ignore">    async fn load(runtime: ContractRuntime&lt;Self&gt;) -&gt; Self {
        let state = Counter::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");
        CounterContract { state, runtime }
    }</code></pre>
<p>When the transaction finishes executing successfully, there's a final step where
all loaded application contracts are called in order to do any final checks and
persist its state to storage. That final step is a call to the <code>Contract::store</code>
method, which can be thought of as similar to executing a destructor. In our
implementation we will persist the state back to storage:</p>
<pre><code class="language-rust ignore">    async fn store(mut self) {
        self.state.save().await.expect("Failed to save state");
    }</code></pre>
<p>It's possible to do more than just saving the state, and the
<a href="developers/sdk/../advanced_topics/contract_finalize.html">Contract finalization section</a>
provides more details on that.</p>
<h2 id="instantiating-our-application"><a class="header" href="#instantiating-our-application">Instantiating our Application</a></h2>
<p>The first thing that happens when an application is created from a bytecode is
that it is instantiated. This is done by calling the contract's
<code>Contract::instantiate</code> method.</p>
<p><code>Contract::instantiate</code> is only called once when the application is created and
only on the microchain that created the application.</p>
<p>Deployment on other microchains will use the <code>Default</code> value of all sub-views in
the state if the state uses the view paradigm.</p>
<p>For our example application, we'll want to initialize the state of the
application to an arbitrary number that can be specified on application creation
using its instantiation parameters:</p>
<pre><code class="language-rust ignore">    async fn instantiate(&amp;mut self, value: u64) {
        self.state.value.set(value);
    }</code></pre>
<h2 id="implementing-the-increment-operation"><a class="header" href="#implementing-the-increment-operation">Implementing the Increment Operation</a></h2>
<p>Now that we have our counter's state and a way to initialize it to any value we
would like, we need a way to increment our counter's value. Execution requests
from block proposers or other applications are broadly called 'operations'.</p>
<p>To handle an operation, we need to implement the <code>Contract::execute_operation</code>
method. In the counter's case, the operation it will be receiving is a <code>u64</code>
which is used to increment the counter by that value:</p>
<pre><code class="language-rust ignore">    async fn execute_operation(&amp;mut self, operation: u64) {
        let current = self.state.value.get();
        self.state.value.set(current + operation);
    }</code></pre>
<h2 id="declaring-the-abi"><a class="header" href="#declaring-the-abi">Declaring the ABI</a></h2>
<p>Finally, to link our <code>Contract</code> trait implementation with the ABI of the
application, the following code is added:</p>
<pre><code class="language-rust ignore">impl WithContractAbi for CounterContract {
    type Abi = counter::CounterAbi;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-the-service-binary"><a class="header" href="#writing-the-service-binary">Writing the Service Binary</a></h1>
<p>The service binary is the second component of a Linera application. It is
compiled into a separate Bytecode from the contract and is run independently. It
is not metered (meaning that querying an application's service does not consume
gas), and can be thought of as a read-only view into your application.</p>
<p>Application states can be arbitrarily complex, and most of the time you don't
want to expose this state in its entirety to those who would like to interact
with your app. Instead, you might prefer to define a distinct set of queries
that can be made against your application.</p>
<p>The <code>Service</code> trait is how you define the interface into your application. The
<code>Service</code> trait is defined as follows:</p>
<pre><code class="language-rust ignore">pub trait Service: WithServiceAbi + ServiceAbi + Sized {
    /// Immutable parameters specific to this application.
    type Parameters: Serialize + DeserializeOwned + Send + Sync + Clone + Debug + 'static;

    /// Creates an in-memory instance of the service handler.
    async fn new(runtime: ServiceRuntime&lt;Self&gt;) -&gt; Self;

    /// Executes a read-only query on the state of this application.
    async fn handle_query(&amp;self, query: Self::Query) -&gt; Self::QueryResponse;
}</code></pre>
<p>The full service trait definition can be found
<a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/linera-sdk/src/lib.rs">here</a>.</p>
<p>Let's implement <code>Service</code> for our counter application.</p>
<p>First, we create a new type for the service, similarly to the contract:</p>
<pre><code class="language-rust ignore">pub struct CounterService {
    state: Counter,
}</code></pre>
<p>Just like with the <code>CounterContract</code> type, this type usually has two types: the
application <code>state</code> and the <code>runtime</code>. We can omit the fields if we don't use
them, so in this example we're omitting the <code>runtime</code> field, since its only used
when constructing the <code>CounterService</code> type.</p>
<p>We need to generate the necessary boilerplate for implementing the service
<a href="https://component-model.bytecodealliance.org/design/wit.html">WIT interface</a>,
export the necessary resource types and functions so that the service can be
executed. Fortunately, there is a macro to perform this code generation, so just
add the following to <code>service.rs</code>:</p>
<pre><code class="language-rust ignore">linera_sdk::service!(CounterService);</code></pre>
<p>Next, we need to implement the <code>Service</code> trait for <code>CounterService</code> type. The
first step is to define the <code>Service</code>'s associated type, which is the global
parameters specified when the application is instantiated. In our case, the
global parameters aren't used, so we can just specify the unit type:</p>
<pre><code class="language-rust ignore">#[async_trait]
impl Service for CounterService {
    type Parameters = ();
}</code></pre>
<p>Also like in contracts, we must implement a <code>load</code> constructor when implementing
the <code>Service</code> trait. The constructor receives the runtime handle and should use
it to load the application state:</p>
<pre><code class="language-rust ignore">    async fn load(runtime: ServiceRuntime&lt;Self&gt;) -&gt; Self {
        let state = Counter::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");
        Ok(CounterService { state })
    }</code></pre>
<p>Services don't have a <code>store</code> method because they are read-only and can't
persist any changes back to the storage.</p>
<p>The actual functionality of the service starts in the <code>handle_query</code> method. We
will accept GraphQL queries and handle them using the
<a href="https://github.com/async-graphql/async-graphql"><code>async-graphql</code> crate</a>. To
forward the queries to custom GraphQL handlers we will implement in the next
section, we use the following code:</p>
<pre><code class="language-rust ignore">    async fn handle_query(&amp;mut self, request: Request) -&gt; Response {
        let schema = Schema::build(
            // implemented in the next section
            QueryRoot { value: *self.state.value.get() },
            // implemented in the next section
            MutationRoot {},
            EmptySubscription,
        )
        .finish();
        schema.execute(request).await
    }
}</code></pre>
<p>Finally, as before, the following code is needed to incorporate the ABI
definitions into your <code>Service</code> implementation:</p>
<pre><code class="language-rust ignore">impl WithServiceAbi for CounterService {
    type Abi = counter::CounterAbi;
}</code></pre>
<h2 id="adding-graphql-compatibility"><a class="header" href="#adding-graphql-compatibility">Adding GraphQL compatibility</a></h2>
<p>Finally, we want our application to have GraphQL compatibility. To achieve this
we need a <code>QueryRoot</code> to respond to queries and a <code>MutationRoot</code> for creating
serialized <code>Operation</code> values that can be placed in blocks.</p>
<p>In the <code>QueryRoot</code>, we only create a single <code>value</code> query that returns the
counter's value:</p>
<pre><code class="language-rust ignore">struct QueryRoot {
    value: u64,
}

#[Object]
impl QueryRoot {
    async fn value(&amp;self) -&gt; &amp;u64 {
        &amp;self.value
    }
}</code></pre>
<p>In the <code>MutationRoot</code>, we only create one <code>increment</code> method that returns a
serialized operation to increment the counter by the provided <code>value</code>:</p>
<pre><code class="language-rust ignore">struct MutationRoot;

#[Object]
impl MutationRoot {
    async fn increment(&amp;self, value: u64) -&gt; Vec&lt;u8&gt; {
        bcs::to_bytes(&amp;value).unwrap()
    }
}</code></pre>
<p>We haven't included the imports in the above code; they are left as an exercise
to the reader (but remember to import <code>async_graphql::Object</code>). If you want the
full source code and associated tests check out the <a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/examples/counter/src/service.rs">examples
section</a> on
GitHub.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deploying-the-application"><a class="header" href="#deploying-the-application">Deploying the Application</a></h1>
<p>The first step to deploy your application is to configure a wallet. This will
determine where the application will be deployed: either to a local net or to
the public deployment (i.e. a devnet or a testnet).</p>
<h2 id="local-net"><a class="header" href="#local-net">Local Net</a></h2>
<p>To configure the local network, follow the steps in the
<a href="developers/sdk/../getting_started/hello_linera.html#using-the-initial-test-wallet">Getting Started section</a>.</p>
<p>Afterwards, the <code>LINERA_WALLET</code> and the <code>LINERA_STORAGE</code> environment variables
should be set and can be used in the <code>publish-and-create</code> command to deploy the
application while also specifying:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  target/wasm32-unknown-unknown/release/my-counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<h2 id="devnets-and-testnets"><a class="header" href="#devnets-and-testnets">Devnets and Testnets</a></h2>
<p>To configure the wallet for the current testnet while creating a new microchain,
the following command can be used:</p>
<pre><code class="language-bash">linera wallet init --with-new-chain --faucet https://faucet.testnet-archimedes.linera.net
</code></pre>
<p>The Faucet will provide the new chain with some tokens, which can then be used
to deploy the application with the <code>publish-and-create</code> command. It requires
specifying:</p>
<ol>
<li>The location of the contract bytecode</li>
<li>The location of the service bytecode</li>
<li>The JSON encoded initialization arguments</li>
</ol>
<pre><code class="language-bash">linera publish-and-create \
  target/wasm32-unknown-unknown/release/my-counter_{contract,service}.wasm \
  --json-argument "42"
</code></pre>
<h2 id="interacting-with-the-application"><a class="header" href="#interacting-with-the-application">Interacting with the Application</a></h2>
<p>To interact with the deployed application, a
<a href="developers/sdk/../core_concepts/node_service.html">node service</a> must be used.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cross-chain-messages"><a class="header" href="#cross-chain-messages">Cross-Chain Messages</a></h1>
<p>On Linera, applications are meant to be multi-chain: They are instantiated on
every chain where they are used. An application has the same application ID and
bytecode everywhere, but a separate state on every chain. To coordinate, the
instances can send <em>cross-chain messages</em> to each other. A message sent by an
application is always handled by the <em>same</em> application on the target chain: The
handling code is guaranteed to be the same as the sending code, but the state
may be different.</p>
<p>For your application, you can specify any serializable type as the <code>Message</code>
type in your <code>Contract</code> implementation. To send a message, use the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/contract/type.ContractRuntime.html"><code>ContractRuntime</code></a>
made available as an argument to the contract's
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/trait.Contract.html#tymethod.load"><code>Contract::load</code></a>
constructor. The runtime is usually stored inside the contract object, as we did
when <a href="developers/sdk/./contract.html">writing the contract binary</a>. We can then call
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/contract/type.ContractRuntime.html#prepare_message"><code>ContractRuntime::prepare_message</code></a>
to start preparing a message, and then <code>send_to</code> to send it to a destination
chain.</p>
<pre><code class="language-rust ignore">    self.runtime
        .prepare_message(message_contents)
        .send_to(destination_chain_id);</code></pre>
<p>It is also possible to send a message to a subscription channel, so that the
message is forwarded to the subscribers of that channel. All that has to be done
is specify a
<a href="https://docs.rs/linera-base/latest/linera_base/identifiers/struct.ChannelName.html"><code>ChannelName</code></a>
as the destination parameter to <code>send_to</code>.</p>
<p>After block execution in the <em>sending</em> chain, sent messages are placed in the
<em>target</em> chains' inboxes for processing. There is no guarantee that it will be
handled: For this to happen, an owner of the target chain needs to include it in
the <code>incoming_messages</code> in one of their blocks. When that happens, the
contract's <code>execute_message</code> method gets called on their chain.</p>
<p>While preparing the message to be sent, it is possible to enable authentication
forwarding and/or tracking. Authentication forwarding means that the message is
executed by the receiver with the same authenticated signer as the sender of the
message, while tracking means that the message is sent back to the sender if the
receiver rejects it. The example below enables both flags:</p>
<pre><code class="language-rust ignore">    self.runtime
        .prepare_message(message_contents)
        .with_tracking()
        .with_authentication()
        .send_to(destination_chain_id);</code></pre>
<h2 id="example-fungible-token"><a class="header" href="#example-fungible-token">Example: Fungible Token</a></h2>
<p>In the <a href="https://github.com/linera-io/linera-protocol/tree/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/examples/fungible"><code>fungible</code> example
application</a>, such a message
can be the transfer of tokens from one chain to another. If the sender includes
a <code>Transfer</code> operation on their chain, it decreases their account balance and
sends a <code>Credit</code> message to the recipient's chain:</p>
<pre><code class="language-rust ignore">async fn execute_operation(&amp;mut self, operation: Self::Operation) -&gt; Self::Response {
    match operation {
        // ...
        Operation::Transfer {
            owner,
            amount,
            target_account,
        } =&gt; {
            self.check_account_authentication(owner)?;
            self.state.debit(owner, amount).await?;
            self.finish_transfer_to_account(amount, target_account, owner)
                .await;
            FungibleResponse::Ok
        }
        // ...
    }
}

async fn finish_transfer_to_account(
    &amp;mut self,
    amount: Amount,
    target_account: Account,
    source: AccountOwner,
) {
    if target_account.chain_id == self.runtime.chain_id() {
        self.state.credit(target_account.owner, amount).await;
    } else {
        let message = Message::Credit {
            target: target_account.owner,
            amount,
            source,
        };
        self.runtime
            .prepare_message(message)
            .with_authentication()
            .with_tracking()
            .send_to(target_account.chain_id);
    }
}</code></pre>
<p>On the recipient's chain, <code>execute_message</code> is called, which increases their
account balance.</p>
<pre><code class="language-rust ignore">async fn execute_message(&amp;mut self, message: Message) {
    match message {
        Message::Credit {
            amount,
            target,
            source,
        } =&gt; {
            // ...
            self.state.credit(target, amount).await;
        }
        // ...
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calling-other-applications"><a class="header" href="#calling-other-applications">Calling other Applications</a></h1>
<p>We have seen that cross-chain messages sent by an application on one chain are
always handled by the <em>same</em> application on the target chain.</p>
<p>This section is about calling other applications using <em>cross-application
calls</em>.</p>
<p>Such calls happen on the same chain and are made with the
<a href="https://docs.rs/linera-sdk/latest/linera_sdk/contract/type.ContractRuntime.html#call_application"><code>ContractRuntime::call_application</code></a>
method:</p>
<pre><code class="language-rust ignore">pub fn call_application&lt;A: ContractAbi + Send&gt;(
    &amp;mut self,
    authenticated: bool,
    application: ApplicationId&lt;A&gt;,
    call: &amp;A::Operation,
) -&gt; A::Response {</code></pre>
<p>The <code>authenticated</code> argument specifies whether the callee is allowed to perform
actions that require authentication on behalf of the signer of the original
block that caused this call.</p>
<p>The <code>application</code> argument is the callee's application ID, and <code>A</code> is the
callee's ABI.</p>
<p>The <code>call</code> argument is the operation requested by the application call.</p>
<h2 id="example-crowd-funding"><a class="header" href="#example-crowd-funding">Example: Crowd-Funding</a></h2>
<p>The <code>crowd-funding</code> example application allows the application creator to launch
a campaign with a funding target. That target can be an amount specified in any
type of token based on the <code>fungible</code> application. Others can then pledge tokens
of that type to the campaign, and if the target is not reached by the deadline,
they are refunded.</p>
<p>If Alice used the <code>fungible</code> example to create a Pugecoin application (with an
impressionable pug as its mascot), then Bob can create a <code>crowd-funding</code>
application, use Pugecoin's application ID as <code>CrowdFundingAbi::Parameters</code>, and
specify in <code>CrowdFundingAbi::InstantiationArgument</code> that his campaign will run
for one week and has a target of 1000 Pugecoins.</p>
<p>Now let's say Carol wants to pledge 10 Pugecoin tokens to Bob's campaign.</p>
<p>First she needs to make sure she has his crowd-funding application on her chain,
e.g. using the <code>linera request-application</code> command. This will automatically
also register Alice's Pugecoin application on her chain, because it is a
dependency of Bob's.</p>
<p>Now she can make her pledge by running the <code>linera service</code> and making a query
to Bob's application:</p>
<pre><code class="language-json">mutation { pledge(owner: "User:841…6c0", amount: "10") }
</code></pre>
<p>This will add a block to Carol's chain containing the pledge operation that gets
handled by <code>CrowdFunding::execute_operation</code>, resulting in one cross-application
call and two cross-chain messages:</p>
<p>First <code>CrowdFunding::execute_operation</code> calls the <code>fungible</code> application on
Carol's chain to transfer 10 tokens to Carol's account on Bob's chain:</p>
<pre><code class="language-rust ignore">// ...
let call = fungible::Operation::Transfer {
    owner,
    amount,
    target_account,
};
// ...
self.runtime
    .call_application(/* authenticated by owner */ true, fungible_id, &amp;call);</code></pre>
<p>This causes <code>Fungible::execute_operation</code> to be run, which will create a
cross-chain message sending the amount 10 to the Pugecoin application instance
on Bob's chain.</p>
<p>After the cross-application call returns, <code>CrowdFunding::execute_operation</code>
continues to create another cross-chain message
<code>crowd_funding::Message::PledgeWithAccount</code>, which informs the crowd-funding
application on Bob's chain that the 10 tokens are meant for the campaign.</p>
<p>When Bob now adds a block to his chain that handles the two incoming messages,
first <code>Fungible::execute_message</code> gets executed, and then
<code>CrowdFunding::execute_message</code>. The latter makes another cross-application call
to transfer the 10 tokens from Carol's account to the crowd-funding
application's account (both on Bob's chain). That is successful because Carol
does now have 10 tokens on this chain and she authenticated the transfer
indirectly by signing her block. The crowd-funding application now makes a note
in its application state on Bob's chain that Carol has pledged 10 Pugecoin
tokens.</p>
<p>For the complete code please take a look at the
<a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/examples/crowd-funding/src/contract.rs"><code>crowd-funding</code></a>
and the
<a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/examples/fungible/src/contract.rs"><code>fungible</code></a>
application contracts in the <code>examples</code> folder in <code>linera-protocol</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-data-blobs"><a class="header" href="#using-data-blobs">Using Data Blobs</a></h1>
<p>Some applications may want to use static assets, like images or other data: e.g.
the <code>non-fungible</code> example application implements NFTs, and each NFT has an
associated image.</p>
<p>Data blobs are pieces of binary data that, once published on <em>any</em> chain, can be
used on <em>all</em> chains. What format they are in and what they are used for is
determined by the application(s) that read(s) them.</p>
<p>You can use the <code>linera publish-data-blob</code> command to publish the contents of a
file, as an operation in a block on one of your chains. This will print the ID
of the new blob, including its hash. Alternatively, you can run <code>linera service</code>
and use the <code>publishDataBlob</code> GraphQL mutation.</p>
<p>Applications can now use <code>runtime.read_data_blob(blob_hash)</code> to read the blob.
This works on any chain, not only the one that published it. The first time your
client executes a block reading a blob, it will download the blob from the
validators if it doesn't already have it locally.</p>
<p>In the case of the NFT app, it is only the service, not the contract, that
actually uses the blob data to display it as an image in the frontend. But we
still want to make sure that the user has the image locally as soon as they
receive an NFT, even if they don't view it yet. This can be achieved by calling
<code>runtime.assert_data_blob_exists(blob_hash)</code> in the contract: It will make sure
the data is available, without actually loading it.</p>
<p>For the complete code please take a look at the <a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/examples/non-fungible/src/contract.rs"><code>non-fungible</code>
contract</a>
and <a href="https://github.com/linera-io/linera-protocol/blob/f84b66720b92b2eab86622e26b56c3aa2adbc0c0/examples/non-fungible/src/service.rs">service</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="printing-logs-from-an-application"><a class="header" href="#printing-logs-from-an-application">Printing Logs from an Application</a></h1>
<p>Applications can use the <a href="https://crates.io/crates/log"><code>log</code> crate</a> to print
log messages with different levels of importance. Log messages are useful during
development, but they may also be useful for end users. By default the
<code>linera service</code> command will log the messages from an application if they are
of the "info" importance level or higher (briefly, <code>log::info!</code>, <code>log::warn!</code>
and <code>log::error!</code>).</p>
<p>During development it is often useful to log messages of lower importance (such
as <code>log::debug!</code> and <code>log::trace!</code>). To enable them, the <code>RUST_LOG</code> environment
variable must be set before running <code>linera service</code>. The example below enables
trace level messages from applications and enables warning level messages from
other parts of the <code>linera</code> binary:</p>
<pre><code class="language-ignore">export RUST_LOG="warn,linera_execution::wasm=trace"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h1>
<p>Linera applications can be tested using normal Rust unit tests or integration
tests. Unit tests use a mock runtime for execution, so it's useful for testing
the application as if it were running by itself on a single chain. Integration
tests use a simulated validator for testing. This allows creating chains and
adding blocks to them in order to test interactions between multiple microchains
and multiple applications.</p>
<p>Applications should consider having both types of tests. Unit tests should be
used to focus on the application's internals and core functionality. Integration
tests should be used to test how the application behaves on a more complex
environment that's closer to the real network.</p>
<blockquote>
<p>For Rust tests, the <code>cargo test</code> command can be used to run both the unit and
integration tests.</p>
</blockquote>
<h2 id="unit-tests"><a class="header" href="#unit-tests">Unit tests</a></h2>
<p>Unit tests are written beside the application's source code (i.e., inside the
<code>src</code> directory of the project). The main purpose of a unit test is to test
parts of the application in an isolated environment. Anything that's external is
usually mocked. When the <code>linera-sdk</code> is compiled with the <code>test</code> feature
enabled, the <code>ContractRuntime</code> and <code>SystemRuntime</code> types are actually mock
runtimes, and can be configured to return specific values for different tests.</p>
<h3 id="example"><a class="header" href="#example">Example</a></h3>
<p>A simple unit test is shown below, which tests if the application contract's
<code>do_something</code> method changes the application state.</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use crate::{ApplicationContract, ApplicationState};
    use linera_sdk::{util::BlockingWait, ContractRuntime};

    #[test]
    fn test_do_something() {
        let runtime = ContractRuntime::new();
        let mut contract = ApplicationContract::load(runtime).blocking_wait();

        let result = contract.do_something();

        // Check that `do_something` succeeded
        assert!(result.is_ok());
        // Check that the state in memory was updated
        assert_eq!(contract.state, ApplicationState {
            // Define the application's expected final state
            ..ApplicationState::default()
        });
        // Check that the state in memory is different from the state in storage
        assert_ne!(
            contract.state,
            ApplicationState::load(runtime.root_view_storage_context())
        );
    }
}</code></pre>
<h2 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h2>
<p>Integration tests are usually written separately from the application's source
code (i.e., inside a <code>tests</code> directory that's beside the <code>src</code> directory).</p>
<p>Integration tests use the helper types from <code>linera_sdk::test</code> to set up a
simulated Linera network, and publish blocks to microchains in order to execute
the application.</p>
<h3 id="example-1"><a class="header" href="#example-1">Example</a></h3>
<p>A simple test that sends a message between application instances on different
chains is shown below.</p>
<pre><code class="language-rust ignore">#[tokio::test]
async fn test_cross_chain_message() {
    let parameters = vec![];
    let instantiation_argument = vec![];

    let (validator, application_id) =
        TestValidator::with_current_application(parameters, instantiation_argument).await;

    let mut sender_chain = validator.get_chain(application_id.creation.chain_id).await;
    let mut receiver_chain = validator.new_chain().await;

    sender_chain
        .add_block(|block| {
            block.with_operation(
                application_id,
                Operation::SendMessageTo(receiver_chain.id()),
            )
        })
        .await;

    receiver_chain.handle_received_messages().await;

    assert_eq!(
        receiver_chain
            .query::&lt;ChainId&gt;(application_id, Query::LastSender)
            .await,
        sender_chain.id(),
    );
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>In this section, we present additional topics related to the Linera protocol.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contract-finalization"><a class="header" href="#contract-finalization">Contract Finalization</a></h1>
<p>When a transaction finishes executing successfully, there's a final step where
all loaded application contracts have their <code>Contract::store</code> implementation
called. This can be seen to be similar to executing a destructor. In that sense,
applications may want to perform some final operations after execution finished.
While finalizing, contracts may send messages, read and write to the state, but
are not allowed to call other applications, because they are all also in the
process of finalizing.</p>
<p>While finalizing, contracts can force the transaction to fail by panicking. The
block is then rejected, even if the entire transaction's operation had succeeded
before the application's <code>Contract::store</code> was called. This allows a contract to
reject transactions if other applications don't follow any required constraints
it establishes after it responds to a cross-application call.</p>
<p>As an example, a contract that executes a cross-application call with
<code>Operation::StartSession</code> may require the same caller to perform another
cross-application call with <code>Operation::EndSession</code> before the transaction ends.</p>
<pre><code class="language-rust ignore">pub struct MyContract {
    state: MyState,
    runtime: ContractRuntime&lt;Self&gt;,
    active_sessions: HashSet&lt;ApplicationId&gt;,
}

impl Contract for MyContract {
    type Message = ();
    type InstantiationArgument = ();
    type Parameters = ();

    async fn load(runtime: ContractRuntime&lt;Self&gt;) -&gt; Self {
        let state = MyState::load(runtime.root_view_storage_context())
            .await
            .expect("Failed to load state");

        MyContract {
            state,
            runtime,
            active_sessions: HashSet::new(),
        }
    }

    async fn instantiate(&amp;mut self, (): Self::InstantiationArgument) {}

    async fn execute_operation(&amp;mut self, operation: Self::Operation) -&gt; Self::Response {
        let caller = self.runtime
            .authenticated_caller_id()
            .expect("Missing caller ID");

        match operation {
            Operation::StartSession =&gt; {
                assert!(
                    self.active_sessions.insert(caller_id),
                    "Can't start more than one session for the same caller"
                );
            }
            Operation::EndSession =&gt; {
                assert!(
                    self.active_sessions.remove(&amp;caller_id),
                    "Session was not started"
                );
            }
        }
    }

    async fn execute_message(&amp;mut self, message: Self::Message) -&gt; Result&lt;(), Self::Error&gt; {
        unreachable!("This example doesn't support messages");
    }

    async fn store(&amp;mut self) {
        assert!(
            self.active_sessions.is_empty(),
            "Some sessions have not ended"
        );

        self.state.save().await.expect("Failed to save state");
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validators"><a class="header" href="#validators">Validators</a></h1>
<p>Validators run the servers that allow users to download and create blocks. They
validate, execute and cryptographically certify the blocks of all the chains.</p>
<blockquote>
<p>In Linera, every chain is backed by the same set of validators and has the
same level of security.</p>
</blockquote>
<p>The main function of validators is to guarantee the integrity of the
infrastructure in the sense that:</p>
<ul>
<li>
<p>Each block is valid, i.e. it has the correct format, its operations are
allowed, the received messages are in the correct order, and e.g. the balance
was correctly computed.</p>
</li>
<li>
<p>Every message received by one chain was actually sent by another chain.</p>
</li>
<li>
<p>If one block on a particular height is certified, no other block on the same
height is.</p>
</li>
</ul>
<p>These properties are guaranteed to hold as long as two thirds of the validators
(weighted by their stake) follow the protocol. In the future, deviating from the
protocol may cause a validator to be considered malicious and to lose their
<em>stake</em>.</p>
<p>Validators also play a role in the liveness of the system by making sure that
the history of the chains stays available. However, since validators do not
propose blocks on most chains (see <a href="developers/advanced_topics/block_creation.html">next section</a>), they do
<em>not</em> guarantee that any particular operation or message will eventually be
executed on a chain. Instead, chain owners decide whether and when to propose
new blocks, and which operations and messages to include. The current
implementation of the Linera client automatically includes all incoming messages
in new blocks. The operations are the actions the chain owner explicitly adds,
e.g. transfer.</p>
<h2 id="architecture-of-a-validator"><a class="header" href="#architecture-of-a-validator">Architecture of a validator</a></h2>
<p>Since every chain uses the same validators, adding more chains does not require
adding validators. Instead, it requires each individual validator to scale out
by adding more computation units, also known as "workers" or "physical shards".</p>
<p>In the end, a Linera validator resembles a Web2 service made of</p>
<ul>
<li>
<p>a load balancer (aka. ingress/egress), currently implemented by the binary
<code>linera-proxy</code>,</p>
</li>
<li>
<p>a number of workers, currently implemented by the binary <code>linera-server</code>,</p>
</li>
<li>
<p>a shared database, currently implemented by the abstract interface
<code>linera-storage</code>.</p>
</li>
</ul>
<pre><code class="language-ignore">Example of Linera network

                    │                                             │
                    │                                             │
┌───────────────────┼───────────────────┐     ┌───────────────────┼───────────────────┐
│ validator 1       │                   │     │ validator N       │                   │
│             ┌─────┴─────┐             │     │             ┌─────┴─────┐             │
│             │   load    │             │     │             │   load    │             │
│       ┌─────┤  balancer ├────┐        │     │       ┌─────┤  balancer ├──────┐      │
│       │     └───────────┘    │        │     │       │     └─────┬─────┘      │      │
│       │                      │        │     │       │           │            │      │
│       │                      │        │     │       │           │            │      │
│  ┌────┴─────┐           ┌────┴─────┐  │     │  ┌────┴───┐  ┌────┴────┐  ┌────┴───┐  │
│  │  worker  ├───────────┤  worker  │  │ ... │  │ worker ├──┤  worker ├──┤ worker │  │
│  │    1     │           │    2     │  │     │  │    1   │  │    2    │  │    3   │  │
│  └────┬─────┘           └────┬─────┘  │     │  └────┬───┘  └────┬────┘  └────┬───┘  │
│       │                      │        │     │       │           │            │      │
│       │                      │        │     │       │           │            │      │
│       │     ┌───────────┐    │        │     │       │     ┌─────┴─────┐      │      │
│       └─────┤  shared   ├────┘        │     │       └─────┤  shared   ├──────┘      │
│             │ database  │             │     │             │ database  │             │
│             └───────────┘             │     │             └───────────┘             │
└───────────────────────────────────────┘     └───────────────────────────────────────┘

</code></pre>
<p>Inside a validator, components communicate using the internal network of the
validator. Notably, workers use direct Remote Procedure Calls (RPCs) with each
other to deliver cross-chain messages.</p>
<p>Note that the number of workers may vary for each validator. Both the load
balancer and the shared database are represented as a single entity but are
meant to scale out in production.</p>
<blockquote>
<p>For local testing during development, we currently use a single worker and
RocksDB as a database.</p>
</blockquote>
<!--
## Configuring Networks, Workers, and Proxies

In [a previous section](../getting_started/hello_linera.md), we used the
`linera net up` command to start a local network. This should be sufficient for
most use cases when you're running a local network.

```bash
linera net up
```

However, it is possible to customize and configure the parameters of the
network.

To do this, you need the `linera-protocol` repository and the
`./scripts/run_local.sh` script.

`run_local.sh` uses the `validator_n.toml` file from the `configuration/`
directory to configure validator number `n`.

```bash
linera-server generate --validators configuration/validator_{1,2,3,4}.toml --committee committee.json
```

generates keys and writes them, together with the options from the TOML files,
to `server_1.json`, ..., `server_4.json`. It also stores the set of the new
validators' public keys in `committee.json`.

```bash
linera --wallet wallet.json --storage rocksdb:linera.db create-genesis-config 10 --genesis genesis.json --initial-funding 10 --committee committee.json
```

creates a configuration for the initial state of the network, `genesis.json`,
with 10 chains, each with a balance of 10. It also creates a `wallet.json` for a
client who owns all those chains and initializes the corresponding local node
`linera.db`.

To start the newly configured network, each validator `n` must start their
proxy:

```bash
linera-proxy server_n.json &
```

And all shards; for shard `i`:

```bash
linera-server run --storage rocksdb:server_n_i.db --server server_n.json --shard i --genesis genesis.json &
```

This will create a separate database file `server_n_i.db` for each shard. In a
production network, these would be running on different machines.

## Changing the Set of Validators

If a new validator wants to start participating, or an old one wants to leave,
all chains must be updated.

The system has one designated _admin chain_, where the validators can join or
leave, and where new _epochs_ are defined. During every epoch, the set of
validators is fixed. If you own the admin chain, you can use the `set-validator`
and `remove-validator` commands to start a new epoch with a modified set of
validators:

```bash
linera --wallet wallet.json set-validator --name 5b611b86cc1f54f73a4abfb4a2167c7327cc85a74cb2a5502431f67b554850b4 --address 127.0.0.1:9100 --votes 3
linera --wallet wallet.json remove-validator --name f65a585f05852f0610e2460a99c23faa3969f3cfce8a519f843a793dbfb4cb84
```

Chain owners must then create a block that receives the `SetCommittees` message
from the admin chain, and have it certified by the old validators. Only the
_next_ block in their chain will be certified by the new validator set!

The _admin chain_ is currently managed by a single user. In the future, it will
be a _public chain_ (i.e. managed by validators). We anticipate that Linera
epochs will change once per day (or less) and that several subsequent epochs
will overlap so that chain owners have enough time to migrate their chains.
(Chain migration may also be delegated to third parties. See
[next section](block_creation.html).)

-->
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-new-blocks"><a class="header" href="#creating-new-blocks">Creating New Blocks</a></h1>
<blockquote>
<p>In Linera, the responsibility of proposing blocks is separate from the task of
validating blocks.</p>
</blockquote>
<p>While all chains are validated in the same way, the Linera protocol defines
several types of chains, depending on how new blocks are produced.</p>
<ul>
<li>
<p>The simplest and lowest-latency type of chain is called <em>single-owner</em> chain.</p>
</li>
<li>
<p>Other types of Linera chains not currently supported in the SDK include
<em>permissioned chains</em> and <em>public chains</em> (see the
<a href="https://linera.io/whitepaper">whitepaper</a> for more context).</p>
</li>
</ul>
<blockquote>
<p>For most types of chains (all but <em>public chains</em>), Linera validators do not
need to exchange messages with each other.</p>
</blockquote>
<p>Instead, the wallets (aka. <code>linera</code> clients) of chain owners make the system
progress by proposing blocks and actively providing any additional required data
to the validators. For instance, client commands such as <code>transfer</code>,
<code>publish-bytecode</code>, or <code>open-chain</code> perform multiple steps to append a block
containing the token transfer, application publishing, or chain creation
operation:</p>
<ul>
<li>
<p>The Linera client creates a new block containing the desired operation and new
incoming messages, if there are any. It also contains the most recent block's
hash to designate its parent. The client sends the new block to all
validators.</p>
</li>
<li>
<p>The validators validate the block, i.e. check that the block satisfies the
conditions listed above, and send a cryptographic signature to the client,
indicating that they vote to append the new block. But only if they have not
voted for a different block on the same height earlier!</p>
</li>
<li>
<p>The client ideally receives a vote from every validator, but only a quorum of
votes (say, two thirds) are required: These constitute a "certificate",
proving that the block was confirmed. The client sends the certificate to
every validator.</p>
</li>
<li>
<p>The validators "execute" the block: They update their own view of the most
recent state of the chain by applying all messages and operations, and if it
generated any cross-chain messages, they send these to the appropriate
workers.</p>
</li>
</ul>
<p>To guarantee that each incoming message in a block was actually sent by another
chain, a validator will, in the second step, only <em>vote</em> for a block if it has
already executed the block that sent it. However, when receiving a valid
certificate for a block that receives a message it has not seen yet, it will
accept and <em>execute</em> the block anyway. The certificate is proof that most other
validators have seen the message, so it must be correct.</p>
<p>In the case of single-owner chains, clients must be carefully implemented so
that they never propose multiple blocks at the same height. Otherwise, the chain
may be stuck: once each of the two conflicting blocks has been signed by enough
validators, it becomes impossible to collect a quorum of votes for either block.</p>
<p>In the future, we anticipate that most users will use <em>permissioned chains</em> even
if they are the only owners of their chains. Permissioned chains have two
confirmation steps instead of one, but it is not possible to accidentally make a
chain unextendable. They also allow users to delegate certain administrative
tasks to third-parties, notably to help with epoch changes (i.e. when the
validators change if reconfigured).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="applications-that-handle-assets"><a class="header" href="#applications-that-handle-assets">Applications that Handle Assets</a></h1>
<p>In general, if you send tokens to a chain owned by someone else, you rely on
them for asset availability: if they don't handle your messages, you don't have
access to your tokens.</p>
<p>Fortunately, Linera provides a solution based on temporary chains: if the number
of parties who want to participate is limited and known in advance, we can:</p>
<ul>
<li>make them all chain owners using the <code>linera change-ownership</code> command,</li>
<li>allow only one application's operations on the chain,</li>
<li>and allow only that operation to close the chain, using
<code>linera change-application-permissions</code>.</li>
</ul>
<p>Such an application should have a designated operation or message that causes it
to close the chain: when that operation is executed, it should send back all
remaining assets, and call the runtime's <code>close_chain</code> method.</p>
<p>Once the chain is closed, owners can still create blocks to reject messages.
That way, even assets that are in flight can be returned.</p>
<p>The
<a href="https://github.com/linera-io/linera-protocol/tree/main/examples/matching-engine"><code>matching-engine</code> example application</a>
does this:</p>
<pre><code class="language-rust ignore">    async fn execute_operation(&amp;mut self, operation: Operation) -&gt; Self::Response {
        match operation {
            // ...
            Operation::CloseChain =&gt; {
                for order_id in self.state.orders.indices().await.unwrap() {
                    match self.modify_order(order_id, ModifyAmount::All).await {
                        Some(transfer) =&gt; self.send_to(transfer),
                        // Orders with amount zero may have been cleared in an earlier iteration.
                        None =&gt; continue,
                    }
                }
                self.runtime
                    .close_chain()
                    .expect("The application does not have permissions to close the chain.");
            }
        }
    }</code></pre>
<p>This enables doing atomic swaps using the Matching Engine: if you make a bid,
you are guaranteed that at any point in time you can get back either the tokens
you are offering or the tokens you bought.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="experimental-topics"><a class="header" href="#experimental-topics">Experimental Topics</a></h1>
<p>In this section, we present experimental topics related to the Linera protocol.</p>
<p>These are still in the works and subject to frequent breaking changes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="machine-learning-on-linera"><a class="header" href="#machine-learning-on-linera">Machine Learning on Linera</a></h1>
<p>The Linera application contract / service split allows for securely and
efficiently running machine learning models on the edge.</p>
<p>The application's contract retrieves the correct model with all the correctness
guarantees enforced by the consensus algorithm, while the client performs
inference off-chain, in the un-metered service. Since the service is running on
the user's own hardware, it can be implicitly trusted.</p>
<h2 id="guidelines"><a class="header" href="#guidelines">Guidelines</a></h2>
<p>The existing examples use the <a href="https://github.com/huggingface/candle"><code>candle</code></a>
framework by <a href="https://huggingface.co/">Hugging Face</a> as the underlying ML
framework.</p>
<p><code>candle</code> is a minimalist ML framework for Rust with a focus on performance and
usability. It also compiles to Wasm and has great support for Wasm both in and
outside the browser. Check candle's
<a href="https://github.com/huggingface/candle/tree/main/candle-wasm-examples">examples</a>
for inspiration on the types of models which are supported.</p>
<h3 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h3>
<p>To add ML capabilities to your existing Linera project, you'll need to add the
<code>candle-core</code>, <code>getrandom</code>, <code>rand</code> and <code>tokenizers</code> dependencies to your Linera
project:</p>
<pre><code class="language-toml">candle-core = "0.4.1"
getrandom = { version = "0.2.12", default-features = false, features = ["custom"] }
rand = "0.8.5"
</code></pre>
<p>Optionally, to run Large Language Models, you'll also need the
<code>candle-transformers</code> and <code>transformers</code> crate:</p>
<pre><code class="language-toml">candle-transformers = "0.4.1"
tokenizers = { git = "https://github.com/christos-h/tokenizers", default-features = false, features = ["unstable_wasm"] }
</code></pre>
<h3 id="providing-randomness"><a class="header" href="#providing-randomness">Providing Randomness</a></h3>
<p>ML frameworks use random numbers to perform inference. Linera services run in a
Wasm VM which does not have access to the OS Rng. For this reason, we need to
manually seed RNG used by <code>candle</code>. We do this by writing a custom <code>getrandom</code>.</p>
<p>Create a file under <code>src/random.rs</code> and add the following:</p>
<pre><code class="language-rust ignore">use std::sync::{Mutex, OnceLock};

use rand::{rngs::StdRng, Rng, SeedableRng};

static RNG: OnceLock&lt;Mutex&lt;StdRng&gt;&gt; = OnceLock::new();

fn custom_getrandom(buf: &amp;mut [u8]) -&gt; Result&lt;(), getrandom::Error&gt; {
    let seed = [0u8; 32];
    RNG.get_or_init(|| Mutex::new(StdRng::from_seed(seed)))
        .lock()
        .expect("failed to get RNG lock")
        .fill(buf);
    Ok(())
}

getrandom::register_custom_getrandom!(custom_getrandom);</code></pre>
<p>This will enable <code>candle</code> and any other crates which rely on <code>getrandom</code> access
to a deterministic RNG. If deterministic behaviour is not desired, the System
API can be used to seed the RNG from a timestamp.</p>
<h3 id="loading-the-model-into-the-service"><a class="header" href="#loading-the-model-into-the-service">Loading the model into the Service</a></h3>
<p>Models cannot currently be saved on-chain; for more information see the
<code>Limitations</code> below.</p>
<p>To perform model inference, the model must be loaded into the service. To do
this we'll use the <code>fetch_url</code> API when a query is made against the service:</p>
<pre><code class="language-rust ignore">impl Service for MyService {
    async fn handle_query(&amp;self, request: Request) -&gt; Response {
        // do some stuff here
        let raw_weights = self.runtime.fetch_url("https://my-model-provider.com/model.bin");
        // do more stuff here
    }
}</code></pre>
<p>This can be served from a local webserver or pulled directly from a model
provider such as Hugging Face.</p>
<p>At this point we have the raw bytes which correspond to the models and
tokenizer. <code>candle</code> supports multiple formats for storing model weights, both
quantized and not (<code>gguf</code>, <code>ggml</code>, <code>safetensors</code>, etc.).</p>
<p>Depending on the model format that you're using, <code>candle</code> exposes convenience
functions to convert the bytes into a typed <code>struct</code> which can then be used to
perform inference. Below is an example for a non-quantized Llama 2 model:</p>
<pre><code class="language-rust ignore">    fn load_llama_model(cursor: &amp;mut Cursor&lt;Vec&lt;u8&gt;&gt;) -&gt; Result&lt;(Llama, Cache), candle_core::Error&gt; {
        let config = llama2_c::Config::from_reader(cursor)?;
        let weights =
            llama2_c_weights::TransformerWeights::from_reader(cursor, &amp;config, &amp;Device::Cpu)?;
        let vb = weights.var_builder(&amp;config, &amp;Device::Cpu)?;
        let cache = llama2_c::Cache::new(true, &amp;config, vb.pp("rot"))?;
        let llama = Llama::load(vb, config.clone())?;
        Ok((llama, cache))
    }</code></pre>
<h3 id="inference"><a class="header" href="#inference">Inference</a></h3>
<p>Performing inference using <code>candle</code> is not a 'one-size-fits-all' process.
Different models require different logic to perform inference so the specifics
of how to perform inference are beyond the scope of this document.</p>
<p>Luckily, there are multiple examples which can be used as guidelines on how to
perform inference in Wasm:</p>
<ul>
<li><a href="https://github.com/linera-io/linera-protocol/tree/main/examples/llm">Llm Stories</a></li>
<li><a href="https://github.com/linera-io/linera-protocol/tree/main/examples/gen-nft">Generative NFTs</a></li>
<li><a href="https://github.com/huggingface/candle/tree/main/candle-wasm-examples">Candle Wasm Examples</a></li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<h3 id="hardware-acceleration"><a class="header" href="#hardware-acceleration">Hardware Acceleration</a></h3>
<p>Although SIMD instructions <em>are</em> supported by the service runtime, general
purpose GPU hardware acceleration is
<a href="https://github.com/linera-io/linera-protocol/issues/1931">not currently supported</a>.
Therefore, performance in local model inference is degraded for larger models.</p>
<h3 id="on-chain-models"><a class="header" href="#on-chain-models">On-Chain Models</a></h3>
<p>Due to block-size constraints, models need to be stored off-chain until the
introduction of the
<a href="https://github.com/linera-io/linera-protocol/issues/1981">Blob API</a>. The Blob
API will enable large binary blobs to be stored on-chain, the correctness and
availability of which is guaranteed by the validators.</p>
<h3 id="maximum-model-size"><a class="header" href="#maximum-model-size">Maximum Model Size</a></h3>
<p>The maximum size of a model which can be loaded into an application's service is
currently constrained by:</p>
<ol>
<li>The addressable memory of the service's Wasm runtime being 4 GiB.</li>
<li>Not being able to load models directly to the GPU.</li>
</ol>
<p>It is recommended that smaller models (50 MB - 100 MB) are used at current state
of development.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-operator-manual"><a class="header" href="#node-operator-manual">Node Operator Manual</a></h1>
<p>This section of the Linera Manual is meant for operators running Linera
validator nodes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="devnets"><a class="header" href="#devnets">Devnets</a></h1>
<p>This section discusses how to deploy developer networks, aka "Devnets", for
testing and development purposes.</p>
<p>Devnets always start from a genesis configuration and an empty state. Validator
nodes are run by the core Linera team. Devnets do not handle real assets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-devnets-with-docker-compose"><a class="header" href="#running-devnets-with-docker-compose">Running devnets with Docker Compose</a></h1>
<p>In this section, we use Docker Compose to run a simple devnet with a single
validator.</p>
<p>Docker Compose is a tool for defining and managing multi-container Docker
applications. It allows you to describe the services, networks, and volumes of
your application in a single YAML file (docker-compose.yml). With Docker
Compose, you can easily start, stop, and manage all the containers in your
application as a single unit using simple commands like docker-compose up and
docker-compose down.</p>
<p>For a more complete setup, consider using Kind as described
<a href="operators/devnets/kind.html">in the next section</a>.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>This section covers everything you need to install to run a Linera network with
Docker Compose.</p>
<p>Note: This section has been tested only on Linux.</p>
<h3 id="docker-compose-requirements"><a class="header" href="#docker-compose-requirements">Docker Compose Requirements</a></h3>
<p>To install Docker Compose see the
<a href="https://docs.docker.com/compose/install/">installing Docker Compose</a> section in
the Docker docs.</p>
<h3 id="installing-the-linera-toolchain"><a class="header" href="#installing-the-linera-toolchain">Installing the Linera Toolchain</a></h3>
<p>To install the Linera Toolchain refer to the
<a href="operators/devnets/../../developers/getting_started/installation.html#installing-from-github">installation section</a>.</p>
<p>You want to install the toolchain from GitHub, as you'll be using the repository
to run the Docker Compose validator service.</p>
<h2 id="running-with-docker-compose"><a class="header" href="#running-with-docker-compose">Running with Docker Compose</a></h2>
<p>To run a local devnet with Docker Compose, navigate to the root of the
<code>linera-protocol</code> repository and run:</p>
<pre><code class="language-bash">cd docker &amp;&amp; ./compose.sh
</code></pre>
<p>This will take some time as Docker images are built from the Linera source. When
the service is ready, a temporary wallet and database are available under the
<code>docker</code> subdirectory.</p>
<p>Referencing these variables with the <code>linera</code> binary will enable you to interact
with the devnet:</p>
<pre><code class="language-bash">$ linera --wallet wallet.json --storage rocksdb:linera.db sync
2024-06-07T14:19:32.751359Z  INFO linera: Synchronizing chain information
2024-06-07T14:19:32.771842Z  INFO linera::client_context: Saved user chain states
2024-06-07T14:19:32.771850Z  INFO linera: Synchronized chain information in 20 ms
$ linera --wallet wallet.json --storage rocksdb:linera.db query-balance
2024-06-07T14:19:36.958149Z  INFO linera: Evaluating the local balance of e476187f6ddfeb9d588c7b45d3df334d5501d6499b3f9ad5595cae86cce16a65 by staging execution of known incoming messages
2024-06-07T14:19:36.959481Z  INFO linera: Balance obtained after 1 ms
10.
</code></pre>
<p>The network is transient, so killing the script will perform a cleanup operation
destroying wallets, storage and volumes associated with the network.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-devnets-with-kind"><a class="header" href="#running-devnets-with-kind">Running devnets with <code>kind</code></a></h1>
<p>In this section, we use <code>kind</code> to run a full devnet (network of validators)
locally.</p>
<p>Kind (Kubernetes in Docker) is a tool for running local Kubernetes clusters
using Docker container nodes. Kind uses Docker to create a cluster of containers
that simulate the Kubernetes control plane and worker nodes, allowing developers
to easily create, manage, and test multi-node clusters on their local machine.</p>
<h2 id="installation-2"><a class="header" href="#installation-2">Installation</a></h2>
<p>This section covers everything you need to install to run a Linera network with
<code>kind.</code></p>
<h3 id="linera-toolchain-requirements"><a class="header" href="#linera-toolchain-requirements">Linera Toolchain Requirements</a></h3>
<p>The operating systems currently supported by the Linera toolchain can be
summarized as follows:</p>
<div class="table-wrapper"><table><thead><tr><th>Linux x86 64-bit</th><th>Mac OS (M1 / M2)</th><th>Mac OS (x86)</th><th>Windows</th></tr></thead><tbody>
<tr><td>✓ Main platform</td><td>✓ Working</td><td>✓ Working</td><td>Untested</td></tr>
</tbody></table>
</div>
<p>The main prerequisites to install the Linera toolchain are Rust, Wasm, and
Protoc. They can be installed as follows on Linux:</p>
<ul>
<li>
<p>Rust and Wasm</p>
<ul>
<li><code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li><code>rustup target add wasm32-unknown-unknown</code></li>
</ul>
</li>
<li>
<p>Protoc</p>
<ul>
<li><code>curl -LO https://github.com/protocolbuffers/protobuf/releases/download/v21.11/protoc-21.11-linux-x86_64.zip</code></li>
<li><code>unzip protoc-21.11-linux-x86_64.zip -d $HOME/.local</code></li>
<li>If <code>~/.local</code> is not in your path, add it:
<code>export PATH="$PATH:$HOME/.local/bin"</code></li>
</ul>
</li>
<li>
<p>On certain Linux distributions, you may have to install development packages
such as <code>g++</code>, <code>libclang-dev</code> and <code>libssl-dev</code>.</p>
</li>
</ul>
<p>For MacOS support see the installation section on
<a href="https://github.com/linera-io/linera-protocol/blob/main/INSTALL.md">GitHub</a>.</p>
<p>This manual was tested with the following Rust toolchain:</p>
<pre><code class="language-text">[toolchain]
channel = "1.81.0"
components = [ "clippy", "rustfmt", "rust-src" ]
targets = [ "wasm32-unknown-unknown" ]
profile = "minimal"
</code></pre>
<h3 id="local-kubernetes-requirements"><a class="header" href="#local-kubernetes-requirements">Local Kubernetes Requirements</a></h3>
<p>To run <code>kind</code> locally, you also need the following dependencies:</p>
<ol>
<li><a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation"><code>kind</code></a></li>
<li><a href="https://kubernetes.io/docs/tasks/tools/"><code>kubectl</code></a></li>
<li><a href="https://docs.docker.com/get-docker/"><code>docker</code></a></li>
<li><a href="https://helm.sh/docs/intro/install/"><code>helm</code></a></li>
<li><a href="https://github.com/databus23/helm-diff"><code>helm-diff</code></a></li>
<li><a href="https://github.com/helmfile/helmfile?tab=readme-ov-file#installation"><code>helmfile</code></a></li>
</ol>
<h3 id="installing-the-linera-toolchain-1"><a class="header" href="#installing-the-linera-toolchain-1">Installing the Linera Toolchain</a></h3>
<p>To install the <code>Linera</code> toolchain, download the Linera source from
<a href="https://github.com/linera-io/linera-protocol">GitHub</a>:</p>
<pre><code class="language-bash">git clone https://github.com/linera-io/linera-protocol.git
cd linera-protocol
git checkout -t origin/testnet_archimedes  # Current release branch
</code></pre>
<p>and to install the Linera toolchain:</p>
<pre><code class="language-bash">cargo install --locked --path linera-service --features kubernetes
</code></pre>
<h2 id="running-with-kind"><a class="header" href="#running-with-kind">Running with <code>kind</code></a></h2>
<p>To run a local devnet with <code>kind</code>, navigate to the root of the <code>linera-protocol</code>
repository and run:</p>
<pre><code class="language-bash">linera net up --kubernetes
</code></pre>
<p>This will take some time as Docker images are built from the Linera source. When
the cluster is ready, some text is written to the process output containing the
exports required to configure your wallet for the devnet - something like:</p>
<pre><code class="language-bash">export LINERA_WALLET="/tmp/.tmpIOelqk/wallet_0.json"
export LINERA_STORAGE="rocksdb:/tmp/.tmpIOelqk/client_0.db"
</code></pre>
<p>Exporting these variables in a new terminal will enable you to interact with the
devnet:</p>
<pre><code class="language-bash">$ linera sync-balance
2024-05-21T22:30:12.061199Z  INFO linera: Synchronizing chain information and querying the local balance
2024-05-21T22:30:12.061218Z  WARN linera: This command is deprecated. Use `linera sync &amp;&amp; linera query-balance` instead.
2024-05-21T22:30:12.065787Z  INFO linera::client_context: Saved user chain states
2024-05-21T22:30:12.065792Z  INFO linera: Operation confirmed after 4 ms
1000000.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testnets"><a class="header" href="#testnets">Testnets</a></h1>
<p>This section discusses how to deploy a validator node and join an existing
Testnet.</p>
<p>In a Testnet, the validator nodes are run by different operators. Testnets will
gain in stability and decentralization over time in preparation of the mainnet
launch. Testnets do not handle real assets.</p>
<blockquote>
<p>In the initial Testnets of Linera, the set of validator nodes will be managed
by the Linera Core team.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joining-an-existing-testnet"><a class="header" href="#joining-an-existing-testnet">Joining an Existing Testnet</a></h1>
<p>In this section, we use Docker Compose to run a validator and join an existing
Testnet.</p>
<h2 id="infrastructure-requirements"><a class="header" href="#infrastructure-requirements">Infrastructure Requirements</a></h2>
<p>Validators run via Docker Compose do not come with a pre-packaged load balancer
to perform TLS termination (unlike validators running on Kubernetes).</p>
<p>The load balancer configuration <strong>must</strong> have the following properties:</p>
<ol>
<li>Support HTTP/2 connections.</li>
<li>Support gRPC connections.</li>
<li>Support long-lived HTTP/2 connections.</li>
<li>Support a maximum body size of up to 20 MB.</li>
<li>Provide TLS termination with a certificate signed by a known CA.</li>
</ol>
<p>Finally, the load balancer that performs TLS termination must redirect traffic
from <code>443</code> to <code>19100</code> (the port exposed by the proxy).</p>
<h3 id="using-nginx"><a class="header" href="#using-nginx">Using Nginx</a></h3>
<p>Minimum supported version: 1.18.0.</p>
<p>Below is an example Nginx configuration which upholds the infrastructure
requirements found in <code>/etc/nginx/sites-available/default</code>:</p>
<pre><code class="language-ignore">server {
        listen 80 http2;

        location / {
                grpc_pass grpc://127.0.0.1:19100;
        }
}

server {
    listen 443 ssl http2;
    server_name &lt;hostname&gt;; # e.g. my-subdomain.my-domain.net

    # SSL certificates
    ssl_certificate &lt;ssl-cert-path&gt;; # e.g. /etc/letsencrypt/live/my-subdomain.my-domain.net/fullchain.pem
    ssl_certificate_key &lt;ssl-key-path&gt;; # e.g. /etc/letsencrypt/live/my-subdomain.my-domain.net/privkey.pem;

    # Proxy traffic to the service running on port 19100.
    location / {
        grpc_pass grpc://127.0.0.1:19100;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    keepalive_timeout 10m 60s;
    grpc_read_timeout 10m;
    grpc_send_timeout 10m;

    client_header_timeout 10m;
    client_body_timeout 10m;
}
</code></pre>
<h3 id="using-caddy"><a class="header" href="#using-caddy">Using Caddy</a></h3>
<p>Minimum supported version: v2.4.3</p>
<p>Below is an example Caddy configuration which upholds the infrastructure
requirements found in <code>/etc/caddy/Caddyfile</code>:</p>
<pre><code class="language-ignore">example.com {
  reverse_proxy localhost:19100 {
    transport http {
      versions h2c
      read_timeout 10m
      write_timeout 10m
    }
  }
}
</code></pre>
<h3 id="scylladb-configuration"><a class="header" href="#scylladb-configuration">ScyllaDB Configuration</a></h3>
<p>ScyllaDB is an open-source distributed NoSQL database built for high-performance
and low-latency. Linera validators use ScyllaDB as their persistent storage.</p>
<p>ScyllaDB may require kernel parameters to be modified in order to work.
Specifically the number of events allowed in asynchronous I/O contexts.</p>
<p>To set this run:</p>
<pre><code class="language-bash">echo 1048576 &gt; /proc/sys/fs/aio-max-nr
</code></pre>
<h2 id="one-click-deploy"><a class="header" href="#one-click-deploy">One-Click Deploy</a></h2>
<blockquote>
<p>Note: This section was only tested under Linux.</p>
</blockquote>
<p>After downloading the <code>linera-protocol</code> repository, and checking out the testnet
branch <code>testnet_archimedes</code> you can run
<code>scripts/deploy-validator.sh &lt;hostname&gt;</code> to deploy a Linera validator.</p>
<p>For example:</p>
<pre><code class="language-bash">$ git fetch origin
$ git checkout -t origin/testnet_archimedes
$ scripts/deploy-validator.sh linera.mydomain.com --remote-image
</code></pre>
<p>The deployment automatically listens for new image updates and will pull them
automatically.</p>
<blockquote>
<p>Note: Optionally you can build the image from source by not specifying
<code>--remote-image</code>.</p>
</blockquote>
<p>The public key will be printed after the command has finished executing, for
example:</p>
<pre><code class="language-bash">$ scripts/deploy-validator.sh linera.mydomain.com --remote-image
...
Public Key: 92f934525762a9ed99fcc3e3d3e35a825235dae133f2682b78fe22a742bac196
</code></pre>
<p>The public key, in this case beginning with <code>92f</code>, must be communicated to the
Linera Protocol core team along with the chosen host name for onboarding in the
next epoch.</p>
<p>For a more bespoke deployment, refer to the manual installation instructions
below.</p>
<blockquote>
<p>Note: If you have previously deployed a validator you may need to remove old
docker volumes (<code>docker_linera-scylla-data</code> and <code>docker_linera-shared</code>).</p>
</blockquote>
<h3 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying installation</a></h3>
<p>To verify the installation, you can use the <code>linera query-validator</code> command.
For example:</p>
<pre><code class="language-bash">$ linera wallet init --with-new-chain --faucet https://faucet.testnet-archimedes.linera.net
$ linera query-validator grpcs:my-domain.com:443

RPC API hash: kd/Ru73B4ZZjXYkFqqSzoWzqpWi+NX+8IJLXOODjSko
GraphQL API hash: eZqzuBlLT0bcoQUjOCPf2j22NfZUWG95id4pdlUmhgs
WIT API hash: 4/gsw8G+47OUoEWK6hJRGt9R69RanU/OidmX7OKhqfk
Source code: https://github.com/linera-io/linera-protocol/tree/

0cd20d06af5262540535347d4cc6e5952a921d1a6a7f6dd0982159c9311cfb3e
</code></pre>
<p>The last line is the hash of the network's genesis configuration.</p>
<h2 id="manual-installation"><a class="header" href="#manual-installation">Manual Installation</a></h2>
<p>This section covers everything you need to install to run a Linera validator
node with Docker Compose.</p>
<blockquote>
<p>Note: This section was only tested under Linux.</p>
</blockquote>
<h3 id="docker-compose-requirements-1"><a class="header" href="#docker-compose-requirements-1">Docker Compose Requirements</a></h3>
<p>To install Docker Compose see the
<a href="https://docs.docker.com/compose/install/">installing Docker Compose</a> section in
the Docker docs.</p>
<h3 id="installing-the-linera-toolchain-2"><a class="header" href="#installing-the-linera-toolchain-2">Installing the Linera Toolchain</a></h3>
<blockquote>
<p>When installing the Linera Toolchain, you <strong>must</strong> check out the
<code>testnet_archimedes</code> branch.</p>
</blockquote>
<p>To install the Linera Toolchain refer to the
<a href="operators/testnets/../../developers/getting_started/installation.html#installing-from-github">installation section</a>.</p>
<p>You want to install the toolchain from GitHub, as you'll be using the repository
to run the Docker Compose validator service.</p>
<h2 id="setting-up-a-linera-validator"><a class="header" href="#setting-up-a-linera-validator">Setting up a Linera Validator</a></h2>
<p>For the next section, we'll be working out of the <code>docker</code> subdirectory in the
<code>linera-protocol</code> repository.</p>
<h3 id="creating-your-validator-configuration"><a class="header" href="#creating-your-validator-configuration">Creating your Validator Configuration</a></h3>
<p>Validators are configured using a TOML file. You can use the following template
to set up your own validator configuration:</p>
<pre><code class="language-toml">server_config_path = "server.json"
host = "&lt;your-host&gt;" # e.g. my-subdomain.my-domain.net
port = 19100
metrics_host = "proxy"
metrics_port = 21100
internal_host = "proxy"
internal_port = 20100
[external_protocol]
Grpc = "ClearText" # Depending on your load balancer you may need "Tls" here.
[internal_protocol]
Grpc = "ClearText"

[[shards]]
host = "shard"
port = 19100
metrics_host = "shard"
metrics_port = 21100

</code></pre>
<h3 id="genesis-configuration"><a class="header" href="#genesis-configuration">Genesis Configuration</a></h3>
<p>The genesis configuration describes the committee of validators and chains at
the point of network creation. It is required for validators to function.</p>
<p>Initially, the genesis configuration for each Testnet will be found in a public
bucket managed by the Linera Protocol core team.</p>
<p>An example can be found here:</p>
<pre><code class="language-bash">wget "https://storage.googleapis.com/linera-io-dev-public/testnet-archimedes/genesis.json"
</code></pre>
<h3 id="creating-your-keys"><a class="header" href="#creating-your-keys">Creating Your Keys</a></h3>
<p>Now that the
<a href="operators/testnets/joining.html#creating-your-validator-configuration">validator configuration</a> has
been created and the <a href="operators/testnets/joining.html#genesis-configuration">genesis configuration</a>
is available, the validator private keys can be generated.</p>
<p>To generate the private keys, the <code>linera-server</code> binary is used:</p>
<pre><code class="language-bash">linera-server generate --validators /path/to/validator/configuration.toml
</code></pre>
<p>This will generate a file called <code>server.json</code> with the information required for
a validator to operate, including a cryptographic keypair.</p>
<p>The public key will be printed after the command has finished executing, for
example:</p>
<pre><code class="language-bash">$ linera-server generate --validators /path/to/validator/configuration.toml
2024-07-01T16:51:32.881255Z  INFO linera_version::version_info: Linera protocol: v0.12.0
2024-07-01T16:51:32.881273Z  INFO linera_version::version_info: RPC API hash: p//G+L8e12ZRwUdWoGHWYvWA/03kO0n6gtgKS4D4Q0o
2024-07-01T16:51:32.881274Z  INFO linera_version::version_info: GraphQL API hash: KcS5z1lEg+L9QjcP99l5vNSc7LfCwnwEsfDvMZGJ/PM
2024-07-01T16:51:32.881277Z  INFO linera_version::version_info: WIT API hash: p//G+L8e12ZRwUdWoGHWYvWA/03kO0n6gtgKS4D4Q0o
2024-07-01T16:51:32.881279Z  INFO linera_version::version_info: Source code: https://github.com/linera-io/linera-protocol/tree/44b3e1ab15 (dirty)
2024-07-01T16:51:32.881519Z  INFO linera_server: Wrote server config server.json
92f934525762a9ed99fcc3e3d3e35a825235dae133f2682b78fe22a742bac196 # &lt;- Public Key
</code></pre>
<p>The public key, in this case beginning with <code>92f</code>, must be communicated to the
Linera Protocol core team along with the chosen host name for onboarding in the
next epoch.</p>
<blockquote>
<p>Note: Before being included in the next epoch, validator nodes will receive no
traffic from existing users.</p>
</blockquote>
<h3 id="building-the-linera-docker-image"><a class="header" href="#building-the-linera-docker-image">Building the Linera Docker image</a></h3>
<p>To build the Linera Docker image, run the following command from the root of the
<code>linera-protocol</code> repository:</p>
<pre><code class="language-bash">docker build --build-arg git_commit="$(git rev-parse --short HEAD)" -f docker/Dockerfile . -t linera
</code></pre>
<p>This can take several minutes.</p>
<h3 id="running-a-validator-node"><a class="header" href="#running-a-validator-node">Running a Validator Node</a></h3>
<p>Now that the genesis configuration is available at <code>docker/genesis.json</code> and the
server configuration is available at <code>docker/server.json</code>, the validator can be
started by running from inside the <code>docker</code> directory:</p>
<pre><code class="language-bash">cd docker &amp;&amp; docker compose up -d
</code></pre>
<p>This will run the Docker Compose deployment in a detached mode. It can take a
few minutes for the ScyllaDB image to be downloaded and started.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<p>Congrats on reading this manual to the end! In this section, we will be sharing
additional material.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>
<ul>
<li>
<p><strong>Address</strong>: A unique public alphanumeric identifier used to designate the
identity of an entity on the Linera network.</p>
</li>
<li>
<p><strong>Admin Chain</strong>: The Linera Network has one designated <em>admin chain</em> where
validators can join or leave and where new epochs are defined.</p>
</li>
<li>
<p><strong>Application</strong>: Similar to a smart-contract on Ethereum, an application is
code deployed on the Linera network which is executed by all validators. An
application has a metered <em>contract</em> which executes 'business logic' and
modifies state and an unmetered 'service' which is a read-only view into an
application's state.</p>
</li>
<li>
<p><strong>Byzantine Fault-Tolerant (BFT)</strong>: A system which can operate correctly and
achieve consensus even if components of the system fail or act maliciously.</p>
</li>
<li>
<p><strong>Block Height</strong>: The number of blocks preceding a given block on a specific
microchain.</p>
</li>
<li>
<p><strong>Block Proposal</strong>: A candidate block proposed by a chain owner which may be
selected at the next block height.</p>
</li>
<li>
<p><strong>Bytecode</strong>: A collection of bytes corresponding to a program that can be run
by the Wasm virtual machine.</p>
</li>
<li>
<p><strong>Client</strong>: The <code>linera</code> program, which is a local node and wallet operated by
users to make requests to the network. In Linera, clients drive the network by
proposing new blocks and validators are mostly reactive.</p>
</li>
<li>
<p><strong>Certificate</strong>: A value with signatures from a quorum of validators. Values
can be confirmed blocks, meaning that the block has been added to the chain
and is final. There are other values that are used for reaching consensus,
before certifying a confirmed block.</p>
</li>
<li>
<p><strong>Committee</strong>: The set of all validators for a particular <em>epoch</em>, together
with their voting weights.</p>
</li>
<li>
<p><strong>Chain Owner</strong>: The owner of a <em>user chain</em> or <em>permissioned chain</em>. This is
represented as the alphanumeric identifier derived from the hash of the
owner's public key.</p>
</li>
<li>
<p><strong>Channel</strong>: A broadcast mechanism enabling publish-subscribe behavior across
chains.</p>
</li>
<li>
<p><strong>Contract</strong>: The metered part of an application which executes business logic
and can modify the application's state.</p>
</li>
<li>
<p><strong>Cross-Application Call</strong>: A call from one application to another on the
<em>same chain</em>.</p>
</li>
<li>
<p><strong>Cross-Chain Message</strong>: A message containing a data payload which is sent
from one chain to another. Cross-Chain messages are the asynchronous
communication primitive which enable communication on the same application
running on different chains.</p>
</li>
<li>
<p><strong>Devnet</strong>: An experimental deployment of the Linera protocol meant for
testing and development. In a Devnet, the validator nodes are often run by the
same operator for simplicity. Devnets may be shut down and restarted from a
genesis configuration any time. Devnets do not handle real assets.</p>
</li>
<li>
<p><strong>Epoch</strong>: A period of time when a particular set of validators with
particular voting weights can certify new blocks. Since each chain has to
transition explicitly from one epoch to the next, epochs can overlap.</p>
</li>
<li>
<p><strong>Genesis Configuration</strong>: The configuration determining the state of a newly
created network; the voting weights of the initial set of validators, the
initial fee structure, and initial chains that the network starts with.</p>
</li>
<li>
<p><strong>Inbox</strong>: A commutative data structure storing incoming messages for a given
chain.</p>
</li>
<li>
<p><strong>Mainnet</strong>: A deployment meant to be used in production, with real assets.</p>
</li>
<li>
<p><strong>Message</strong>: See 'Cross-Chain Message'.</p>
</li>
<li>
<p><strong>Microchain</strong>: A lightweight chain of blocks holding a subset of the
network's state running on every validator. This is used interchangeably with
'chain'. <em>All</em> Linera chains are microchains.</p>
</li>
<li>
<p><strong>Network</strong>: The totality of all protocol participants. A network is the
combination of committee, clients and auditors.</p>
</li>
<li>
<p><strong>Operation</strong>: Operations are either transactions directly added to a block by
the creator (and signer) of the block, or calls to an application from
another. Users typically use operations to start interacting with an
application on their own chain.</p>
</li>
<li>
<p><strong>Permissioned Chain</strong>: A microchain which is owned by more than one user.
Users take turns proposing blocks and the likelihood of selection is
proportional to their <em>weight</em>.</p>
</li>
<li>
<p><strong>Project</strong>: The collection of files and dependencies which are built into the
bytecode which is instantiated as an application on the Linera Network.</p>
</li>
<li>
<p><strong>Public Chain</strong>: A microchain with full BFT consensus with a strict set of
permissions relied on for the operation of the network.</p>
</li>
<li>
<p><strong>Quorum</strong>: A set of validators representing &gt; ⅔ of the total stake. A quorum
is required to create a certificate.</p>
</li>
<li>
<p><strong>Single-Owner Chain</strong>: See 'User Chain'.</p>
</li>
<li>
<p><strong>Service</strong>: An unmetered read-only view into an application's state.</p>
</li>
<li>
<p><strong>Shard</strong>: A logical subset of all microchains on a given validator. This
corresponds directly to a physical <em>worker</em>.</p>
</li>
<li>
<p><strong>Stake</strong>: An amount of tokens pledged by a validator or auditor, as a
collateral to guarantee their honest and correct participation in the network.</p>
</li>
<li>
<p><strong>Testnet</strong>: A deployment of the Linera protocol meant for testing and
development. In a Testnet, the validator nodes are operated by multiple
operators. Testnets will gain in stability and decentralization over time in
preparation of the mainnet launch. Testnets do not handle real assets.</p>
</li>
<li>
<p><strong>User Chain</strong>: Used interchangeably with <em>Single-Owner Chain</em>. User chains
are chains which are owned by a single user on the network. Only the chain
owner can propose blocks, and therefore only the chain owner can forcibly
advance the state of a user chain.</p>
</li>
<li>
<p><strong>Validator</strong>: Validators run the servers that allow users to download and
create blocks. They validate, execute and cryptographically certify the blocks
of all the chains.</p>
</li>
<li>
<p><strong>View</strong>: Views are like an Object-Relational Mapping (ORM) for mapping
complex types onto key-value stores. Views group complex state changes into a
set of elementary operations and commit them atomically. They are full or
partial in-memory representations of complex types saved on disk in a
key-value store</p>
</li>
<li>
<p><strong>Wallet</strong>: A file containing a user's public and private keys along with
configuration and information regarding the chains they own.</p>
</li>
<li>
<p><strong>WebAssembly (Wasm)</strong>: A binary compilation target and instruction format
that runs on a stack-based VM. Linera applications are compiled to Wasm and
run on Wasm VMs inside validators and clients.</p>
</li>
<li>
<p><strong>Web3</strong>: A natural evolution of the internet focusing on decentralization by
leveraging blockchains and smart contracts.</p>
</li>
<li>
<p><strong>Worker</strong>: A process which runs a subset of all microchains on a given
validator. This corresponds directly to a logical <em>shard</em>.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="videos"><a class="header" href="#videos">Videos</a></h1>
<p>We're constantly improving the SDK and creating new material. Below are some of
our recent tutorials and presentations videos:</p>
<h3 id="rust-on-linera-spring-2024-hackathon-kick-off"><a class="header" href="#rust-on-linera-spring-2024-hackathon-kick-off"><a href="https://www.youtube.com/watch?v=gVOHsS7d5qI">Rust on Linera: Spring 2024 Hackathon Kick-Off</a></a></h3>
<p>Exploring the Linera protocol with our founder, Mathieu Baudet, followed by an
overview of the Rust on Linera hackathon specifics and resources.</p>
<h3 id="rust-on-linera-spring-2024-hackathon-coding-workshop-1"><a class="header" href="#rust-on-linera-spring-2024-hackathon-coding-workshop-1"><a href="https://www.youtube.com/watch?v=Px_9AapmZPY">Rust on Linera: Spring 2024 Hackathon Coding Workshop #1</a></a></h3>
<p>Building and deploying your first Linera application using the Linera devnet
with one of our engineers, Christos Hadjiaslanis.</p>
<h3 id="rust-on-linera-spring-2024-hackathon-coding-workshop-2"><a class="header" href="#rust-on-linera-spring-2024-hackathon-coding-workshop-2"><a href="https://www.youtube.com/watch?v=Y-wunX2SwSs">Rust on Linera: Spring 2024 Hackathon Coding Workshop #2</a></a></h3>
<p>Making your Linera application robust by adding testing, logging, and more.</p>
<h3 id="rust-on-linera-spring-2024-hackathon-coding-workshop-3"><a class="header" href="#rust-on-linera-spring-2024-hackathon-coding-workshop-3"><a href="https://www.youtube.com/watch?v=UkAYdolV9vw">Rust on Linera: Spring 2024 Hackathon Coding Workshop #3</a></a></h3>
<p>Building a meta-fungible token application on Linera.</p>
<h3 id="secure-reactive-web3-for-everyone"><a class="header" href="#secure-reactive-web3-for-everyone"><a href="https://www.youtube.com/watch?v=GViOuQzs_fo">Secure Reactive Web3 for Everyone</a></a></h3>
<p>Discussing how user wallets track on-chain data using WebAssembly and
microchains with Mathieu Baudet and Andreas Fackler from Eth Prague 2024.</p>
<h3 id="linera-x-movement-labs-integrated-day-party-panel-discussion"><a class="header" href="#linera-x-movement-labs-integrated-day-party-panel-discussion"><a href="https://www.youtube.com/watch?v=BSWEZU70WAE">Linera x Movement Labs Integrated Day Party Panel Discussion</a></a></h3>
<p>Discussing the importance of blockchain and Web3 technologies, challenges and
opportunities in the industry, and the significance of security and user
empowerment in the new web ecosystem from Consensus 2024.</p>
<p>For the latest videos and highlights, check out our
<a href="https://www.youtube.com/@linera_io">YouTube channel</a> and
<a href="https://x.com/linera_io">X (formerly Twitter) Media</a>.</p>
<p><em>Happy viewing!</em></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-8b5bd394.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-ba43d0c1.js"></script>

        <!-- Custom JS scripts -->
        <script src="custom-6e1704cf.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
